<!-- @noSnoop -->
<html>
<head>
  <meta charset="utf-8">
  <title id="pageTitle">Universal Dashboard - Live Matrix</title>
  <!-- Load Chart.js from local file -->
  <script src="/file/web1/chart.js"></script>
  <!-- Load Chart.js Zoom Plugin from local files -->
  <script src="/file/hammer.min.js"></script>
  <script src="/file/chartjs-plugin-zoom.min.js"></script>
  <script type='text/javascript' src='/requirejs/config.js' onerror=" window.requirejsConfigFailed = true;"></script>
  <script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js' onerror=" window.requirejsFailed = true;"></script>
  <!-- Load external CSS -->
  <link rel="stylesheet" href="/file/web1/css/dashboard-styles.css">
  <!-- Load external JavaScript modules -->
  <script src="/file/web1/js/dashboard-state.js?v=2.0"></script>
  <script src="/file/web1/js/ui-handlers.js?v=2.0"></script>
  <script src="/file/web1/js/drag-drop.js?v=2.0"></script>
  <script src="/file/web1/js/point-operations.js?v=2.0"></script>
  <script src="/file/web1/js/config-storage.js?v=2.0"></script>
  <script src="/file/web1/js/user-dashboard.js?v=2.0"></script>
  <script src="/file/web1/js/loading-overlay.js?v=2.0"></script>
  <script src="/file/web1/js/chart-utils.js?v=2.0"></script>
  <script src="/file/web1/js/alarm-utils.js?v=2.0"></script>
  <script src="/file/web1/js/discovery-utils.js?v=2.0"></script>
  <style>
    /* Page-specific styles only - main styles are in dashboard-styles.css */
  </style>
</head>
<body>
  <div class="container">
    <h1 id="pageHeader">Universal Dashboard</h1>
    
    <div class="tabs">
      <button class="tab-btn active" onclick="window.switchTab('universal')">🌐 Universal Dashboard</button>
      <button class="tab-btn" onclick="window.switchTab('multi')">Multi-View</button>
      <button class="tab-btn" onclick="window.switchTab('alarmDashboard')">🚨 Alarm Dashboard</button>
      <button class="tab-btn" onclick="window.switchTab('history')">History Chart</button>
    </div>

    <!-- GLOBAL STATUS -->
    <div id="status" class="status">Initializing...</div>

    <!-- TAB 1: MULTI VIEW -->
    <div id="multiView" class="view-panel">
      <div class="selector-box">
        <label>Select Units to Compare</label>
        <div class="multi-select-area" id="multiSelectArea">
           <!-- Checkboxes go here -->
        </div>
        <div style="margin-top: 10px; display: flex; gap: 10px;">
           <button style="flex:1" onclick="window.toggleAllMulti(true)">Select All</button>
           <button style="flex:1" onclick="window.toggleAllMulti(false)">Select None</button>
        </div>
        <div style="margin-top: 10px;">
          <label style="font-size:11px; color:#888;">Filter Point Type:</label>
          <select id="multiCategoryFilter" style="background:#2d2d2d; color:white; border:1px solid #555; padding:8px; border-radius:4px; width:100%;">
             <option value="all">All Types</option>
             <option value="temperature">🌡️ Temperatures</option>
             <option value="call">🔔 Calls/Demands</option>
             <option value="speed">⚡ Speeds/VFDs</option>
             <option value="position">🎚️ Positions</option>
             <option value="pressure">💨 Pressure</option>
             <option value="flow">💨 Flow</option>
             <option value="humidity">💧 Humidity</option>
             <option value="power">⚡ Power/Energy</option>
             <option value="status">🔘 Status/Control</option>
             <option value="alarm">🚨 Alarms/Faults</option>
             <option value="setpoint">🎯 Setpoints</option>
          </select>
        </div>
        <button class="action-btn" onclick="window.loadMultiMatrix()">LOAD MATRIX</button>
      </div>
      <div id="multiTableArea"></div>
    </div>

    <!-- TAB 2: BUILDING-WIDE SEARCH -->
    <div id="buildingSearchView" class="view-panel">
      <div class="selector-box">
        <label style="font-weight:bold; margin-bottom:10px; display:block;">🔍 Search All Equipment for Specific Points</label>
        <p style="font-size:11px; color:#888; margin-bottom:15px;">
          Find all points across the entire building that match your search pattern (e.g., "space temp", "supply", "fan speed")
        </p>

        <div style="display:flex; gap:10px; margin-bottom:15px;">
          <div style="flex:1;">
            <label>Search Pattern</label>
            <input type="text" id="buildingSearchPattern" placeholder="e.g., space temp, outdoor, fan, cool call"
                   style="width:100%; padding:8px; background:#2d2d2d; color:white; border:1px solid #555; border-radius:4px;">
          </div>
          <div style="flex:0 0 200px;">
            <label>Filter by Type</label>
            <select id="buildingSearchTypeFilter" style="width:100%; padding:8px; background:#2d2d2d; color:white; border:1px solid #555; border-radius:4px;">
              <option value="all">All Types</option>
              <option value="temperature">🌡️ Temperatures</option>
              <option value="call">🔔 Calls/Demands</option>
              <option value="speed">⚡ Speeds/VFDs</option>
              <option value="position">🎚️ Positions</option>
              <option value="pressure">💨 Pressure</option>
              <option value="flow">💨 Flow</option>
              <option value="humidity">💧 Humidity</option>
              <option value="power">⚡ Power/Energy</option>
              <option value="status">🔘 Status/Control</option>
              <option value="alarm">🚨 Alarms/Faults</option>
              <option value="setpoint">🎯 Setpoints</option>
            </select>
          </div>
        </div>

        <div style="display:flex; gap:10px;">
          <button class="action-btn" onclick="window.searchBuildingWide()" style="flex:1;">🔍 SEARCH BUILDING</button>
          <button onclick="window.addAllSearchResultsToChart()" style="flex:1; padding:10px; background:#2196F3; color:white; border:none; border-radius:4px; cursor:pointer;">
            📊 Add All to Chart
          </button>
          <button onclick="window.clearBuildingSearch()" style="flex:0 0 120px; padding:10px; background:#666; color:white; border:none; border-radius:4px; cursor:pointer;">
            🗑️ Clear Results
          </button>
        </div>

        <div id="buildingSearchStats" style="margin-top:15px; font-size:11px; color:#888;"></div>
      </div>
      <div id="buildingSearchArea"></div>
    </div>

    <!-- TAB: UNIVERSAL DASHBOARD -->
    <div id="universalView" class="view-panel">
      <div style="padding:20px; width:100%; max-width:100%; box-sizing:border-box; overflow-x:hidden;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
          <div style="display:flex; align-items:center; gap:15px;">
            <h2 style="color:#4CAF50; margin:0;">🌐 Universal Dashboard</h2>
            <select id="dashboardSelector" onchange="window.switchToDashboard(this.value)" style="padding:8px 12px; background:#2d2d2d; color:#fff; border:1px solid #444; border-radius:4px; cursor:pointer; font-size:12px;">
              <option value="">-- Select Dashboard --</option>
            </select>
            <button onclick="window.openSaveDashboardModal()" class="action-btn" style="background:#4CAF50; padding:8px 12px; font-size:12px;">💾 Save Current</button>
            <button onclick="window.openManageDashboardsModal()" class="action-btn" style="background:#FF9800; padding:8px 12px; font-size:12px;">📋 Manage</button>
          </div>
          <div style="display:flex; gap:10px;">
            <button onclick="window.openRulesEditor()" class="action-btn" style="background:#9C27B0;">✏️ Edit Rules</button>
            <button onclick="window.openSyncOptions()" class="action-btn" style="background:#607D8B;">⚙️ Sync Options</button>
            <button id="refreshDiscoveryBtn" onclick="window.refreshDiscovery()" class="action-btn refresh-discovery-btn" style="background:linear-gradient(135deg, #4CAF50 0%, #45a049 100%); font-size:14px; font-weight:bold; padding:12px 24px; box-shadow:0 4px 15px rgba(76,175,80,0.4); border:2px solid #66BB6A; animation:pulse-green 2s infinite;">🔄 Refresh Discovery</button>
            <span id="superUserPanel" style="display:none;">
              <button onclick="window.openUserManagementModal()" class="action-btn" style="background:#E91E63;">👥 Users</button>
            </span>
          </div>
        </div>
        <div id="discoveryStatus" style="padding:15px; background:#1e1e1e; border-radius:4px; margin-bottom:20px; color:#888; font-size:12px;">
          No discovery run yet. Click "🔄 Refresh Discovery" to scan the entire station and discover all devices.
        </div>
        <div id="universalDashboardContent" style="color:#888; text-align:center; padding:40px; width:100%; max-width:100%; box-sizing:border-box; overflow-x:hidden;">
          <p>👆 Click "Refresh Discovery" above to start</p>
        </div>
      </div>
    </div>

    <!-- TAB 3: ALARM DASHBOARD -->
    <div id="alarmDashboardView" class="view-panel">
      <div class="selector-box">
        <label style="font-weight:bold; margin-bottom:10px; display:block;">🚨 Active Alarms & Faults</label>
        <p style="font-size:11px; color:#888; margin-bottom:15px;">
          Real-time view of all active alarms from the Niagara alarm database
        </p>

        <div style="display:flex; gap:10px; align-items:flex-end; margin-bottom:15px;">
          <div style="flex:1;">
            <label>Filter Alarms</label>
            <select id="alarmFilterType" style="width:100%; padding:8px; background:#2d2d2d; color:white; border:1px solid #555; border-radius:4px;">
              <option value="all">All Alarms</option>
              <option value="unacked">Unacknowledged Only</option>
              <option value="active" selected>Active (Not Returned to Normal)</option>
              <option value="equipment">By Equipment...</option>
            </select>
          </div>
          <div style="flex:1;">
            <label>Search Equipment/Point</label>
            <input type="text" id="alarmSearchText" placeholder="e.g., HP5, Space Temp"
                   style="width:100%; padding:8px; background:#2d2d2d; color:white; border:1px solid #555; border-radius:4px;">
          </div>
          <button class="action-btn" onclick="window.refreshAlarmDashboard()" style="flex:0 0 150px;">
            🔄 Refresh Alarms
          </button>
          <label style="flex:0 0 auto; font-size:11px; color:#888; display:flex; align-items:center; gap:5px;">
            <input type="checkbox" id="alarmAutoRefresh" checked onchange="window.toggleAlarmAutoRefresh()"> Auto-refresh (30s)
          </label>
        </div>

        <div id="alarmStats" style="margin-bottom:15px; padding:10px; background:#1e1e1e; border-radius:4px; display:flex; gap:20px;">
          <div>
            <span style="color:#888; font-size:11px;">TOTAL ALARMS:</span>
            <span id="alarmCountTotal" style="color:#f44336; font-weight:bold; margin-left:5px;">0</span>
          </div>
          <div>
            <span style="color:#888; font-size:11px;">UNACKED:</span>
            <span id="alarmCountUnacked" style="color:#ff9800; font-weight:bold; margin-left:5px;">0</span>
          </div>
          <div>
            <span style="color:#888; font-size:11px;">ACTIVE:</span>
            <span id="alarmCountActive" style="color:#2196f3; font-weight:bold; margin-left:5px;">0</span>
          </div>
        </div>
      </div>
      <div id="alarmDashboardArea"></div>
    </div>

    <!-- TAB 4: ENHANCED HISTORY VIEW -->
    <div id="historyView" class="view-panel">
      <!-- Selection Panel -->
      <div class="selector-box">
         <label style="font-weight:bold; margin-bottom:10px; display:block;">📊 Multi-Point History Comparison</label>

         <!-- Equipment & Point Selection -->
         <div style="display:flex; gap:10px; margin-bottom:15px;">
             <div style="flex:1;">
                 <label>Select Equipment</label>
                 <div style="display:flex; gap:5px;">
                    <select id="histUnitDropdown" onchange="window.updateHistoryPxButton()" style="flex:1;">
                        <option>Loading...</option>
                    </select>
                    <button id="histPxBtn" onclick="window.openHistoryPx()" style="background:#2196F3; color:white; border:none; border-radius:4px; cursor:pointer; padding:0 10px; display:none;" title="View Graphic">
                        🖼️
                    </button>
                 </div>
             </div>
             <div style="flex:1;">
                 <label>Select Points (from selected equipment)</label>
                 <select id="histPointDropdown" size="5" multiple style="height:auto;">
                    <option disabled>-- Select Equipment First --</option>
                 </select>
             </div>
         </div>

         <!-- Selected Points List -->
         <div id="selectedPointsList" style="background:#1e1e1e; padding:10px; border-radius:4px; margin-bottom:15px; min-height:40px;">
            <label style="color:#888; font-size:11px; text-transform:uppercase;">Selected Points:</label>
            <div id="selectedPointsContent" style="margin-top:5px; color:#4CAF50; font-size:13px;">
               None selected
            </div>
         </div>

         <!-- Time Range -->
         <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; margin-bottom:15px;">
            <div>
               <label>Quick Range</label>
               <select id="histPeriod" onchange="window.updateDateInputs()">
                  <option value="custom">Custom Range</option>
                  <option value="last24h" selected>Last 24 Hours</option>
                  <option value="last48h">Last 48 Hours</option>
                  <option value="lastWeek">Last Week</option>
                  <option value="lastMonth">Last Month</option>
               </select>
            </div>
            <div>
               <label>Start Date/Time</label>
               <input type="datetime-local" id="histStartDate" onchange="document.getElementById('histPeriod').value='custom'">
            </div>
            <div>
               <label>End Date/Time</label>
               <input type="datetime-local" id="histEndDate" onchange="document.getElementById('histPeriod').value='custom'">
            </div>
         </div>

         <!-- Chart Controls -->
         <div style="display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px; margin-bottom:15px;">
            <div>
               <label>Chart Type</label>
               <select id="histChartType">
                  <option value="line">Line Chart</option>
                  <option value="bar">Bar Chart</option>
                  <option value="scatter">Scatter Plot</option>
               </select>
            </div>
            <div>
               <label>Y-Axis Mode</label>
               <select id="histYAxisMode">
                  <option value="auto">Auto (Dual if needed)</option>
                  <option value="shared">Shared Y-Axis</option>
                  <option value="separate">Always Dual Y-Axis</option>
               </select>
            </div>
            <div>
               <label>Max Points</label>
               <select id="histMaxPoints">
                  <option value="100">100 points</option>
                  <option value="200" selected>200 points</option>
                  <option value="500">500 points</option>
                  <option value="1000">1000 points</option>
               </select>
            </div>
            <div style="display:flex; align-items:flex-end; gap:15px;">
               <label style="cursor:pointer; display:flex; align-items:center; gap:5px;">
                  <input type="checkbox" id="histShowGrid" checked> Show Grid
               </label>
               <div style="display:flex; flex-direction:column; gap:3px;">
                  <label style="font-size:11px; color:#888;">Status Filter:</label>
                  <select id="histStatusFilter" onchange="if(window.chartInstance) window.renderHistoryChart();" style="background:#2d2d2d; color:white; border:1px solid #555; padding:4px; border-radius:4px;">
                     <option value="all">All Points</option>
                     <option value="alarmsOnly">🔴 Alarms Only</option>
                     <option value="faultsOnly">❌ Faults Only</option>
                     <option value="anyIssue">⚠️ Any Issue</option>
                     <option value="okOnly">✅ OK Only</option>
                  </select>
               </div>
               <div style="display:flex; flex-direction:column; gap:3px;">
                  <label style="font-size:11px; color:#888;">Point Type:</label>
                  <select id="histCategoryFilter" onchange="if(window.chartInstance) window.renderHistoryChart();" style="background:#2d2d2d; color:white; border:1px solid #555; padding:4px; border-radius:4px;">
                     <option value="all">All Types</option>
                     <option value="temperature">🌡️ Temperatures</option>
                     <option value="call">🔔 Calls/Demands</option>
                     <option value="speed">⚡ Speeds/VFDs</option>
                     <option value="position">🎚️ Positions</option>
                     <option value="pressure">💨 Pressure</option>
                     <option value="flow">💨 Flow</option>
                     <option value="humidity">💧 Humidity</option>
                     <option value="power">⚡ Power/Energy</option>
                     <option value="status">🔘 Status/Control</option>
                     <option value="alarm">🚨 Alarms/Faults</option>
                     <option value="setpoint">🎯 Setpoints</option>
                  </select>
               </div>
            </div>
         </div>

         <!-- Action Buttons -->
         <div style="display:flex; gap:10px;">
            <button class="action-btn" onclick="window.addSelectedPoints()" style="flex:1;">
               ➕ ADD SELECTED POINTS
            </button>
            <button class="action-btn" onclick="window.plotHistoryChart()" style="flex:2;">
               📊 PLOT / REFRESH CHART
            </button>
            <button onclick="window.clearAllHistoryPoints()" style="flex:1; background:#f44336;">
               🗑️ CLEAR ALL
            </button>
         </div>
      </div>

      <!-- Chart Box -->
      <div class="chart-box" style="height:500px;">
         <canvas id="myChart"></canvas>
      </div>

      <!-- Chart Controls Under Chart -->
      <div style="background:#2d2d2d; padding:10px; border-radius:8px; margin-top:10px;">
         <div style="display:flex; gap:10px; justify-content:center; margin-bottom:8px;">
            <button onclick="window.resetChartZoom()" style="background:#555; padding:8px 16px; border:none; color:white; border-radius:4px; cursor:pointer;">
               🔄 Refresh / Reset
            </button>
            <button onclick="window.exportHistoryCSV()" style="background:#555; padding:8px 16px; border:none; color:white; border-radius:4px; cursor:pointer;">
               📥 Export CSV
            </button>
            <button onclick="window.toggleDataTable()" style="background:#555; padding:8px 16px; border:none; color:white; border-radius:4px; cursor:pointer;">
               📋 Toggle Data Table
            </button>
            <button onclick="window.resetChartColors()" style="background:#555; padding:8px 16px; border:none; color:white; border-radius:4px; cursor:pointer;">
               🎨 Reset Colors
            </button>
         </div>
         <div style="text-align:center; color:#888; font-size:11px;">
            💡 Zoom: Mouse wheel to zoom | Drag to select area | Ctrl+Drag to pan | Reset button to restore<br>
            🎨 Legend: Click color box to change color | Click X or text to hide/show
         </div>
      </div>

      <!-- Data Table View -->
      <div id="historyDataTable" style="display:none; margin-top:15px; background:#2d2d2d; padding:15px; border-radius:8px;">
         <h3 style="color:#4CAF50; margin-bottom:10px;">📋 Data Table View</h3>
         <div style="max-height:400px; overflow:auto;">
            <table class="live-table" id="histDataTableContent">
               <thead><tr><th>Timestamp</th><th>Point</th><th>Value</th></tr></thead>
               <tbody><tr><td colspan="3" style="text-align:center; color:#888;">No data to display</td></tr></tbody>
            </table>
         </div>
      </div>

    </div>

    <!-- GLOBAL ADD POINT -->
    <div id="addPointArea" class="add-point-bar" style="display:none">
       <div>
         <label style="color:#888; font-size:11px; text-transform:uppercase;">Add Column / Point</label>
         <select id="availablePointsDropdown">
            <option value="">-- Scan a unit first --</option>
         </select>
       </div>
       <button class="add-btn" onclick="window.addGlobalColumn()" style="background:#4CAF50; border:none; color:white; font-weight:bold; height:38px;">ADD</button>
    </div>

  </div>

<script>
// ========================================
// MAIN APPLICATION INITIALIZATION
// ========================================
// NOTE: DashboardState, UI handlers, drag-drop, and point operations
// are now loaded from external JS files:
// - /file/web1/js/dashboard-state.js
// - /file/web1/js/ui-handlers.js
// - /file/web1/js/drag-drop.js
// - /file/web1/js/point-operations.js

// Keyboard shortcuts for undo/redo (uses functions from external files)
document.addEventListener('keydown', function(e) {
  // Ctrl+Z for Undo
  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
    e.preventDefault();
    if (window.undo) window.undo();
  }
  // Ctrl+Y or Ctrl+Shift+Z for Redo
  if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
    e.preventDefault();
    if (window.redo) window.redo();
  }
});

// Define window.switchTab early so HTML onclick handlers can use it
window.switchTab = function(tab) {
  // This will be replaced by the full implementation below
  // But this stub prevents "not a function" errors during page load
  console.log('switchTab called (stub):', tab);
};

// Fallback if RequireJS fails to load
(function() {
  "use strict";
  
  function showError(message) {
    var statusDiv = document.getElementById('status');
    if (statusDiv) {
      statusDiv.innerHTML = '<div style="color:#f44336; padding:20px; text-align:center; background:#2d2d2d; border-radius:8px; border:2px solid #f44336;">⚠️ ' + message + '<br><br><button onclick="location.reload()" style="background:#4CAF50; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; font-size:14px; margin-top:10px;">Refresh Page</button></div>';
    }
    if (document.body) {
      document.body.style.backgroundColor = "#1a1a1a";
      document.body.style.color = "#e0e0e0";
    }
  }
  
  function initializeDashboard(baja, Promise) {
    if (document.body) {
      document.body.style.backgroundColor = "#1a1a1a";
      document.body.style.color = "#e0e0e0";
    }
    
    // Update status
    var statusDiv = document.getElementById('status');
    if (statusDiv) {
      statusDiv.textContent = 'Loading dashboard...';
    }
  
  // --- CONFIGURATION ---
  var CONFIG = {
    basePath: 'Drivers/BacnetNetwork',
    searchPattern: 'HP',
    pointFolderPath: ['points', 'Monitor'],
    defaults: [
      { label: 'Space Temp',   match: ['Space Temp', 'Space_Temp', 'CtrlSpaceTemp'] },
      { label: 'Supply Temp',  match: ['Supply Temp', 'Supply Air', 'DaTemp', 'Discharge Air'] },
      { label: 'Setpoint',     match: ['Effective Setpoint', 'no_EffSp', 'Active Setpoint'] },
      { label: 'Cool Call',    match: ['Cool Call', 'Cooling Output', 'Cooling_Valve'] },
      { label: 'Heat Call',    match: ['Heat Call', 'Heating Output', 'Heating_Valve'] }
    ]
  };

    // --- STATE ---
    var foundEquipment = [];
    var isEquipmentScanned = false; // NEW: Track if we have done the heavy scan
    var currentSubscriber = null;
    var globalColumns = JSON.parse(JSON.stringify(CONFIG.defaults)); 
    var knownAvailablePoints = new Set();
    var chartInstance = null; // For Chart.js

  // ============================================================================
  // SECTION: Universal Dashboard - Config Storage & Discovery System
  // ============================================================================

  // --- FILE SYSTEM OPERATIONS ---
  // NOTE: BoxError messages in console for non-existent files are EXPECTED behavior.
  // BajaScript logs these errors internally even though we catch them.
  // This is normal on first load when config files don't exist yet.
  //
  // PERSISTENCE STRATEGY:
  // Primary: localStorage (works immediately, no setup required, browser-specific)
  // Optional: RPC file creation (requires Java component - see saveConfigFileViaRpc)
  // Fallback: HTTP PUT (only works for existing files)
  //
  // localStorage is actually ideal for user-specific dashboard configs since:
  // - Each user gets their own config automatically
  // - No file system permissions needed
  // - Works across page reloads
  // - No server-side code required
  async function loadConfigFile(filePath) {
    try {
      // Normalize file path
      // If path doesn't start with "files/", it's relative to HTML file's directory
      // (e.g., "dashboard-config.json" will be in same directory as HTML file)
      let normalizedPath = filePath;
      if (!normalizedPath.startsWith('files/')) {
        // Keep as-is - will be relative to current directory (same as HTML file)
      } else {
        // Remove "files/" prefix for standard file system paths
        normalizedPath = normalizedPath.substring(6);
      }
      const fileOrd = 'file:^' + normalizedPath;
      console.log('🔍 [DEBUG] NOTE: If file doesn\'t exist, BoxError will appear in console (this is expected)');
      
      // Try to get the file - this will throw BoxError if file doesn't exist
      // BajaScript logs this error internally, but we catch it and handle gracefully
      let file;
      try {
        file = await baja.Ord.make(fileOrd).get();
      } catch (ordError) {
        // File doesn't exist - this is expected on first run
        // BoxError is logged by BajaScript internally, but we handle it here
        console.log('🔍 [DEBUG] File does not exist (expected on first run):', fileOrd);
        return null;
      }
      
      if (!file || file.isDirectory()) {
        return null;
      }
      
      // Get read URI and fetch content
      const readUri = file.getReadUri();
      if (!readUri) {
        return null;
      }
      
      const res = await fetch(readUri);
      if (!res.ok) {
        return null;
      }
      
      const text = await res.text();
      const config = JSON.parse(text);
      return config;
    } catch (err) {
      // File doesn't exist or can't be read - this is expected on first run
      console.log('🔍 [DEBUG] loadConfigFile error (expected):', err.name, err.message);
      return null;
    }
  }

  // --- RPC-BASED FILE CREATION (requires Java component with @NiagaraRpc method) ---
  // To enable RPC file creation, create a Java Program component with this code:
  // 
  // import javax.baja.file.*;
  // import javax.baja.naming.*;
  // import java.io.*;
  // 
  // @NiagaraRpc
  // public void writeFile(String filePath, String content) throws Exception {
  //   // Create BOrd for the file (matches Java example pattern)
  //   BOrd fileOrd = BOrd.make("file:^" + filePath);
  //   
  //   // Parse the ORD to get FilePath
  //   OrdQuery[] query = fileOrd.parse();
  //   FilePath filePathObj = (FilePath)query[query.length - 1];
  //   
  //   BIFile file = null;
  //   try {
  //     // Try to get existing file
  //     file = (BIFile)fileOrd.get(fileOrd.resolve().getComponent());
  //   } catch(UnresolvedException ure) {
  //     // File doesn't exist - create it using BFileSystem (matches Java example)
  //     file = BFileSystem.INSTANCE.makeFile(filePathObj);
  //   }
  //   
  //   // Get local file path and write using FileWriter (matches Java example)
  //   File localFile = BFileSystem.INSTANCE.pathToLocalFile(file.getFilePath());
  //   FileWriter fileWriter = new FileWriter(localFile, false);
  //   try {
  //     fileWriter.write(content);
  //   } finally {
  //     fileWriter.close();
  //   }
  // }
  // 
  // 
  // SETUP INSTRUCTIONS:
  // 1. Create a Program component in Workbench
  // 2. Place it at: station:|slot:/Services/FileService
  // 3. Copy the Java code above into the Program's source
  // 4. The RPC method will be automatically available
  // 
  // ALTERNATIVE: If you can't create a Program component, the code will fall back to:
  // - localStorage (works immediately, no setup needed)
  // - HTTP PUT (may fail for new files, but works for existing files)
  //
  async function saveConfigFileViaRpc(filePath, data) {
    try {
      // Normalize path: remove "files/" prefix if present
      let normalizedPath = filePath;
      if (normalizedPath.startsWith('files/')) {
        normalizedPath = normalizedPath.substring(6);
      }
      
      // Method 1: Try to find a file service component (adjust ORD as needed)
      const possibleServiceOrds = [
        'station:|slot:/Services/FileService',
        'station:|slot:/Services/DashboardFileService',
        'station:|slot:/FileService',
        'station:|slot:/Services/ConfigService'
      ];
      
      for (const serviceOrd of possibleServiceOrds) {
        try {
          const service = await baja.Ord.make(serviceOrd).get();
          if (service) {
            // Call RPC method (adjust method name as needed: 'writeFile', 'saveFile', etc.)
            const result = await service.rpc('writeFile', normalizedPath, JSON.stringify(data, null, 2));
            return true;
          }
        } catch (e) {
          // Service not found at this location, try next
          continue;
        }
      }
      
      // Method 2: Try HTTP RPC servlet approach (doesn't require component reference)
      // Format: POST /rpc/methodName/ord with JSON array of arguments
      // Try common service locations via HTTP RPC
      const rpcServiceOrds = [
        'type:web:FileService',
        'station:|slot:/Services/FileService',
        'station:|slot:/Services/DashboardFileService'
      ];
      
      for (const rpcOrd of rpcServiceOrds) {
        try {
          // Get CSRF token if available (required for RPC calls)
          let csrfToken = '';
          try {
            // Try to get CSRF token from meta tag or global variable
            const csrfMeta = document.querySelector('meta[name="csrf-token"]');
            if (csrfMeta) {
              csrfToken = csrfMeta.getAttribute('content');
            } else if (window.csrfToken) {
              csrfToken = window.csrfToken;
            }
          } catch (e) {
            // CSRF token not available, continue anyway
          }
          
          const rpcUrl = '/rpc/writeFile/' + encodeURIComponent(rpcOrd);
          const headers = {
            'Content-Type': 'application/json'
          };
          if (csrfToken) {
            headers['x-niagara-csrfToken'] = csrfToken;
          }
          
          const rpcRes = await fetch(rpcUrl, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify([normalizedPath, JSON.stringify(data, null, 2)])
          });
          
          if (rpcRes.ok) {
            const result = await rpcRes.json();
            return true;
          }
        } catch (e) {
          // RPC call failed, try next ORD
          continue;
        }
      }
      
      return false;
    } catch (err) {
      return false;
    }
  }

  async function saveConfigFile(filePath, data) {
    try {
      // PRIMARY METHOD: Use localStorage (works immediately, no setup needed)
      // This is actually ideal for user-specific dashboard configs
      try {
        const storageKey = 'dashboard_config_' + filePath.replace(/[^a-zA-Z0-9]/g, '_');
        localStorage.setItem(storageKey, JSON.stringify(data, null, 2));
        // Return true immediately - localStorage works reliably
        return true;
      } catch (storageErr) {
        // Continue to try other methods
      }
      
      // OPTIONAL: Try RPC-based file creation (if Java component exists)
      console.log('🔍 [DEBUG] Attempting RPC-based file creation (optional)...');
      const rpcResult = await saveConfigFileViaRpc(filePath, data);
      if (rpcResult) {
        console.log('✅ Also saved via RPC (file system)');
        return true;
      }
      
      // OPTIONAL: Try direct file write (may fail for new files)
      // If filePath doesn't start with "files/", assume it's relative to HTML file's directory
      console.log('🔍 [DEBUG] Attempting direct file write (optional)...');
      let normalizedPath = filePath;
      
      // If path doesn't start with "files/", it's relative to HTML file's directory
      // (e.g., "dashboard-config.json" will be in same directory as HTML file)
      if (!normalizedPath.startsWith('files/')) {
        // Keep as-is - will be relative to current directory (same as HTML file)
      } else {
        // Remove "files/" prefix for standard file system paths
        normalizedPath = normalizedPath.substring(6);
      }
      
      const fileOrd = 'file:^' + normalizedPath;
      // First ensure directory exists
      const dirPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
      if (dirPath) {
        await ensureDirectoryExists(dirPath);
      }
      
      // Try to get the file (it may not exist yet)
      let file;
      try {
        file = await baja.Ord.make(fileOrd).get();
      } catch (e) {
        // File doesn't exist yet, that's okay - we'll create it
        file = null;
      }
      
      // If file doesn't exist, we need to create it by writing to it
      // Get write URI - this should work even if file doesn't exist
      if (!file) {
        // Try to get file object anyway - sometimes getWriteUri works on non-existent files
        try {
          file = await baja.Ord.make(fileOrd).get();
        } catch (e) {
          // If we can't get the file object, try using the write URI directly
          // Construct write URI manually if needed
        }
      }
      
      // Get write URI
      let writeUri;
      if (file) {
        writeUri = file.getWriteUri();
      } else {
        // If we can't get file object, we need to construct the write URI properly
        // The write URI needs to be URL-encoded: /ord/file:^path becomes /ord/file:%5Epath
        // But actually, we should try to get the parent directory and use its write capability
        // Or use the ORD directly with proper encoding
        const encodedPath = encodeURIComponent(normalizedPath);
        // Try the standard format: /ord/file:^path (not URL-encoded in the path part)
        writeUri = '/ord/file:^' + normalizedPath;
        console.log('🔍 [DEBUG] Constructed write URI (file doesn\'t exist):', writeUri);
        // Alternative approach: Try to get parent directory and create file through it
        const dirPath2 = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
        const fileName = normalizedPath.substring(normalizedPath.lastIndexOf('/') + 1);
        
        if (dirPath2) {
          try {
            const dirOrd = 'file:^' + dirPath2;
            const parentDir = await baja.Ord.make(dirOrd).get();
            if (parentDir && parentDir.isDirectory()) {
              // Try to construct write URI using directory + filename
              // The write URI might be: /ord/file:^dirPath/filename
              writeUri = '/ord/file:^' + normalizedPath;
            }
          } catch (dirErr) {
          }
        }
      }
      
      if (!writeUri) {
        // localStorage already saved above, so return true
        return true;
      } else {
        const res = await fetch(writeUri, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data, null, 2)
        });
        if (res.ok) {
          return true;
        } else {
          console.log('💡 File system write failed (expected for new files), but localStorage saved successfully');
          // localStorage already saved above, so return true
          return true;
        }
      }
    } catch (err) {
      // Try localStorage as final fallback
      try {
        const storageKey = 'dashboard_config_' + filePath.replace(/[^a-zA-Z0-9]/g, '_');
        localStorage.setItem(storageKey, JSON.stringify(data, null, 2));
        console.log('✅ Config saved to localStorage (fallback):', storageKey);
        return true;
      } catch (storageErr) {
        return false;
      }
    }
  }

  async function ensureDirectoryExists(dirPath) {
    try {
      // Convert path like "files/dashboard" to "file:^dashboard"
      let normalizedPath = dirPath;
      if (normalizedPath.startsWith('files/')) {
        normalizedPath = normalizedPath.substring(6); // Remove "files/" prefix
      }
      const dirOrd = 'file:^' + normalizedPath;
      
      try {
        const dir = await baja.Ord.make(dirOrd).get();
        if (dir && dir.isDirectory()) {
          return true; // Directory exists
        }
      } catch (e) {
        // Directory doesn't exist, that's okay
      }
      
      // Try to create parent directory first
      const parentPath = normalizedPath.substring(0, normalizedPath.lastIndexOf('/'));
      if (parentPath) {
        await ensureDirectoryExists(parentPath);
      }
      
      // Note: BajaScript doesn't provide direct directory creation
      // The directory will be created when we write a file to it
      return true;
    } catch (err) {
      return false;
    }
  }

  // --- CONFIG STORAGE API (Uses localStorage as primary, file system as optional) ---
  // File locations (in order of preference):
  // 1. Same directory as HTML file: dashboard-config.json (easiest - just drop file next to HTML)
  // 2. files/dashboard/config.json (standard location)
  // 3. localStorage (always works, browser-specific)
  async function loadConfig() {
    console.log('🔍 [DEBUG] loadConfig() called');
    try {
      // PRIMARY: Try localStorage first (fast, reliable, no setup needed)
      try {
        const storageKey = 'dashboard_config_files_dashboard_config_json';
        const stored = localStorage.getItem(storageKey);
        if (stored) {
          const parsed = JSON.parse(stored);
          return parsed;
        }
      } catch (storageErr) {
      }
      
      // OPTIONAL: Try to load from file system (if files exist)
      // Try 1: Same directory as HTML file (easiest - just drop dashboard-config.json next to HTML)
      const sameDirConfig = await loadConfigFile('dashboard-config.json');
      if (sameDirConfig) {
        // Ensure dashboardAssignments exists
        if (!sameDirConfig.dashboardAssignments) {
          sameDirConfig.dashboardAssignments = {};
        }
        // Also save to localStorage for faster future loads
        try {
          const storageKey = 'dashboard_config_files_dashboard_config_json';
          localStorage.setItem(storageKey, JSON.stringify(sameDirConfig, null, 2));
        } catch (e) {}
        return sameDirConfig;
      }
      
      // Try 2: Standard location
      const globalConfig = await loadConfigFile('files/dashboard/config.json');
      if (globalConfig) {
        // Also save to localStorage for faster future loads
        try {
          const storageKey = 'dashboard_config_files_dashboard_config_json';
          localStorage.setItem(storageKey, JSON.stringify(globalConfig, null, 2));
        } catch (e) {}
        return globalConfig;
      }
      
      // No config found - create default
      const defaultConfig = getDefaultConfig();
      // Ensure dashboardAssignments exists
      if (!defaultConfig.dashboardAssignments) {
        defaultConfig.dashboardAssignments = {};
      }
      console.log('🔍 [DEBUG] Default config structure:', Object.keys(defaultConfig));
      
      // Save to localStorage (primary) and optionally to file system
      // Try saving to same directory as HTML first (easiest location)
      const saved = await saveConfigFile('dashboard-config.json', defaultConfig);
      if (saved) {
      }
      
      return defaultConfig;
    } catch (err) {
      return getDefaultConfig();
    }
  }

  async function saveConfig(obj) {
    try {
      const saved = await saveConfigFile('files/dashboard/config.json', obj);
      if (!saved) {
      }
    } catch (err) {
    }
  }

  function getDefaultConfig() {
    return {
      "global": {
        "rules": [
          // Smart defaults - work out of the box, case-insensitive, handle variations
          {"pattern": ".*hp.*|.*heat.?pump.*|.*heater.*|.*htr.*", "type": "heatpump", "icon": "heatpump.svg"},
          {"pattern": ".*exh.*fan.*|.*exfan.*|.*ef\\d.*", "type": "exhaustfan", "icon": "fan.svg"},
          {"pattern": ".*boiler.*|.*blr.*", "type": "boiler", "icon": "boiler.svg"},
          {"pattern": ".*genset.*|.*generator.*", "type": "generator", "icon": "generator.svg"},
          {"pattern": ".*charger.*|.*battery.*", "type": "charger", "icon": "battery.svg"},
          {"pattern": ".*cooling.*tower.*|.*tower.*plant.*", "type": "coolingtower", "icon": "tower.svg"},
          {"pattern": ".*pump.*|.*clp.*|.*ctp.*", "type": "pump", "icon": "pump.svg"},
          {"pattern": ".*freezer.*|.*frzr.*|.*fridge.*|.*walk.?in.*", "type": "freezer", "icon": "freezer.svg"},
          {"pattern": ".*boiler.*|.*blr.*", "type": "boiler", "icon": "boiler.svg"},
          {"pattern": ".*ahu.*|.*air.?handler.*|.*rtu.*", "type": "ahu", "icon": "ahu.svg"},
          {"pattern": ".*mau.*|.*make.?up.*", "type": "mau", "icon": "mau.svg"},
          {"pattern": ".*vav.*|.*zone.?box.*|.*terminal.*", "type": "vav", "icon": "vav.svg"},
          {"pattern": ".*kitchen.*|.*hood.*|.*cooking.*", "type": "kitchen", "icon": "kitchen.svg"}
        ],
        "zones": [],
        "groups": {},
        "snapshot": null,
        "lastSync": null,
        "syncMode": "manual"
      },
      "users": {},
      "presets": {},
      "dashboardAssignments": {} // NEW: Global dashboard assignments { dashboardId: { owner: username, assignedTo: [username1, username2], isPublic: false } }
    };
  }

  // Global dashboard config
  var dashboardConfig = null;
  var currentUserConfig = null;
  
  // --- USERSERVICE INTEGRATION ---
  var currentUser = {
    name: null,
    isSuperUser: false,
    permissions: null
  };
  
  // --- USER-SPECIFIC CONFIG MANAGEMENT ---
  async function loadUserConfig(username) {
    try {
      const userConfigPath = 'files/dashboard/users/' + username + '/config.json';
      
      // PRIMARY: Try localStorage first (fast, reliable, user-specific)
      try {
        const storageKey = 'dashboard_config_' + userConfigPath.replace(/[^a-zA-Z0-9]/g, '_');
        const stored = localStorage.getItem(storageKey);
        if (stored) {
          const parsed = JSON.parse(stored);
          return parsed;
        }
      } catch (storageErr) {
      }
      
      // OPTIONAL: Try to load from file system (if files exist)
      console.log('🔍 [DEBUG] Attempting to load from file system (optional)...');
      const userConfig = await loadConfigFile(userConfigPath);
      if (userConfig) {
        // Also save to localStorage for faster future loads
        try {
          const storageKey = 'dashboard_config_' + userConfigPath.replace(/[^a-zA-Z0-9]/g, '_');
          localStorage.setItem(storageKey, JSON.stringify(userConfig, null, 2));
        } catch (e) {}
        return userConfig;
      }
      
      // No config found - create default user config
      const defaultUserConfig = {
        dashboards: [],
        activeDashboard: null,
        restrictions: null,
        pxGraphics: []
      };
      
      // Save to localStorage (primary) and optionally to file system
      const saved = await saveConfigFile(userConfigPath, defaultUserConfig);
      if (saved) {
      }
      
      return defaultUserConfig;
    } catch (err) {
      // Return defaults even if save failed
      return {
        dashboards: [],
        activeDashboard: null,
        restrictions: null,
        pxGraphics: []
      };
    }
  }
  
  async function saveUserConfig(username, config) {
    try {
      const filePath = 'files/dashboard/users/' + username + '/config.json';
      const saved = await saveConfigFile(filePath, config);
      if (saved) {
        return true;
      }
      return false;
    } catch (err) {
      return false;
    }
  }
  
  // Get all dashboards across all users (for admins/maintenance)
  async function getAllDashboards() {
    const allDashboards = [];
    const allUsers = await getAllUsers();
    
    for (let user of allUsers) {
      const userDashboards = await getUserDashboards(user.name);
      userDashboards.forEach(function(dashboard) {
        // Add owner info
        dashboard.owner = user.name;
        allDashboards.push(dashboard);
      });
    }
    
    return allDashboards;
  }
  
  // Get dashboards visible to current user based on permissions
  async function getVisibleDashboards(username, userRole) {
    const isSuperUser = userRole === 'super' || (window.currentUser && window.currentUser.isSuperUser);
    const isMaintenance = userRole === 'maintenance';
    
    // Super users and maintenance see all dashboards
    if (isSuperUser || isMaintenance) {
      return await getAllDashboards();
    }
    
    // Regular users only see dashboards assigned to them
    const assignments = (dashboardConfig && dashboardConfig.dashboardAssignments) || {};
    const visibleDashboardIds = new Set();
    
    // Find dashboards assigned to this user
    Object.keys(assignments).forEach(function(dashboardId) {
      const assignment = assignments[dashboardId];
      if (assignment.assignedTo && assignment.assignedTo.includes(username)) {
        visibleDashboardIds.add(dashboardId);
      } else if (assignment.isPublic) {
        visibleDashboardIds.add(dashboardId);
      }
    });
    
    // Also include dashboards owned by this user
    const userConfig = await loadUserConfig(username);
    const userDashboards = userConfig.dashboards || [];
    userDashboards.forEach(function(dashboard) {
      visibleDashboardIds.add(dashboard.id);
    });
    
    // Load all visible dashboards
    const visibleDashboards = [];
    const allDashboards = await getAllDashboards();
    allDashboards.forEach(function(dashboard) {
      if (visibleDashboardIds.has(dashboard.id)) {
        visibleDashboards.push(dashboard);
      }
    });
    
    return visibleDashboards;
  }
  
  async function getUserDashboards(username) {
    // Try to get from in-memory config first
    if (dashboardConfig && dashboardConfig.users && dashboardConfig.users[username]) {
      return dashboardConfig.users[username].dashboards || [];
    }
    
    // Fallback: load from file
    try {
      const userConfig = await loadUserConfig(username);
      return userConfig.dashboards || [];
    } catch (err) {
      return [];
    }
  }
  
  async function saveDashboard(username, dashboardData) {
    try {
      // Load user config from file (source of truth)
      let userConfig = await loadUserConfig(username);
      
      // Ensure structure exists
      if (!userConfig.dashboards) {
        userConfig.dashboards = [];
      }
      if (userConfig.activeDashboard === undefined) {
        userConfig.activeDashboard = null;
      }
      if (userConfig.restrictions === undefined) {
        userConfig.restrictions = null;
      }
      
      // Add or update dashboard
      const dashboards = userConfig.dashboards;
      const existingIndex = dashboards.findIndex(d => d.id === dashboardData.id);
      const isNew = existingIndex < 0;
      
      if (existingIndex >= 0) {
        dashboards[existingIndex] = dashboardData;
      } else {
        if (!dashboardData.id) {
          dashboardData.id = 'dashboard_' + Date.now();
        }
        dashboards.push(dashboardData);
      }
      
      // Initialize dashboard assignments if new
      if (isNew) {
        if (!dashboardConfig.dashboardAssignments) {
          dashboardConfig.dashboardAssignments = {};
        }
        dashboardConfig.dashboardAssignments[dashboardData.id] = {
          owner: username,
          assignedTo: [username], // Owner can always see their own dashboards
          isPublic: false,
          createdAt: new Date().toISOString()
        };
        await saveConfig(dashboardConfig);
      }
      
      // Save to user-specific file (source of truth)
      await saveUserConfig(username, userConfig);
      
      // If using file persistence and dashboard includes customCards, save them separately
      if (window.USE_FILE_PERSISTENCE && dashboardData.customCards) {
        const jsonData = JSON.stringify(dashboardData.customCards);
        await window.saveDashboardDataToFile('customCards', jsonData);
      }
      
      // Update in-memory config for immediate access
      if (!dashboardConfig.users) {
        dashboardConfig.users = {};
      }
      dashboardConfig.users[username] = userConfig;
      return dashboardData.id;
    } catch (err) {
      return null;
    }
  }
  
  async function loadDashboard(username, dashboardId) {
    try {
      const dashboards = await getUserDashboards(username);
      const dashboard = dashboards.find(d => d.id === dashboardId);
      if (dashboard) {
        return dashboard;
      }
      return null;
    } catch (err) {
      return null;
    }
  }
  
  async function deleteDashboard(username, dashboardId) {
    try {
      // Load user config from file (source of truth)
      const userConfig = await loadUserConfig(username);
      
      if (!userConfig.dashboards) {
        return false;
      }
      
      const dashboards = userConfig.dashboards;
      const index = dashboards.findIndex(d => d.id === dashboardId);
      if (index >= 0) {
        dashboards.splice(index, 1);
        
        // If this was the active dashboard, clear it
        if (userConfig.activeDashboard === dashboardId) {
          userConfig.activeDashboard = null;
        }
        
        // Save to user-specific file (source of truth)
        await saveUserConfig(username, userConfig);
        
        // Update in-memory config for immediate access
        if (!dashboardConfig.users) {
          dashboardConfig.users = {};
        }
        dashboardConfig.users[username] = userConfig;
        return true;
      }
      return false;
    } catch (err) {
      return false;
    }
  }
  
  // --- SUPER USER FUNCTIONS ---
  async function getAllUsers() {
    try {
      const userService = await getUserService();
      if (!userService) {
        return [];
      }
      
      const users = [];
      const slots = userService.getSlots();
      if (slots) {
        slots.properties().each(function(slot) {
          try {
            const userName = slot.getName();
            users.push({ name: userName });
          } catch (e) {}
        });
      }
      return users;
    } catch (err) {
      return [];
    }
  }
  
  async function assignPresetToUser(username, presetId) {
    try {
      // Load global config to get presets
      const globalConfig = await loadConfig();
      if (!globalConfig.presets || !globalConfig.presets[presetId]) {
        return false;
      }
      
      const preset = globalConfig.presets[presetId];
      
      // Load user config from file (source of truth)
      let userConfig = await loadUserConfig(username);
      
      // Apply preset restrictions
      userConfig.restrictions = preset.restrictions || null;
      
      // Create a dashboard from preset if user doesn't have one
      if (!userConfig.dashboards || userConfig.dashboards.length === 0) {
        if (!userConfig.dashboards) {
          userConfig.dashboards = [];
        }
        const presetDashboard = {
          id: 'preset_' + presetId + '_' + Date.now(),
          name: preset.name,
          tabs: preset.tabs || [],
          pxGraphics: [],
          expandedSections: {},
          isPreset: true,
          presetId: presetId
        };
        userConfig.dashboards.push(presetDashboard);
        userConfig.activeDashboard = presetDashboard.id;
      }
      
      // Save to user-specific file (source of truth)
      await saveUserConfig(username, userConfig);
      
      // Update in-memory config for immediate access
      if (!dashboardConfig.users) {
        dashboardConfig.users = {};
      }
      dashboardConfig.users[username] = userConfig;
      return true;
    } catch (err) {
      return false;
    }
  }
  
  async function setUserRestrictions(username, allowedTabs) {
    // Load user config from file (source of truth)
    let userConfig = await loadUserConfig(username);
    userConfig.restrictions = allowedTabs;
    
    // Save to user-specific file (source of truth)
    await saveUserConfig(username, userConfig);
    
    // Update in-memory config for immediate access
    if (!dashboardConfig.users) {
      dashboardConfig.users = {};
    }
    dashboardConfig.users[username] = userConfig;
  }
  
  async function createPreset(presetData) {
    try {
      if (!dashboardConfig.presets) {
        dashboardConfig.presets = {};
      }
      
      const presetId = presetData.id || 'preset_' + Date.now();
      dashboardConfig.presets[presetId] = {
        id: presetId,
        name: presetData.name,
        tabs: presetData.tabs || [],
        restrictions: presetData.restrictions || null
      };
      
      await saveConfig(dashboardConfig);
      return presetId;
    } catch (err) {
      return null;
    }
  }
  
  function getUserPreset(username) {
    if (!dashboardConfig.users || !dashboardConfig.users[username]) {
      return null;
    }
    
    const userConfig = dashboardConfig.users[username];
    if (userConfig.dashboards && userConfig.dashboards.length > 0) {
      const presetDashboard = userConfig.dashboards.find(d => d.isPreset);
      if (presetDashboard) {
        return dashboardConfig.presets[presetDashboard.presetId] || null;
      }
    }
    return null;
  }
  
  async function getCurrentUser() {
    try {
      // Check if baja is available
      if (!baja || typeof baja.getUserName !== 'function') {
        return { name: 'anonymous', isSuperUser: false };
      }
      
      const userName = baja.getUserName();
      if (!userName) {
        return { name: 'anonymous', isSuperUser: false };
      }
      
      currentUser.name = userName;
      
      // Try to get UserService to check permissions
      try {
        const userService = await baja.Ord.make("service:baja:UserService").get();
        if (userService) {
          const escapedName = baja.SlotPath.escape(userName);
          const user = userService.get(escapedName);
          if (user) {
            // Check if user has super user permissions
            const permissions = user.get('permissions');
            if (permissions) {
              currentUser.permissions = permissions;
              // Check if permissions map is super user
              if (permissions.isSuperUser && permissions.isSuperUser()) {
                currentUser.isSuperUser = true;
              } else {
                // Check for super user permission in permissions map
                const permsMap = permissions;
                if (permsMap && permsMap.isSuperUser && permsMap.isSuperUser()) {
                  currentUser.isSuperUser = true;
                }
              }
            }
          }
        }
      } catch (e) {
      }
      window.currentUser = currentUser; // Expose globally
      return currentUser;
    } catch (err) {
      return { name: 'anonymous', isSuperUser: false };
    }
  }
  
  async function isSuperUser() {
    if (!currentUser.name) {
      await getCurrentUser();
    }
    return currentUser.isSuperUser;
  }
  
  async function getUserService() {
    try {
      return await baja.Ord.make("service:baja:UserService").get();
    } catch (err) {
      return null;
    }
  }

  // --- LOADING OVERLAY FUNCTIONS ---
  function showLoadingOverlay(message, subtext) {
    let overlay = document.getElementById('loadingOverlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'loadingOverlay';
      overlay.className = 'loading-overlay';
      overlay.innerHTML = `
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loadingText">${message || 'Loading...'}</div>
        <div class="loading-subtext" id="loadingSubtext">${subtext || ''}</div>
      `;
      document.body.appendChild(overlay);
    } else {
      overlay.style.display = 'flex';
      document.getElementById('loadingText').textContent = message || 'Loading...';
      document.getElementById('loadingSubtext').textContent = subtext || '';
    }
    // Update the refresh discovery button
    const btn = document.getElementById('refreshDiscoveryBtn');
    if (btn) {
      btn.classList.add('loading');
      btn.innerHTML = '⏳ Discovering...';
    }
  }
  
  function hideLoadingOverlay() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
      overlay.style.display = 'none';
    }
    // Restore the refresh discovery button
    const btn = document.getElementById('refreshDiscoveryBtn');
    if (btn) {
      btn.classList.remove('loading');
      btn.innerHTML = '🔄 Refresh Discovery';
    }
  }
  
  function updateLoadingText(message, subtext) {
    const loadingText = document.getElementById('loadingText');
    const loadingSubtext = document.getElementById('loadingSubtext');
    if (loadingText) loadingText.textContent = message || '';
    if (loadingSubtext) loadingSubtext.textContent = subtext || '';
  }
  
  // --- FULL STATION DISCOVERY ---
  async function runFullDiscovery() {
    showLoadingOverlay('🔍 Discovering Devices...', 'Scanning the station for equipment');
    const statusDiv = document.getElementById('discoveryStatus');
    if (statusDiv) statusDiv.textContent = 'Discovering all components...';

    try {
      // Load current config
      dashboardConfig = await loadConfig();

      // Discover equipment by scanning the Drivers folder for equipment containers
      // This finds actual devices (HP, MAU, AHU, etc.) not individual points
      const basePath = CONFIG?.basePath || 'Drivers/BacnetNetwork';
      return baja.Ord.make('station:|slot:/' + basePath).get().then(function(folder) {
        const equipment = [];
        const equipmentPromises = [];
        
        folder.getSlots().each(function(slot) {
          const name = slot.getName();
          // Find all equipment - skip system folders and internal components
          const systemFolders = ['points', 'Monitor', 'Alarms', 'status', 'enabled', 'faultCause', 
            'health', 'alarmSourceInfo', 'historyPolicies', 'worker', 'writeWorker', 'bacnetComm',
            'localDevice', 'tuningPolicies', 'covWorker', 'HonBacnetDeviceConfig',
            'honeywellBacnetDeviceManager_HonBacnetDeviceTypeHandler', 'HyperlinkList', 'BacnetLinkManagerUtil'];
          const isSystemFolder = systemFolders.some(sys => name.toLowerCase() === sys.toLowerCase());
          
          if (name && !name.startsWith('_') && !isSystemFolder) {
            const eqOrd = 'station:|slot:/' + basePath + '/' + name;
            const p = getEquipmentDisplayNameWithLocation(eqOrd, name).then(function(displayName) {
              equipment.push({
                name: displayName,
                originalName: name,
                ord: eqOrd,
                slotPath: '/' + basePath + '/' + name
              });
            }).catch(function() {
              // If display name fails, use original name
              equipment.push({
                name: name,
                originalName: name,
                ord: eqOrd,
                slotPath: '/' + basePath + '/' + name
              });
            });
            equipmentPromises.push(p);
          }
        });
        
        return Promise.all(equipmentPromises).then(async function() {
          updateLoadingText('📦 Found ' + equipment.length + ' Devices', 'Scanning for extractable sensors...');
          
          // Run a single BQL query to find all extractable points across all devices
          console.log('🔍 [DEBUG] Scanning for extractable points (ExFan, Water, H20, etc.)...');
          
          const extractedDevices = [];
          
          // Query for all control points with displayName, out, and status
          const extractBql = "station:|slot:/Drivers/BacnetNetwork|bql:select slotPath, displayName, name, out, status from control:ControlPoint";
          
          try {
            await new Promise(function(resolve) {
              // Set timeout to prevent endless waiting
              const timeout = setTimeout(function() {
                resolve();
              }, 60000); // 60 second timeout
              
              baja.Ord.make(extractBql).get().then(function(table) {
                clearTimeout(timeout);
                table.cursor({
                  limit: 5000,
                  each: function(record) {
                    try {
                      const slotPath = record.get('slotPath') ? record.get('slotPath').toString() : '';
                      const displayName = record.get('displayName') ? record.get('displayName').toString() : '';
                      const name = record.get('name') ? record.get('name').toString() : '';
                      
                      // Get out value and status
                      let outValue = '';
                      let outStatus = 'ok';
                      try {
                        const outVal = record.get('out');
                        if (outVal) {
                          const outStr = outVal.toString();
                          // Parse the value - format is typically "value {status}"
                          const match = outStr.match(/^(.+?)\s*\{([^}]+)\}/);
                          if (match) {
                            outValue = match[1].trim();
                            outStatus = match[2].trim();
                          } else {
                            outValue = outStr;
                          }
                          // Format numeric values to max 2 decimal places
                          const numVal = parseFloat(outValue);
                          if (!isNaN(numVal)) {
                            outValue = numVal % 1 === 0 ? numVal.toString() : numVal.toFixed(2);
                          }
                        }
                      } catch(e) {
                      }
                      
                      // Get status
                      try {
                        const statusVal = record.get('status');
                        if (statusVal) {
                          const statusStr = statusVal.toString().toLowerCase();
                          if (statusStr.includes('alarm')) outStatus = 'alarm';
                          else if (statusStr.includes('fault')) outStatus = 'fault';
                          else if (statusStr.includes('stale')) outStatus = 'stale';
                          else if (statusStr.includes('down')) outStatus = 'down';
                        }
                      } catch(e) {}
                      
                      // Skip if displayName equals name (not customized)
                      if (!displayName || displayName === name) return;
                      
                      // Check if it matches extraction patterns and determine device type
                      const displayNameLower = displayName.toLowerCase();
                      let inferredType = null;
                      
                      // Debug: Log all customized points to see what's available
                      console.log('🔍 [EXTRACT] Checking customized point:', displayName, '(slot:', name, ')');
                      
                      // ExFan patterns - including numbered variants like ExFan18, EF1, etc.
                      if (/ex\s*fan|exh\s*fan|exhaust\s*fan|^ef\d|^exf/i.test(displayName)) {
                        inferredType = 'exhaustfan';
                      }
                      // Water patterns - Hot Water, H20, H2O, Water Return/Supply/Temp, Dom Hot/Cold Water
                      else if (/water|h20|h2o|hhw|^dom\s*(hot|cold)/i.test(displayName)) {
                        inferredType = 'watersensor';
                      }
                      // Chilled water patterns
                      else if (/chw|chilled/i.test(displayName)) {
                        inferredType = 'chilledwater';
                      }
                      // Boiler patterns
                      else if (/boiler|outlet\s*temp|stack\s*temp|lead\s*lag/i.test(displayName)) {
                        inferredType = 'boiler';
                      }
                      // Generator patterns
                      else if (/genset|generator|gen\s*running|coolant|fuel\s*level|battery\s*voltage|oil\s*pressure|engine\s*temp/i.test(displayName)) {
                        inferredType = 'generator';
                      }
                      // Charger/Battery patterns
                      else if (/charger|batt|ac_on|ac_fail/i.test(displayName)) {
                        inferredType = 'charger';
                      }
                      // Cooling Tower patterns
                      else if (/tower|cooling\s*tower|ctp\d*\s*psi/i.test(displayName)) {
                        inferredType = 'coolingtower';
                      }
                      // Pump patterns
                      else if (/pump|clp\d*\s*psi/i.test(displayName)) {
                        inferredType = 'pump';
                      }
                      
                      if (inferredType) {
                      }
                      
                      if (inferredType && displayName.length > 2) {
                        // Extract parent equipment name from slotPath
                        const pathParts = slotPath.split('/');
                        let parentName = 'Unknown';
                        const pointsIdx = pathParts.indexOf('points');
                        if (pointsIdx > 0) {
                          parentName = pathParts[pointsIdx - 1];
                        }
                        
                        // Check if already exists
                        const exists = extractedDevices.some(function(d) {
                          return d.slotPath === slotPath;
                        });
                        
                        if (!exists) {
                          // Store parent path for location lookup later
                          const parentPath = pathParts.slice(0, pointsIdx).join('/');
                          
                          extractedDevices.push({
                            name: displayName + ' (' + parentName + ')',
                            originalName: name,
                            ord: 'station:|slot:' + slotPath,
                            slotPath: slotPath,
                            parentDevice: 'station:|slot:/' + parentPath,
                            parentName: parentName,
                            parentPath: parentPath,
                            inferredType: inferredType,
                            isExtractedPoint: true,
                            outValue: outValue,
                            outStatus: outStatus
                          });
                        }
                      }
                    } catch(e) {
                      // Skip this record
                    }
                  },
                  after: function() {
                    updateLoadingText('🔌 Found ' + extractedDevices.length + ' Sensors', 'Getting locations for extracted devices...');
                    resolve();
                  }
                });
              }).catch(function(e) {
                clearTimeout(timeout);
                resolve();
              });
            });
          } catch(e) {
          }
          
          // Get location for each extracted device from parent device's Location point
          for (let i = 0; i < extractedDevices.length; i++) {
            const extracted = extractedDevices[i];
            if (extracted.parentPath) {
              try {
                // First try to find the parent device in our equipment list
                const parentDevice = equipment.find(function(eq) {
                  return eq.slotPath === '/' + extracted.parentPath || eq.originalName === extracted.parentName;
                });
                if (parentDevice && parentDevice.zone) {
                  extracted.zone = parentDevice.zone;
                } else {
                  // Try to fetch Location point from parent device directly
                  try {
                    const locationOrd = 'station:|slot:/' + extracted.parentPath + '/points/Location';
                    const locationPoint = await baja.Ord.make(locationOrd).get();
                    if (locationPoint) {
                      const outVal = locationPoint.get('out');
                      if (outVal) {
                        let zone = outVal.toString();
                        // Clean up the zone string
                        zone = zone.replace(/\{[^}]*\}/g, '').replace(/@[^@]*$/, '').trim();
                        extracted.zone = zone;
                      }
                    }
                  } catch(locErr) {
                    // Try Monitor/Location path
                    try {
                      const monitorLocationOrd = 'station:|slot:/' + extracted.parentPath + '/Monitor/Location';
                      const monitorLocationPoint = await baja.Ord.make(monitorLocationOrd).get();
                      if (monitorLocationPoint) {
                        const outVal = monitorLocationPoint.get('out');
                        if (outVal) {
                          let zone = outVal.toString();
                          zone = zone.replace(/\{[^}]*\}/g, '').replace(/@[^@]*$/, '').trim();
                          extracted.zone = zone;
                        }
                      }
                    } catch(e) {}
                  }
                }
              } catch(e) {
              }
            }
          }
          
          // Add extracted devices to equipment list
          if (extractedDevices.length > 0) {
            equipment.push.apply(equipment, extractedDevices);
          }
          
          // Store equipment and run inference
          if (!dashboardConfig.global) dashboardConfig.global = {};
          dashboardConfig.global.snapshot = equipment;
          dashboardConfig.global.lastSync = new Date().toISOString();
          
          updateLoadingText('🔧 Running Smart Inference...', 'Categorizing devices by type');
          return runSmartInference(equipment).then(function() {
            updateLoadingText('💚 Calculating Health...', 'Checking device status');
            return calculateHealth(equipment).then(function() {
              updateLoadingText('💾 Saving Configuration...', 'Almost done!');
              return saveConfig(dashboardConfig).then(function() {
                hideLoadingOverlay();
                updateDashboard();
                const extractedCount = extractedDevices.length;
                if (statusDiv) {
                  statusDiv.textContent = `✅ Discovery complete: ${equipment.length - extractedCount} devices + ${extractedCount} extracted sensors, ${Object.keys(dashboardConfig.global.groups || {}).length} groups`;
                  statusDiv.style.color = '#4CAF50';
                }
              });
            });
          });
        });
      }).catch(function(err) {
        hideLoadingOverlay();
        if (statusDiv) {
          statusDiv.textContent = '❌ Discovery failed: ' + err.message;
          statusDiv.style.color = '#f44336';
        }
      });
    } catch (err) {
      hideLoadingOverlay();
      if (statusDiv) {
        statusDiv.textContent = '❌ Discovery setup error: ' + err.message;
        statusDiv.style.color = '#f44336';
      }
    }
  }

  // --- ZONE DETECTION HELPER ---
  async function getZoneForEquipment(equipmentOrd, equipmentName) {
    try {
      const equipment = await baja.Ord.make(equipmentOrd).get();
      let zone = null;
      let zoneSource = null;
      
      // Priority 1: Check Location folder under device
      try {
        const locationSlot = equipment.getSlots().slotName(/^Location$/i).first();
        if (locationSlot) {
          const locationValue = equipment.get(locationSlot);
          if (locationValue) {
            // Handle both Enum and String
            if (locationValue.getEnum) {
              zone = locationValue.getEnum().getName();
            } else if (locationValue.toString) {
              zone = locationValue.toString();
            }
            if (zone) {
              zoneSource = 'Location folder';
              return {zone: zone, source: zoneSource};
            }
          }
        }
      } catch(e) {
        // Location folder not found, continue
      }
      
      // Priority 2: Check points with alarm extensions
      try {
        const pointsFolder = equipment.getSlots().slotName(/^points$/i).first();
        if (pointsFolder) {
          const points = equipment.get(pointsFolder);
          if (points && points.getSlots) {
            let foundZone = null;
            points.getSlots().properties().each(function(slot) {
              if (foundZone) return; // Already found
              try {
                const point = points.get(slot);
                // Check if point has alarm extension
                if (point && point.getSlots) {
                  const alarmExt = point.getSlots().slotName(/alarm|Alarm/i).first();
                  if (alarmExt) {
                    // Try to get zone from alarm extension metadata or point name
                    const pointName = slot.getName().toLowerCase();
                    if (pointName.includes('zone') || pointName.includes('location') || pointName.includes('floor')) {
                      const pointValue = point.get('out');
                      if (pointValue) {
                        foundZone = pointValue.toString();
                        zoneSource = 'Alarm extension point';
                      }
                    }
                  }
                }
              } catch(e) {}
            });
            if (foundZone) {
              return {zone: foundZone, source: zoneSource};
            }
          }
        }
      } catch(e) {
        // Points folder check failed
      }
      
      // Priority 3: Check points/Monitor/Location (most common pattern)
      try {
        const pointsFolder = equipment.getSlots().slotName(/^points$/i).first();
        if (pointsFolder) {
          const points = equipment.get(pointsFolder);
          if (points && points.getSlots) {
            // Check for Monitor folder first - handle case where it doesn't exist
            let monitorSlot = null;
            try {
              monitorSlot = points.getSlots().slotName(/^Monitor$/i).first();
            } catch(e) {
              // Monitor folder doesn't exist - this is expected for many equipment types
            }
            if (monitorSlot) {
              try {
                const monitorFolder = points.get(monitorSlot);
                if (monitorFolder && monitorFolder.getSlots) {
                  // Check for Location point in Monitor folder
                  const locationSlot = monitorFolder.getSlots().slotName(/^Location$/i).first();
                  if (locationSlot) {
                    const locationPoint = monitorFolder.get(locationSlot);
                    if (locationPoint) {
                      try {
                        // Subscribe temporarily to get the actual value (not just 0)
                        let outValue = null;
                        try {
                          // Try to get value directly first
                          outValue = locationPoint.get('out');
                          console.log('🔍 [DEBUG] Location out value (direct):', outValue ? 'exists' : 'null', outValue ? outValue.toString() : '');
                          
                          // If value is 0 or empty, subscribe to get live value
                          const outValueStr = outValue ? outValue.toString() : '';
                          if (!outValue || outValueStr === '0' || outValueStr.match(/^0\s*\{/)) {
                            const subscriber = new baja.Subscriber();
                            subscriber.subscribe([locationPoint]);
                            subscriber.attach('changed', function(change) {
                              try {
                                const liveOut = locationPoint.get('out');
                                if (liveOut) {
                                  outValue = liveOut;
                                  console.log('✅ [DEBUG] Got live Location value:', outValue.toString());
                                  // Detach after getting value
                                  subscriber.detach('changed');
                                  subscriber.unsubscribe();
                                }
                              } catch(e) {
                              }
                            });
                            // Wait a bit for subscription to get value
                            await new Promise(function(resolve) { setTimeout(resolve, 500); });
                            // Try again after subscription
                            outValue = locationPoint.get('out');
                            console.log('🔍 [DEBUG] Location out value (after subscription):', outValue ? 'exists' : 'null', outValue ? outValue.toString() : '');
                          }
                        } catch(e) {
                        }
                        
                        if (outValue) {
                          // Try to get enum name if it's an enum
                          if (outValue.getEnum) {
                            try {
                              const enumVal = outValue.getEnum();
                              if (enumVal) {
                                // Try getName() first
                                if (enumVal.getName && typeof enumVal.getName === 'function') {
                                  zone = enumVal.getName();
                                  console.log('✅ [DEBUG] Got zone from enumVal.getName():', zone);
                                } else if (enumVal.name) {
                                  zone = enumVal.name;
                                } else {
                                  // Try to get the value property
                                  const enumValue = outValue.get('value');
                                  console.log('🔍 [DEBUG] enumValue from outValue.get("value"):', enumValue ? 'exists' : 'null', enumValue ? enumValue.toString() : '');
                                  
                                  if (enumValue) {
                                    // If it's an Enum, get its name
                                    if (enumValue.getEnum) {
                                      const valEnum = enumValue.getEnum();
                                      if (valEnum && valEnum.getName) {
                                        zone = valEnum.getName();
                                        console.log('✅ [DEBUG] Got zone from valEnum.getName():', zone);
                                      } else if (valEnum && valEnum.name) {
                                        zone = valEnum.name;
                                      } else {
                                        const enumStr = enumValue.toString();
                                        zone = enumStr.replace(/\{[^}]*\}/g, '').trim();
                                        console.log('✅ [DEBUG] Got zone from toString (cleaned):', zone);
                                      }
                                    } else {
                                      zone = enumValue.toString().replace(/\{[^}]*\}/g, '').trim();
                                      console.log('✅ [DEBUG] Got zone from enumValue.toString():', zone);
                                    }
                                  } else {
                                    // Try toString and extract name
                                    const enumStr = outValue.toString();
                                    console.log('🔍 [DEBUG] outValue.toString():', enumStr);
                                    // Look for enum name pattern (e.g., "Level1_ZoneCS {ok}")
                                    const nameMatch = enumStr.match(/^([A-Za-z0-9_]+)/);
                                    if (nameMatch) {
                                      zone = nameMatch[1];
                                    } else {
                                      zone = enumStr.replace(/\{[^}]*\}/g, '').trim();
                                      console.log('✅ [DEBUG] Got zone from toString (cleaned, no match):', zone);
                                    }
                                  }
                                }
                                if (zone) {
                                  zoneSource = 'Location enum point (Monitor/Location)';
                                  return {zone: zone, source: zoneSource};
                                }
                              }
                            } catch(enumErr) {
                              // Fall through to string extraction
                            }
                          } else {
                          }
                          
                          // Fallback: get string representation
                          const zoneStr = outValue.toString();
                          console.log('🔍 [DEBUG] outValue.toString():', zoneStr);
                          // Remove status markers like {ok} and try to extract enum name
                          const cleanStr = zoneStr.replace(/\{[^}]*\}/g, '').trim();
                          // If it looks like just a number, try to get the actual enum name
                          if (/^\d+$/.test(cleanStr)) {
                            // It's just a number - try to get enum from the point itself
                            try {
                              const enumType = locationPoint.get('enum');
                              if (enumType) {
                                let enumNames = null;
                                if (enumType.getNames && typeof enumType.getNames === 'function') {
                                  enumNames = enumType.getNames();
                                  console.log('🔍 [DEBUG] Enum names from getNames():', enumNames);
                                } else if (enumType.getItems && typeof enumType.getItems === 'function') {
                                  const items = enumType.getItems();
                                  enumNames = items ? items.map(function(item) { return item.getName ? item.getName() : item.toString(); }) : null;
                                  console.log('🔍 [DEBUG] Enum names from getItems():', enumNames);
                                }
                                
                                if (enumNames && enumNames.length > parseInt(cleanStr)) {
                                  zone = enumNames[parseInt(cleanStr)];
                                } else {
                                }
                              }
                            } catch(e) {
                            }
                          }
                          if (!zone) {
                            zone = cleanStr;
                          }
                          if (zone) {
                            zoneSource = 'Location point (Monitor/Location)';
                            return {zone: zone, source: zoneSource};
                          }
                        } else {
                        }
                      } catch(e) {
                      }
                    } else {
                    }
                  } else {
                  }
                } else {
                }
              } catch(e) {
              }
            } else {
            }
            
            // Also check directly under points for zone/floor/location properties
            const zoneProps = ['zone', 'floor', 'flr', 'location', 'Location'];
            for (let i = 0; i < zoneProps.length; i++) {
              const propSlot = points.getSlots().slotName(new RegExp('^' + zoneProps[i] + '$', 'i')).first();
              if (propSlot) {
                try {
                  const propValue = points.get(propSlot);
                  if (propValue && propValue.get) {
                    const outValue = propValue.get('out');
                    if (outValue) {
                      // Try to get enum name if it's an enum
                      if (outValue.getEnum) {
                        try {
                          const enumVal = outValue.getEnum();
                          if (enumVal) {
                            if (enumVal.getName && typeof enumVal.getName === 'function') {
                              zone = enumVal.getName();
                            } else if (enumVal.name) {
                              zone = enumVal.name;
                            } else {
                              // Try to get the value property
                              const enumValue = outValue.get('value');
                              if (enumValue && enumValue.getEnum) {
                                const valEnum = enumValue.getEnum();
                                if (valEnum && valEnum.getName) {
                                  zone = valEnum.getName();
                                } else if (valEnum && valEnum.name) {
                                  zone = valEnum.name;
                                } else {
                                  const enumStr = enumValue.toString();
                                  const nameMatch = enumStr.match(/^([A-Za-z0-9_]+)/);
                                  zone = nameMatch ? nameMatch[1] : enumStr.replace(/\{[^}]*\}/g, '').trim();
                                }
                              } else {
                                const enumStr = outValue.toString();
                                const nameMatch = enumStr.match(/^([A-Za-z0-9_]+)/);
                                zone = nameMatch ? nameMatch[1] : enumStr.replace(/\{[^}]*\}/g, '').trim();
                              }
                            }
                          }
                        } catch(enumErr) {
                          // Fall through to string extraction
                        }
                      }
                      if (!zone) {
                        const zoneStr = outValue.toString();
                        const cleanStr = zoneStr.replace(/\{[^}]*\}/g, '').trim();
                        // If it's just a number, try to get enum names from the point
                        if (/^\d+$/.test(cleanStr)) {
                          try {
                            const propPoint = propValue;
                            const enumType = propPoint.get('enum');
                            if (enumType && enumType.getNames) {
                              const enumNames = enumType.getNames();
                              if (enumNames && enumNames.length > parseInt(cleanStr)) {
                                zone = enumNames[parseInt(cleanStr)];
                              }
                            }
                          } catch(e) {}
                        }
                        if (!zone) {
                          zone = cleanStr;
                        }
                      }
                      if (zone) {
                        zoneSource = 'Points property: ' + zoneProps[i];
                        return {zone: zone, source: zoneSource};
                      }
                    }
                  }
                } catch(e) {}
              }
            }
          }
        }
      } catch(e) {
        // Points property check failed
      }
      
      // Priority 4: Check parent folder name (existing logic)
      const slotPath = equipmentOrd.replace('station:|slot:', '');
      if (slotPath) {
        const parts = slotPath.split('/');
        if (parts.length > 1) {
          const parentName = parts[parts.length - 2].toLowerCase();
          const zonePattern = /(?:zone|floor|room|kitchen|office|warehouse|lab)\s*(\d+|[a-z]+)/i;
          const match = parentName.match(zonePattern);
          if (match) {
            zone = match[0];
            zoneSource = 'Parent folder';
            return {zone: zone, source: zoneSource};
          }
        }
      }
      return {zone: null, source: null};
    } catch(e) {
      return {zone: null, source: null};
    }
  }
  
  // --- ALARM CLASS DETECTION HELPER ---
  async function getAlarmClassForEquipment(equipmentOrd, equipmentName) {
    try {
      // Method 1: Check points with alarm extensions (fastest)
      const equipment = await baja.Ord.make(equipmentOrd).get();
      const alarmClasses = new Set();
      
      try {
        const pointsFolder = equipment.getSlots().slotName(/^points$/i).first();
        if (pointsFolder) {
          const points = equipment.get(pointsFolder);
          if (points && points.getSlots) {
            points.getSlots().properties().each(function(slot) {
              try {
                const point = points.get(slot);
                if (point && point.getSlots) {
                  // Check for alarm extension
                  const alarmExt = point.getSlots().slotName(/alarm|Alarm/i).first();
                  if (alarmExt) {
                    try {
                      const ext = point.get(alarmExt);
                      if (ext && ext.get) {
                        const alarmClass = ext.get('alarmClass');
                        if (alarmClass) {
                          const className = alarmClass.toString().toLowerCase();
                          if (className && className !== 'null' && className !== 'alarm') {
                            alarmClasses.add(className);
                          }
                        }
                      }
                    } catch(e) {}
                  }
                }
              } catch(e) {}
            });
          }
        }
      } catch(e) {
        // Points scan failed
      }
      
      // If we found alarm classes, return the most common one
      if (alarmClasses.size > 0) {
        const classesArray = Array.from(alarmClasses);
        // Return first one (most common pattern)
        return {alarmClass: classesArray[0], source: 'alarm extension'};
      }
      
      // Method 2: Query alarm service (skip for system components to avoid errors)
      const systemNames = ['ping', 'ackAlarm', 'upload', 'download', 'asyncPing', 'submitDeviceManagerJob', 
        'lookupDeviceById', 'lookupDeviceByAddress', 'lookupDeviceOrdById', 'lookupDeviceOrdByAddress',
        'displayNames', 'privateTransferResultBlockFlag', 'shouldSupportFaultForMultiState', 
        'uploadOnStart', 'writeOnFacetChange'];
      const isSystemComponent = systemNames.some(sys => equipmentName.toLowerCase().includes(sys.toLowerCase()));
      
      // Method 2: Query alarm service - DISABLED due to BQL syntax issues
      // The alarm service BQL queries are failing, so we skip this method
      // and rely on alarm extensions and displayName patterns instead
      
      // Method 3: Check for extra points with modified displayNames (like "customized" -> "ExhFan4")
      try {
        const pointsFolder = equipment.getSlots().slotName(/^points$/i).first();
        if (pointsFolder) {
          const points = equipment.get(pointsFolder);
          if (points && points.getSlots) {
            points.getSlots().properties().each(function(slot) {
              try {
                const point = points.get(slot);
                const slotName = slot.getName().toLowerCase();
                // Check for points like "customized", "oa" with modified displayNames
                if (slotName === 'customized' || slotName === 'oa' || slotName.startsWith('customized') || slotName.startsWith('oa')) {
                  if (point && point.getDisplayName) {
                    const displayName = point.getDisplayName();
                    if (displayName && typeof displayName.then === 'function') {
                      displayName.then(function(dn) {
                        if (dn) {
                          const dnLower = dn.toLowerCase();
                          // Extract device type from displayName (ExhFan4 -> exhfan, Freezer -> freezer)
                          const rules = dashboardConfig.global?.rules || dashboardConfig.rules || [];
                          rules.forEach(function(rule) {
                            const regex = new RegExp(rule.pattern, 'i');
                            if (regex.test(dnLower)) {
                              alarmClasses.add(rule.type);
                            }
                          });
                        }
                      });
                    } else if (displayName) {
                      const dnLower = displayName.toString().toLowerCase();
                      const rules = dashboardConfig.global?.rules || dashboardConfig.rules || [];
                      rules.forEach(function(rule) {
                        const regex = new RegExp(rule.pattern, 'i');
                        if (regex.test(dnLower)) {
                          alarmClasses.add(rule.type);
                        }
                      });
                    }
                  }
                }
              } catch(e) {}
            });
          }
        }
        if (alarmClasses.size > 0) {
          const classesArray = Array.from(alarmClasses);
          return {alarmClass: classesArray[0], source: 'displayName pattern'};
        }
      } catch(e) {
        // Extra points check failed
      }
      
      return {alarmClass: null, source: null};
    } catch(e) {
      return {alarmClass: null, source: null};
    }
  }

  // --- SMART DEVICE & TYPE INFERENCE ---
  async function runSmartInference(components) {
    const byType = {};
    const byZone = {};
    const zonePattern = /(?:zone|floor|room|kitchen|office|warehouse|lab)\s*(\d+|[a-z]+)/i;

    // Filter out system components before processing
    const systemNames = ['status', 'enabled', 'faultCause', 'ping', 'ackAlarm', 'upload', 'download', 
      'asyncPing', 'submitDeviceManagerJob', 'lookupDeviceById', 'lookupDeviceByAddress', 
      'lookupDeviceOrdById', 'lookupDeviceOrdByAddress', 'displayNames', 'privateTransferResultBlockFlag',
      'shouldSupportFaultForMultiState', 'uploadOnStart', 'writeOnFacetChange', 'health', 
      'alarmSourceInfo', 'monitor', 'historyPolicies', 'worker', 'writeWorker', 'bacnetComm',
      'localDevice', 'tuningPolicies', 'covWorker', 'HonBacnetDeviceConfig', 
      'honeywellBacnetDeviceManager_HonBacnetDeviceTypeHandler', 'HyperlinkList', 'BacnetLinkManagerUtil'];
    
    const filteredComponents = components.filter(function(comp) {
      const name = (comp.name || comp.originalName || '').toLowerCase();
      const slotPath = (comp.slotPath || '').toLowerCase();
      
      // Check if it's a system component
      const isSystem = systemNames.some(function(sysName) {
        return name === sysName.toLowerCase() || 
               slotPath.includes('/' + sysName.toLowerCase() + '/') ||
               slotPath.endsWith('/' + sysName.toLowerCase());
      });
      
      // Also filter out if it's a point under a system folder
      if (slotPath) {
        const pathParts = slotPath.split('/');
        if (pathParts.includes('monitor') && pathParts.length > 3) {
          return false; // Skip points under Monitor folder
        }
        // Skip if it's a direct child of BacnetNetwork (network-level properties)
        if (pathParts.length === 3 && pathParts[0] === 'drivers' && pathParts[1] === 'bacnetnetwork') {
          return false;
        }
      }
      
      return !isSystem;
    });
    
    console.log(`Filtered ${components.length} components down to ${filteredComponents.length} (removed ${components.length - filteredComponents.length} system components)`);

    // Process components with zone and alarm class detection
    const inferencePromises = filteredComponents.map(async function(comp) {
      // Get display name or name for matching
      const matchText = (comp.displayName || comp.name || comp.originalName || '').toLowerCase();
      const folderText = (comp.folder || '').toLowerCase();
      const tagsText = (comp.tags || '').toLowerCase();
      const fullText = matchText + ' ' + folderText + (tagsText ? ' ' + tagsText : '');

      // Get zone for this equipment (with error handling)
      try {
        const zoneResult = await getZoneForEquipment(comp.ord, comp.originalName || comp.name);
        comp.zone = zoneResult.zone;
        comp.zoneSource = zoneResult.source;
      } catch(e) {
        // Zone detection failed - set to null
        comp.zone = null;
        comp.zoneSource = null;
      }
      
      // If no zone found, try regex pattern fallback
      if (!comp.zone) {
        const zoneMatch = fullText.match(zonePattern);
        if (zoneMatch) {
          comp.zone = zoneMatch[0];
          comp.zoneSource = 'regex pattern';
        } else if (fullText.includes('kitchen')) {
          comp.zone = 'Kitchen';
          comp.zoneSource = 'keyword match';
        } else if (fullText.includes('office')) {
          comp.zone = 'Office';
          comp.zoneSource = 'keyword match';
        }
      }

      // Get alarm class for device type (strongest indicator) - with error handling
      try {
        const alarmResult = await getAlarmClassForEquipment(comp.ord, comp.originalName || comp.name);
        comp.alarmClass = alarmResult.alarmClass;
        comp.typeSource = alarmResult.source;
      } catch(e) {
        // Alarm class detection failed - set to null
        comp.alarmClass = null;
        comp.typeSource = null;
      }

      // Try to match against rules - check alarm class first, then patterns
      let matchedType = 'generic';
      let matchedIcon = 'sensor.svg';
      let matchedRule = null;

      // Priority 0: Preserve inferredType for extracted points
      if (comp.isExtractedPoint && comp.inferredType && comp.inferredType !== 'sensor') {
        matchedType = comp.inferredType;
        console.log('🔍 [DEBUG] Preserving extracted point type:', matchedType, 'for', comp.name, '(isExtractedPoint:', comp.isExtractedPoint, ')');
      } else if (comp.isExtractedPoint) {
      }
      // Priority 1: Use alarm class if found
      else if (comp.alarmClass) {
        matchedType = comp.alarmClass;
        // Find matching rule for icon
        const rules = dashboardConfig.global?.rules || dashboardConfig.rules || [];
        rules.forEach(function(rule) {
          if (rule.type === comp.alarmClass) {
            matchedIcon = rule.icon;
            matchedRule = rule;
          }
        });
      } else {
        // Priority 2: Pattern matching
        const rules = dashboardConfig.global?.rules || dashboardConfig.rules || [];
        rules.forEach(function(rule) {
          try {
            const regex = new RegExp(rule.pattern, 'i');
            if (regex.test(matchText) || regex.test(folderText) || regex.test(tagsText)) {
              matchedType = rule.type;
              matchedIcon = rule.icon;
              matchedRule = rule;
            }
          } catch (e) {
          }
        });
      }

      // Store inferred data
      comp.inferredType = matchedType;
      comp.inferredIcon = matchedIcon;

      // Build maps
      if (!byType[matchedType]) {
        byType[matchedType] = [];
      }
      byType[matchedType].push(comp);
      if (comp.isExtractedPoint) {
      }

      const zoneKey = comp.zone || 'Unassigned';
      if (!byZone[zoneKey]) byZone[zoneKey] = [];
      byZone[zoneKey].push(comp);
      
      return comp;
    });

    await Promise.all(inferencePromises);

    if (!dashboardConfig.global) dashboardConfig.global = {};
    dashboardConfig.global.byType = byType;
    dashboardConfig.global.byZone = byZone;

    console.log(`✅ Inference complete: ${Object.keys(byType).length} types, ${Object.keys(byZone).length} zones`);
    return Promise.resolve();
  }

  // --- HEALTH CALCULATION ---
  async function calculateHealth(equipment) {
    const groups = {};
    const healthPromises = [];

    // Check health for each equipment unit
    const global = dashboardConfig?.global || dashboardConfig || {};
    (equipment || global.snapshot || []).forEach(function(eq) {
      // For extracted points, use their stored status directly - no need for ORD call
      if (eq.isExtractedPoint) {
        const status = (eq.outStatus || 'ok').toLowerCase();
        const hasAlarm = status.includes('alarm');
        const isDown = status.includes('down');
        const isFault = status.includes('fault');
        const isStale = status.includes('stale');
        
        eq.isHealthy = !hasAlarm && !isDown && !isFault && !isStale;
        eq.hasAlarm = hasAlarm;
        eq.status = hasAlarm ? 'alarm' : isDown ? 'down' : isFault ? 'fault' : isStale ? 'stale' : 'ok';
        healthPromises.push(Promise.resolve());
        return; // Skip the normal ORD-based health check
      }
      
      // Skip if ord is invalid (contains special chars that will fail)
      if (!eq.ord || eq.ord.includes("'") || eq.ord.includes('"')) {
        eq.isHealthy = true;
        eq.status = 'ok';
        healthPromises.push(Promise.resolve());
        return;
      }
      
      const p = baja.Ord.make(eq.ord).get().then(async function(comp) {
        try {
          const status = comp.getStatus();
          let isHealthy = !status.isDown() && !status.isFault() && !status.isStale();
          let hasAlarm = false;
          
          // Check for alarms in children points
          try {
            // Escape equipment name for BQL
            const eqName = (eq.originalName || eq.name || '').replace(/'/g, "''");
            if (!eqName) {
              throw new Error('No equipment name');
            }
            const alarmBql = "station:|slot:/Drivers|bql:select slotPath, normalTime from alarm:AlarmExt where slotPath like '%/" + eqName + "/%'";
            
            try {
              const alarmTable = await baja.Ord.make(alarmBql).get();
              let alarmCount = 0;
              await alarmTable.cursor({
                each: function(record) {
                  try {
                    const normalTime = record.get('normalTime');
                    // If normalTime is null or empty, alarm is active
                    if (!normalTime || normalTime.toString() === 'null' || normalTime.toString() === '') {
                      alarmCount++;
                      hasAlarm = true;
                    }
                  } catch(e) {}
                },
                limit: 100
              });
              
              // Also check the component's own status for alarms
              if (!hasAlarm && comp.getStatus) {
                const compStatus = comp.getStatus();
                if (compStatus && compStatus.isAlarm && compStatus.isAlarm()) {
                  hasAlarm = true;
                  alarmCount = 1;
                }
              }
              
              if (hasAlarm) {
                isHealthy = false;
                eq.alarmCount = alarmCount;
              }
            } catch(alarmErr) {
              // Alarm query failed, check component status directly
              try {
                if (comp.getStatus) {
                  const compStatus = comp.getStatus();
                  if (compStatus && compStatus.isAlarm && compStatus.isAlarm()) {
                    hasAlarm = true;
                    isHealthy = false;
                    eq.alarmCount = 1;
                  }
                }
              } catch(statusErr) {}
            }
          } catch(e) {
            // Alarm check failed, continue
          }
          
          eq.isHealthy = isHealthy;
          eq.hasAlarm = hasAlarm;
          eq.status = status.isDown() ? 'down' : status.isFault() ? 'fault' : status.isStale() ? 'stale' : hasAlarm ? 'alarm' : 'ok';
        } catch(e) {
          eq.isHealthy = false;
          eq.status = 'error';
        }
      }).catch(function() {
        eq.isHealthy = false;
        eq.status = 'offline';
      });
      healthPromises.push(p);
    });

    return Promise.all(healthPromises).then(function() {
      if (!dashboardConfig.global) dashboardConfig.global = {};
      const byType = dashboardConfig.global.byType || {};
      const byZone = dashboardConfig.global.byZone || {};
      
      // Calculate health per type
      Object.keys(byType).forEach(function(type) {
        const components = byType[type];
        let healthyCount = 0;
        let totalCount = components.length;

        components.forEach(function(comp) {
          if (comp.isHealthy) healthyCount++;
        });

        const health = totalCount > 0 ? Math.round((healthyCount / totalCount) * 100) : 100;
        
        groups[type] = {
          count: totalCount,
          healthy: healthyCount,
          health: health
        };
      });

      // Calculate health per zone
      Object.keys(byZone).forEach(function(zone) {
        const components = byZone[zone];
        let healthyCount = 0;
        let totalCount = components.length;

        components.forEach(function(comp) {
          if (comp.isHealthy) healthyCount++;
        });

        const health = totalCount > 0 ? Math.round((healthyCount / totalCount) * 100) : 100;
        
        if (!groups[zone]) {
          groups[zone] = {
            count: totalCount,
            healthy: healthyCount,
            health: health
          };
        }
      });

      dashboardConfig.global.groups = groups;
      return Promise.resolve();
    });
  }

  // --- DEVICE LIST SORTING ---
  window.sortDeviceList = function(column) {
    // Initialize sort state if not exists
    if (!window.deviceListSort) {
      window.deviceListSort = { column: null, direction: 'asc' };
    }
    // Unlock manual order when user requests a sort
    window.deviceListSortLocked = false;
    
    // If clicking the same column, toggle direction; otherwise set new column and default to asc
    if (window.deviceListSort.column === column) {
      window.deviceListSort.direction = window.deviceListSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
      window.deviceListSort.column = column;
      window.deviceListSort.direction = 'asc';
    }
    // Re-render the dashboard with new sort
    updateDashboard();
  };

  // --- LIVE DASHBOARD UPDATE ---
  function updateDashboard() {
    // Get dashboard container (should already exist in HTML)
    let dashboardContainer = document.getElementById('universalView');
    if (!dashboardContainer) {
      return;
    }

    // Get the content area
    let contentArea = document.getElementById('universalDashboardContent');
    if (!contentArea) {
      return;
    }

    // Update status display
    const statusDiv = document.getElementById('discoveryStatus');
    if (statusDiv) {
      const global = dashboardConfig?.global || dashboardConfig || {};
      if (global.lastSync) {
        statusDiv.textContent = `Last sync: ${new Date(global.lastSync).toLocaleString()} | ${(global.snapshot || []).length} components discovered`;
        statusDiv.style.color = '#4CAF50';
      } else {
        statusDiv.textContent = 'No discovery run yet. Click "🔄 Refresh Discovery" to scan the entire station.';
        statusDiv.style.color = '#888';
      }
    }

    // Build HTML for content area
    let html = '';

    // Initialize expanded sections state
    if (!window.dashboardExpandedSections) {
      window.dashboardExpandedSections = {};
      // Load from localStorage if available
      try {
        const saved = localStorage.getItem('dashboard_expanded_sections');
        if (saved) {
          window.dashboardExpandedSections = JSON.parse(saved);
        }
      } catch(e) {}
    }

    // Initialize card titles from localStorage
    if (!window.cardTitles) {
      window.cardTitles = {};
      try {
        const saved = localStorage.getItem('dashboard_card_titles');
        if (saved) window.cardTitles = JSON.parse(saved);
      } catch(e) {}
    }
    
    // Initialize drag state
    if (!window.dragState) {
      window.dragState = { item: null, type: null, data: null, sourceContainer: null, sourceContainerId: null, sourceIndex: null };
    }
    
    // Summary cards by type (expandable)
    html += '<div style="margin-bottom:30px;">';
    // Help text (shown once or on request)
    html += '<div style="background:linear-gradient(135deg, rgba(76,175,80,0.1) 0%, rgba(33,150,243,0.05) 100%); border:1px solid #333; border-radius:8px; padding:12px 18px; margin-bottom:20px; display:flex; align-items:center; gap:15px;">';
    html += '<span style="font-size:24px;">💡</span>';
    html += '<div style="flex:1;">';
    html += '<div style="color:#4CAF50; font-weight:bold; margin-bottom:4px;">Tips: Customize Your Dashboard</div>';
    html += '<div style="color:#888; font-size:12px;">';
    html += '⋮⋮ <b>Drag points</b> from Device/Zone cards to <b>Custom Cards</b> below • ';
    html += '<b>Double-click</b> points for related items • ';
    html += '<b>Resize</b> custom cards by dragging corners • ';
    html += '<b>Ctrl+Z</b> to undo';
    html += '</div>';
    html += '</div>';
    html += '</div>';
    
    html += '<h3 style="color:#888; font-size:14px; text-transform:uppercase; margin-bottom:15px;">Device Types</h3>';
    html += '<div style="display:flex; flex-wrap:wrap; gap:20px; align-items:flex-start;">';
    
    const global = dashboardConfig?.global || dashboardConfig || {};
    let groups = global.groups || {};
    let byType = global.byType || {};
    const byZone = global.byZone || {};
    
    // Ensure extracted devices are in byType even if loaded from cache
    // This fixes the issue where extracted devices lose their type grouping
    const extractedSnapshot = global.snapshot || [];
    extractedSnapshot.forEach(function(comp) {
      if (comp.isExtractedPoint && comp.inferredType && comp.inferredType !== 'generic' && comp.inferredType !== 'sensor') {
        const typeKey = comp.inferredType;
        // Check if this device is already in its type group
        if (!byType[typeKey]) {
          byType[typeKey] = [];
        }
        const alreadyInType = byType[typeKey].some(function(c) { return c.ord === comp.ord; });
        if (!alreadyInType) {
          byType[typeKey].push(comp);
        }
        // Ensure groups entry exists
        if (!groups[typeKey]) {
          groups[typeKey] = { count: 0, healthy: 0, health: 100 };
        }
        // Update count if needed
        if (groups[typeKey].count < byType[typeKey].length) {
          groups[typeKey].count = byType[typeKey].length;
          const healthyCount = byType[typeKey].filter(function(c) { 
            const status = (c.outStatus || c.status || 'ok').toLowerCase();
            return !status.includes('alarm') && !status.includes('fault') && !status.includes('down');
          }).length;
          groups[typeKey].healthy = healthyCount;
          groups[typeKey].health = Math.round((healthyCount / groups[typeKey].count) * 100);
        }
      }
    });
    
    // Save the fixed byType and groups back to config
    if (dashboardConfig.global) {
      dashboardConfig.global.byType = byType;
      dashboardConfig.global.groups = groups;
    }
    
    // Helper: apply saved card order for type cards
    function getOrderedTypeKeys(keys) {
      const order = (window.DashboardState.cardOrder && window.DashboardState.cardOrder.types) ? window.DashboardState.cardOrder.types : [];
      const ordered = [];
      // First, add keys that appear in saved order
      order.forEach(function(id) {
        if (id && id.startsWith('type_')) {
          const k = id.replace('type_', '');
          if (keys.indexOf(k) >= 0 && ordered.indexOf(k) === -1) ordered.push(k);
        }
      });
      // Then, append any remaining keys not yet added
      keys.forEach(function(k) {
        if (ordered.indexOf(k) === -1) ordered.push(k);
      });
      return ordered;
    }
    
    const typeKeys = getOrderedTypeKeys(Object.keys(groups));
    typeKeys.forEach(function(key, idx) {
      const group = groups[key];
      // Skip "generic" type if user wants to hide it (can be toggled in rules editor)
      const hideGeneric = dashboardConfig?.global?.hideGenericType || false;
      if (hideGeneric && key === 'generic') {
        return; // Skip generic type
      }
      // Only show type groups (not zone groups in this section)
      if (group.count > 0 && byType && byType[key]) {
        const healthColor = group.health >= 90 ? '#4CAF50' : group.health >= 70 ? '#FF9800' : '#f44336';
        const sectionKey = 'type_' + key;
        const isExpanded = window.dashboardExpandedSections[sectionKey] || false;
        const components = byType[key] || [];
        
        // Check if any components have alarms
        const alarmCount = components.filter(function(c) {
          const status = (c.outStatus || c.status || '').toLowerCase();
          return status.includes('alarm') || c.hasAlarm;
        }).length;
        const hasAlarms = alarmCount > 0;
        
        // Calculate ring circumference (2 * PI * radius)
        const ringRadius = 28;
        const ringCircum = 2 * Math.PI * ringRadius;
        const ringOffset = ringCircum - (group.health / 100) * ringCircum;
        
        // Format type name for display
        let displayName = key.charAt(0).toUpperCase() + key.slice(1);
        if (key === 'exhaustfan') displayName = 'Exhaust Fans';
        else if (key === 'watersensor') displayName = 'Water Sensors';
        else if (key === 'chilledwater') displayName = 'Chilled Water';
        else if (key === 'heatpump') displayName = 'Heat Pumps';
        else if (key === 'coolingtower') displayName = 'Cooling Towers';
        else if (key === 'generator') displayName = 'Generators';
        else if (key === 'charger') displayName = 'Chargers';
        else if (key === 'boiler') displayName = 'Boilers';
        else if (key === 'pump') displayName = 'Pumps';
        else if (key === 'generic') displayName = 'Other Devices';
        
        // Check if card is hidden
        if (!window.hiddenCards) {
          window.hiddenCards = {};
          try {
            const saved = localStorage.getItem('dashboard_hidden_cards');
            if (saved) window.hiddenCards = JSON.parse(saved);
          } catch(e) {}
        }
        if (window.hiddenCards['type_' + key]) {
          return; // Skip hidden card
        }
        
        html += `<div class="device-type-card ${hasAlarms ? 'has-alarm' : ''}" style="--card-accent-color:${healthColor}; flex:0 1 calc(50% - 10px) !important; min-width:450px !important; width:auto !important;" data-section-type="type" data-section-key="${key}" data-card-type="type" data-card-id="type_${key}" draggable="true" ondragstart="window.handleCardDragStart(event, 'type_${key}')" ondragend="window.handleCardDragEnd(event)" ondragover="window.handleCardDragOver(event)" ondrop="window.handleCardDrop(event)">`;
        
        // Drag handle (top left) + Hide button (top right)
        html += `<span class="drag-handle" style="position:absolute; top:8px; left:8px; cursor:grab; color:#888; font-size:16px; z-index:10;" title="Drag to reorder card">⋮⋮</span>`;
        html += `<button onclick="event.stopPropagation(); window.quickHideCard('type_${key}')" style="position:absolute; top:8px; right:8px; background:#666; color:#fff; border:none; padding:4px 8px; border-radius:3px; cursor:pointer; font-size:10px; opacity:0.7; z-index:10;" title="Hide this card">✕</button>`;
        
        // Header row with name and expand arrow - clickable to toggle
        html += `<div style="cursor:pointer; text-align:left;" onclick="event.stopPropagation(); window.toggleSection('type', '${key}')">`;
        html += `<div style="display:flex; justify-content:space-between; align-items:flex-start;">`;
        html += `<div style="flex:1;">`;
        html += `<div style="font-weight:bold; color:#fff; font-size:15px; margin-bottom:4px; text-align:left;">${displayName}</div>`;
        // Include custom points in count
        const typeCardKey = 'type_' + key;
        const typeCustomizations = window.DashboardState.cardCustomizations && window.DashboardState.cardCustomizations[typeCardKey];
        const assignedPointsCount = (typeCustomizations && typeCustomizations.customPoints) ? typeCustomizations.customPoints.length : 0;
        const totalCount = group.count + assignedPointsCount;
        html += `<div style="font-size:11px; color:#888;">${totalCount} device${totalCount !== 1 ? 's' : ''}${assignedPointsCount > 0 ? ' (+' + assignedPointsCount + ' assigned)' : ''}</div>`;
        html += `</div>`;
        
        // Animated health ring
        html += `<div class="health-ring">`;
        html += `<svg width="70" height="70" viewBox="0 0 70 70">`;
        html += `<circle class="health-ring-bg" cx="35" cy="35" r="${ringRadius}"/>`;
        html += `<circle class="health-ring-progress" cx="35" cy="35" r="${ringRadius}" stroke="${healthColor}" stroke-dasharray="${ringCircum}" stroke-dashoffset="${ringOffset}"/>`;
        html += `</svg>`;
        html += `<div class="health-ring-text" style="color:${healthColor};">${group.health}%</div>`;
        html += `</div>`;
        html += `</div>`;
        
        // Status summary row
        html += `<div style="display:flex; align-items:center; gap:15px; margin-top:12px; padding-top:12px; border-top:1px solid #333;">`;
        // Include assigned points in healthy count (assigned points are always OK)
        const healthyCount = group.healthy + assignedPointsCount;
        html += `<div style="display:flex; align-items:center;"><span class="status-dot healthy"></span><span style="color:#888; font-size:12px;">${healthyCount} OK</span></div>`;
        if (group.count - group.healthy > 0) {
          html += `<div style="display:flex; align-items:center;"><span class="status-dot ${hasAlarms ? 'alarm' : 'warning'}"></span><span style="color:#888; font-size:12px;">${group.count - group.healthy} Issue${group.count - group.healthy !== 1 ? 's' : ''}</span></div>`;
        }
        if (hasAlarms) {
          html += `<div style="display:flex; align-items:center;"><span class="status-dot alarm"></span><span style="color:#f44336; font-size:12px; font-weight:bold;">🚨 ${alarmCount} Alarm${alarmCount !== 1 ? 's' : ''}</span></div>`;
        }
        html += `<span style="color:#888; font-size:18px; margin-left:auto;">${isExpanded ? '▼' : '▶'}</span>`;
        html += `</div>`;
        
        // Action buttons (only show if has alarms)
        if (hasAlarms) {
          html += `<div class="card-actions">`;
          html += `<button class="card-btn card-btn-alarm" onclick="event.stopPropagation(); window.showAlarmsForType('${key}')">🔔 View Alarms</button>`;
          html += `<button class="card-btn card-btn-primary" onclick="event.stopPropagation(); window.toggleSection('type', '${key}')">📋 Details</button>`;
          html += `</div>`;
        }
        
        // Expandable device list
        html += `<div id="section_type_${key}" style="max-height:${isExpanded ? '500px' : '0'}; overflow:hidden; ${isExpanded ? '' : 'height:0;'} transition:max-height 0.3s ease; margin-top:15px; max-width:100%; box-sizing:border-box; clear:both;">`;
        if (isExpanded) {
          // Initialize card sort state
          if (!window.cardSortState) window.cardSortState = {};
          if (!window.cardSortState[key]) window.cardSortState[key] = { column: 'name', direction: 'asc' };
          const sortState = window.cardSortState[key];
          
          function getSortIcon(col) {
            if (sortState.column !== col) return ' ↕';
            return sortState.direction === 'asc' ? ' ↑' : ' ↓';
          }
          
          // All content in one scrollable container so header and rows align
          html += '<div style="max-height:400px; overflow-y:auto;" class="points-container" data-container-type="type" data-container-id="' + key + '" ondragover="window.handlePointContainerDragOver(event)" ondrop="window.handlePointContainerDrop(event)" ondragleave="window.handlePointContainerDragLeave(event)">';
          // Header row
          html += '<div style="display:flex; background:#1e1e1e; padding:6px 8px; font-size:11px; color:#888; border-bottom:1px solid #333; position:sticky; top:0; z-index:1;">';
          html += '<div style="flex:1; cursor:pointer;" onclick="event.stopPropagation(); window.sortCardList(\'' + key + '\', \'name\')" title="Sort by name">Device' + getSortIcon('name') + '</div>';
          html += '<div style="width:70px; text-align:right; cursor:pointer;" onclick="event.stopPropagation(); window.sortCardList(\'' + key + '\', \'value\')" title="Sort by value">Value' + getSortIcon('value') + '</div>';
          html += '<div style="width:60px; text-align:center; cursor:pointer;" onclick="event.stopPropagation(); window.sortCardList(\'' + key + '\', \'status\')" title="Sort by status">Status' + getSortIcon('status') + '</div>';
          html += '<div style="width:50px; text-align:center;">Actions</div>';
          html += '</div>';
          
          // Sort components based on current sort state
          let sortedComponents = components.slice().sort(function(a, b) {
            let result = 0;
            if (sortState.column === 'name') {
              const nameA = (a.name || a.originalName || '').toLowerCase();
              const nameB = (b.name || b.originalName || '').toLowerCase();
              result = nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
            } else if (sortState.column === 'value') {
              const valA = parseFloat(a.outValue) || 0;
              const valB = parseFloat(b.outValue) || 0;
              result = valA - valB;
            } else if (sortState.column === 'status') {
              const statusPriority = { 'ok': 0, 'healthy': 0, 'stale': 1, 'fault': 2, 'alarm': 2, 'down': 3 };
              const statusA = (a.outStatus || a.status || 'ok').toLowerCase();
              const statusB = (b.outStatus || b.status || 'ok').toLowerCase();
              const prioA = statusPriority[statusA] !== undefined ? statusPriority[statusA] : 4;
              const prioB = statusPriority[statusB] !== undefined ? statusPriority[statusB] : 4;
              result = prioA - prioB;
            }
            return sortState.direction === 'asc' ? result : -result;
          });
          
          // Apply custom point order if available (only if no active sort or sort is by name)
          const typeCustomizations = window.DashboardState.cardCustomizations && window.DashboardState.cardCustomizations[typeCardKey];
          const assignedPointsAll = (typeCustomizations && typeCustomizations.customPoints) ? typeCustomizations.customPoints.slice() : [];
          if (typeCustomizations && typeCustomizations.pointOrder && typeCustomizations.pointOrder.length > 0) {
            // Only apply custom order if sorting by name (default) or if no sort is active
            // This allows users to override custom order by sorting by other columns
            if (!sortState.column || sortState.column === 'name') {
              // Reorder sortedComponents based on stored pointOrder, including assigned points
              const pointOrder = typeCustomizations.pointOrder;
              const orderedItems = [];
              const remainingComponents = sortedComponents.slice();
              const remainingAssigned = assignedPointsAll.slice();
              
              pointOrder.forEach(function(ord) {
                const normalizedOrd = (ord || '').replace(/slot:slot:/g, 'slot:');
                // look in components first
                const cIdx = remainingComponents.findIndex(function(c) {
                  const compOrd = (c.ord || c.slotPath || '').replace(/slot:slot:/g, 'slot:');
                  return compOrd === normalizedOrd;
                });
                if (cIdx >= 0) {
                  orderedItems.push(remainingComponents[cIdx]);
                  remainingComponents.splice(cIdx, 1);
                  return;
                }
                // then in assigned points
                const aIdx = remainingAssigned.findIndex(function(cp) {
                  const cpOrd = (cp.ord || cp.data?.ord || '').replace(/slot:slot:/g, 'slot:');
                  return cpOrd === normalizedOrd;
                });
                if (aIdx >= 0) {
                  const ap = remainingAssigned[aIdx];
                  const apData = ap.data || ap;
                  const fakeComp = {
                    __assigned: true,
                    name: apData.name || apData.originalName || 'Assigned Point',
                    ord: ap.ord || apData.ord || apData.slotPath || '',
                    slotPath: apData.slotPath,
                    outValue: apData.value || apData.outValue,
                    status: apData.status || apData.outStatus || 'ok',
                    outStatus: apData.outStatus || apData.status || 'ok',
                    inferredType: apData.inferredType || apData.type || 'generic',
                    zone: apData.zone || 'Assigned',
                    data: apData
                  };
                  orderedItems.push(fakeComp);
                  remainingAssigned.splice(aIdx, 1);
                  return;
                }
              });
              
              // add leftovers: remaining components first, then remaining assigned
              orderedItems.push.apply(orderedItems, remainingComponents);
              remainingAssigned.forEach(function(ap) {
                const apData = ap.data || ap;
                const fakeComp = {
                  __assigned: true,
                  name: apData.name || apData.originalName || 'Assigned Point',
                  ord: ap.ord || apData.ord || apData.slotPath || '',
                  slotPath: apData.slotPath,
                  outValue: apData.value || apData.outValue,
                  status: apData.status || apData.outStatus || 'ok',
                  outStatus: apData.outStatus || apData.status || 'ok',
                  inferredType: apData.inferredType || apData.type || 'generic',
                  zone: apData.zone || 'Assigned',
                  data: apData
                };
                orderedItems.push(fakeComp);
              });
              
              sortedComponents = orderedItems;
              console.log('✅ Applied custom point order to type card (with assigned):', typeCardKey, 'ordered:', orderedItems.length);
            } else {
            }
          }
          
          sortedComponents.forEach(function(comp) {
            const isAssigned = comp.__assigned === true;
            const isExtracted = comp.isExtractedPoint;
            const status = isAssigned ? (comp.status || 'ok').toLowerCase() : (isExtracted ? (comp.outStatus || comp.status || 'ok').toLowerCase() : (comp.status || 'unknown'));
            let statusColor = '#4CAF50';
            let statusText = isExtracted ? 'OK' : 'Healthy';
            let rowStyle = '';
            if (status.includes('down') || status === 'offline') {
              statusColor = '#9E9E9E';
              statusText = 'Offline';
            } else if (status.includes('fault')) {
              statusColor = '#f44336';
              statusText = 'Fault';
              rowStyle = 'background:#3d1a1a;';
            } else if (status.includes('stale')) {
              statusColor = '#FF9800';
              statusText = 'Stale';
            } else if (status.includes('alarm') || comp.hasAlarm) {
              statusColor = '#f44336';
              statusText = '🔴 ALARM' + (comp.alarmCount ? ' (' + comp.alarmCount + ')' : '');
              rowStyle = 'background:#3d1a1a; border-left:3px solid #f44336;';
            }
            
            // For extracted devices: show value @ zone, for regular: just zone
            let zoneValueDisplay = comp.zone || 'Unassigned';
            if (isExtracted && comp.outValue !== undefined && comp.outValue !== null && comp.outValue !== '') {
              const formattedVal = formatValue(comp.outValue);
              zoneValueDisplay = formattedVal + (comp.zone && comp.zone !== 'Unassigned' ? ' @ ' + comp.zone : '');
            }
            
            const pointData = isAssigned ? (comp.data || comp) : {
              name: comp.name || comp.originalName || 'Unknown',
              ord: comp.ord || comp.slotPath || '',
              type: comp.inferredType || 'generic',
              value: comp.outValue,
              status: comp.outStatus || comp.status,
              zone: comp.zone,
              isExtracted: isExtracted
            };
            const pointDataStr = JSON.stringify(pointData).replace(/'/g, "&#39;").replace(/"/g, '&quot;');
            
            const pointIndex = sortedComponents.indexOf(comp);
            // Draggable and reorderable within cards
            html += '<div style="display:flex; align-items:center; justify-content:flex-start; padding:6px 8px; border-bottom:1px solid #333; font-size:11px; cursor:grab; text-align:left; ' + rowStyle + '" draggable="true" data-container-type="type" data-container-id="' + key + '" data-point-index="' + pointIndex + '" data-point-data="' + pointDataStr + '" ondragstart="window.handlePointDragStart(event, \'' + pointDataStr.replace(/'/g, "\\'") + '\')" ondragend="window.handlePointDragEnd(event)" ondragover="window.handlePointDragOver(event)" ondrop="window.handlePointDrop(event)" ondblclick="window.showPointHelper(event, \'' + pointDataStr.replace(/'/g, "\\'") + '\')" class="draggable-point" title="Drag to move or reorder">';
            html += `<div style="flex:1; color:${isAssigned ? '#4CAF50' : '#fff'}; font-weight:${comp.hasAlarm ? 'bold' : (isAssigned ? 'bold' : 'normal')}; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;"><span class="drag-handle" title="Drag to move">⋮⋮</span> ${comp.name || comp.originalName || pointData.name || 'Unknown'}</div>`;
            html += `<div style="width:70px; color:#888; text-align:right; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${zoneValueDisplay}</div>`;
            html += `<div style="width:60px; text-align:center; white-space:nowrap;"><span style="color:${statusColor}; font-weight:bold;">●</span> ${statusText}</div>`;
            if (isAssigned && pointData.ord) {
              html += `<div style="width:50px; text-align:center;"><button onclick="event.stopPropagation(); window.openPxGraphic('${pointData.ord}', '${(pointData.name || 'Point').replace(/'/g, "\\'")}')" style="background:#2196F3; color:white; border:none; padding:3px 6px; border-radius:3px; cursor:pointer; font-size:10px;">PX</button></div>`;
            } else {
              html += `<div style="width:50px; text-align:center;"><button onclick="event.stopPropagation(); window.openPxGraphic('${comp.ord}', '${(comp.name || comp.originalName || 'Unknown').replace(/'/g, "\\'")}')" style="background:#2196F3; color:white; border:none; padding:3px 6px; border-radius:3px; cursor:pointer; font-size:10px;">PX</button></div>`;
            }
            html += '</div>';
          });
          
          html += '</div>'; // Close points-container
        }
        html += '</div>';
        html += '</div>';
      }
    });
    
    html += '</div></div>';

    // Zone sections (expandable) - filter out "Unassigned" and "unknown"
    // Helper to apply saved zone card order
    function getOrderedZoneKeys(keys) {
      const order = (window.DashboardState.cardOrder && window.DashboardState.cardOrder.zones) ? window.DashboardState.cardOrder.zones : [];
      const ordered = [];
      order.forEach(function(id) {
        if (id && id.startsWith('zone_')) {
          const k = id.replace('zone_', '');
          if (keys.indexOf(k) >= 0 && ordered.indexOf(k) === -1) ordered.push(k);
        }
      });
      keys.forEach(function(k) {
        if (ordered.indexOf(k) === -1) ordered.push(k);
      });
      return ordered;
    }

    if (byZone && Object.keys(byZone).length > 0) {
      html += '<h3 style="color:#888; font-size:14px; text-transform:uppercase; margin-bottom:15px;">Zones</h3>';
      html += '<div style="display:flex; flex-wrap:wrap; gap:20px; margin-bottom:30px; align-items:flex-start;">';
      
      getOrderedZoneKeys(Object.keys(byZone)).forEach(function(zone, idx) {
        // Skip "Unassigned", "unknown", "0", and empty zones
        if (!zone || zone.toLowerCase() === 'unassigned' || zone.toLowerCase() === 'unknown' || zone.trim() === '' || zone === '0' || zone.toString() === '0') {
          return;
        }
        const components = byZone[zone];
        const group = groups[zone] || { health: 100, count: components.length, healthy: components.length };
        const healthColor = group.health >= 90 ? '#4CAF50' : group.health >= 70 ? '#FF9800' : '#f44336';
        const sectionKey = 'zone_' + zone;
        const isExpanded = window.dashboardExpandedSections[sectionKey] || false;
        
        // Check if zone card is hidden
        if (!window.hiddenCards) {
          window.hiddenCards = {};
          try {
            const saved = localStorage.getItem('dashboard_hidden_cards');
            if (saved) window.hiddenCards = JSON.parse(saved);
          } catch(e) {}
        }
        if (window.hiddenCards['zone_' + zone]) {
          return; // Skip hidden zone
        }
        
        html += `<div class="zone-card" style="background:#2d2d2d; padding:15px; border-radius:8px; flex:0 1 calc(50% - 10px) !important; min-width:450px !important; width:auto !important;" data-section-type="zone" data-section-key="${zone.replace(/'/g, "\\'")}" data-card-type="zone" data-card-id="zone_${zone.replace(/'/g, "\\'")}" draggable="true" ondragstart="window.handleCardDragStart(event, 'zone_${zone.replace(/'/g, "\\'")}')" ondragend="window.handleCardDragEnd(event)" ondragover="window.handleCardDragOver(event)" ondrop="window.handleCardDrop(event)">`;
        html += `<button onclick="event.stopPropagation(); window.quickHideCard('zone_${zone.replace(/'/g, "\\'")}')" style="position:absolute; top:8px; right:12px; background:#666; color:#fff; border:none; padding:4px 8px; border-radius:3px; cursor:pointer; font-size:10px; opacity:0.8; z-index:10;" title="Hide this zone">✕</button>`;
        html += `<span class="drag-handle" style="position:absolute; top:8px; left:8px; cursor:grab; color:#888; font-size:16px; z-index:10;" title="Drag to reorder card">⋮⋮</span>`;
        html += `<div style="padding-left:18px; padding-right:48px; cursor:pointer; text-align:left;" onclick="event.stopPropagation(); window.toggleSection('zone', '${zone.replace(/'/g, "\\'")}')">`;
        html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">`;
        html += `<div style="font-weight:bold; color:#fff; font-size:15px;">${zone}</div>`;
        // Include custom points in count
        const zoneCardKey = 'zone_' + zone;
        const zoneCustomizations = window.DashboardState.cardCustomizations && window.DashboardState.cardCustomizations[zoneCardKey];
        const zoneCustomPointsCount = (zoneCustomizations && zoneCustomizations.customPoints) ? zoneCustomizations.customPoints.length : 0;
        const zoneTotalCount = components.length + zoneCustomPointsCount;
        
        // Calculate alarm count
        let zoneAlarmCount = 0;
        components.forEach(function(comp) {
          const status = (comp.outStatus || comp.status || 'ok').toLowerCase();
          if (status === 'alarm' || status === 'fault') {
            zoneAlarmCount++;
          }
        });
        const hasAlarms = zoneAlarmCount > 0;
        
        html += `<div style="display:flex; align-items:center; gap:10px;">`;
        // Include custom points in healthy count (custom points are always OK)
        const zoneHealthyCount = group.healthy + zoneCustomPointsCount;
        html += `<div style="color:${healthColor}; font-weight:bold; font-size:14px;">${group.health}%</div>`;
        html += `<span style="color:#888; font-size:18px;">${isExpanded ? '▼' : '▶'}</span>`;
        html += `</div></div>`;
        
        // Status summary row (like device type cards)
        html += `<div style="display:flex; align-items:center; gap:15px; margin-top:12px; padding-top:12px; border-top:1px solid #333;">`;
        html += `<div style="display:flex; align-items:center;"><span class="status-dot healthy"></span><span style="color:#888; font-size:12px;">${zoneHealthyCount} OK</span></div>`;
        if (zoneTotalCount - zoneHealthyCount > 0) {
          html += `<div style="display:flex; align-items:center;"><span class="status-dot ${hasAlarms ? 'alarm' : 'warning'}"></span><span style="color:#888; font-size:12px;">${zoneTotalCount - zoneHealthyCount} Issue${zoneTotalCount - zoneHealthyCount !== 1 ? 's' : ''}</span></div>`;
        }
        if (hasAlarms) {
          html += `<div style="display:flex; align-items:center;"><span class="status-dot alarm"></span><span style="color:#f44336; font-size:12px; font-weight:bold;">🚨 ${zoneAlarmCount} Alarm${zoneAlarmCount !== 1 ? 's' : ''}</span></div>`;
        }
        html += `<div style="margin-left:auto; font-size:11px; color:#888;">${zoneTotalCount} device${zoneTotalCount !== 1 ? 's' : ''}${zoneCustomPointsCount > 0 ? ' (+' + zoneCustomPointsCount + ' custom)' : ''}</div>`;
        html += `</div>`;
        html += `</div>`; // Close clickable div
        
        // Expandable device list
        html += `<div id="section_zone_${zone.replace(/[^a-zA-Z0-9]/g, '_')}" style="max-height:${isExpanded ? '500px' : '0'}; overflow-y:${isExpanded ? 'auto' : 'hidden'}; overflow-x:hidden; ${isExpanded ? '' : 'height:0;'} transition:max-height 0.3s ease; margin-top:15px; max-width:100%; box-sizing:border-box; clear:both;">`;
        if (isExpanded) {
          // Initialize zone sort state
          const zoneSortKey = 'zone_' + zone;
          if (!window.cardSortState) window.cardSortState = {};
          if (!window.cardSortState[zoneSortKey]) window.cardSortState[zoneSortKey] = { column: 'name', direction: 'asc' };
          const zoneSortState = window.cardSortState[zoneSortKey];
          
          function getZoneSortIcon(col) {
            if (zoneSortState.column !== col) return ' ↕';
            return zoneSortState.direction === 'asc' ? ' ↑' : ' ↓';
          }
          
          // Sort zone components
          let sortedZoneComponents = components.slice().sort(function(a, b) {
            let result = 0;
            if (zoneSortState.column === 'name') {
              const nameA = (a.name || a.originalName || '').toLowerCase();
              const nameB = (b.name || b.originalName || '').toLowerCase();
              result = nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
            } else if (zoneSortState.column === 'type') {
              result = (a.inferredType || '').localeCompare(b.inferredType || '');
            } else if (zoneSortState.column === 'status') {
              const statusPriority = { 'ok': 0, 'healthy': 0, 'stale': 1, 'fault': 2, 'alarm': 2, 'down': 3 };
              const statusA = (a.status || 'ok').toLowerCase();
              const statusB = (b.status || 'ok').toLowerCase();
              result = (statusPriority[statusA] || 4) - (statusPriority[statusB] || 4);
            }
            return zoneSortState.direction === 'asc' ? result : -result;
          });
          
          // Apply custom point order if available (only if no active sort or sort is by name)
          if (zoneCustomizations && zoneCustomizations.pointOrder && zoneCustomizations.pointOrder.length > 0) {
            // Only apply custom order if sorting by name (default) or if no sort is active
            if (!zoneSortState.column || zoneSortState.column === 'name') {
              // Reorder sortedZoneComponents based on stored pointOrder
              const pointOrder = zoneCustomizations.pointOrder;
              const orderedComponents = [];
              const remainingComponents = sortedZoneComponents.slice();
              
              // First, add components in the stored order
              pointOrder.forEach(function(ord) {
                const idx = remainingComponents.findIndex(function(c) {
                  return (c.ord || c.slotPath || '') === ord;
                });
                if (idx >= 0) {
                  orderedComponents.push(remainingComponents[idx]);
                  remainingComponents.splice(idx, 1);
                }
              });
              
              // Then add any remaining components that weren't in the order
              orderedComponents.push.apply(orderedComponents, remainingComponents);
              sortedZoneComponents = orderedComponents;
            }
          }
          
          const safeZoneSortKey = zoneSortKey.replace(/'/g, "\\'");
          // Container with drop handler for editable cards
          html += '<div class="points-container" data-container-type="zone" data-container-id="' + zone.replace(/"/g, '&quot;') + '" ondragover="window.handlePointContainerDragOver(event)" ondrop="window.handlePointContainerDrop(event)" ondragleave="window.handlePointContainerDragLeave(event)" style="max-height:400px; overflow-y:auto; padding-left:8px; padding-right:8px;">';
          // Header row - sticky inside scrollable container
          html += '<div style="display:flex; background:#1e1e1e; padding:6px 8px; font-size:11px; color:#888; border-bottom:1px solid #333; position:sticky; top:0; z-index:1;">';
          html += '<div style="flex:1; cursor:pointer;" onclick="event.stopPropagation(); window.sortCardList(\'' + safeZoneSortKey + '\', \'name\')" title="Sort by name">Device' + getZoneSortIcon('name') + '</div>';
          html += '<div style="width:70px; text-align:right; cursor:pointer;" onclick="event.stopPropagation(); window.sortCardList(\'' + safeZoneSortKey + '\', \'type\')" title="Sort by type">Type' + getZoneSortIcon('type') + '</div>';
          html += '<div style="width:60px; text-align:center; cursor:pointer;" onclick="event.stopPropagation(); window.sortCardList(\'' + safeZoneSortKey + '\', \'status\')" title="Sort by status">Status' + getZoneSortIcon('status') + '</div>';
          html += '<div style="width:50px; text-align:center;">Actions</div>';
          html += '</div>';
          
          // Display custom points assigned to this zone card
          const zoneCardKey = 'zone_' + zone;
          const zoneCustomizationsExpanded = zoneCustomizations || (window.DashboardState.cardCustomizations ? window.DashboardState.cardCustomizations[zoneCardKey] : null) || { customPoints: [] };
          if (zoneCustomizationsExpanded.customPoints && zoneCustomizationsExpanded.customPoints.length > 0) {
            zoneCustomizationsExpanded.customPoints.forEach(function(customPoint, idx) {
              const cp = customPoint.data || customPoint;
              const pointDataStr = JSON.stringify(cp).replace(/'/g, "&#39;").replace(/"/g, '&quot;');
              html += '<div style="display:flex; align-items:center; padding:6px 8px; border-bottom:1px solid #333; font-size:11px; background:#1e1e1e; border-left:2px solid #4CAF50; text-align:left;" draggable="true" data-container-type="zone" data-container-id="' + zone.replace(/"/g, '&quot;') + '" data-point-index="custom_' + idx + '" data-point-data="' + pointDataStr + '" ondragstart="window.handlePointDragStart(event, \'' + pointDataStr.replace(/'/g, "\\'") + '\')" ondragend="window.handlePointDragEnd(event)" ondragover="window.handlePointDragOver(event)" ondrop="window.handlePointDrop(event)" class="draggable-point" title="Custom point - Drag to move or remove">';
              html += '<div style="flex:1; color:#4CAF50; font-weight:bold;"><span class="drag-handle">⋮⋮</span> ' + (cp.name || 'Custom Point') + ' <span style="color:#888; font-size:9px;">(custom)</span></div>';
              html += '<div style="width:70px; color:#888; text-align:right;">' + (cp.type || 'custom') + '</div>';
              html += '<div style="width:60px; text-align:center;"><span style="color:#4CAF50;">●</span> OK</div>';
              html += '<div style="width:50px; text-align:center;">';
              if (cp.ord) {
                html += '<button onclick="event.stopPropagation(); window.openPxGraphic(\'' + cp.ord + '\', \'' + (cp.name || 'Custom Point').replace(/'/g, "\\'") + '\')" style="background:#2196F3; color:white; border:none; padding:2px 6px; border-radius:3px; cursor:pointer; font-size:10px; margin-right:2px;">PX</button>';
              }
              html += '<button onclick="event.stopPropagation(); window.removeCustomPointFromCard(\'zone\', \'' + zone.replace(/'/g, "\\'") + '\', ' + idx + ')" style="background:#f44336; color:white; border:none; padding:2px 6px; border-radius:3px; cursor:pointer; font-size:10px;">×</button>';
              html += '</div>';
              html += '</div>';
            });
          }
          
          sortedZoneComponents.forEach(function(comp) {
            const status = comp.status || 'unknown';
            let statusColor = '#4CAF50';
            let statusText = 'Healthy';
            if (status === 'down' || status === 'offline') {
              statusColor = '#9E9E9E';
              statusText = 'Offline';
            } else if (status === 'fault') {
              statusColor = '#f44336';
              statusText = 'Fault';
            } else if (status === 'stale') {
              statusColor = '#FF9800';
              statusText = 'Stale';
            }
            const pointData = {
              name: comp.name || comp.originalName || 'Unknown',
              ord: comp.ord || comp.slotPath || '',
              type: comp.inferredType || 'generic',
              status: comp.status,
              zone: zone
            };
            const pointDataStr = JSON.stringify(pointData).replace(/'/g, "&#39;").replace(/"/g, '&quot;');
            
            const pointIndex = sortedZoneComponents.indexOf(comp);
            const safeZone = zone.replace(/'/g, "\\'");
            // Draggable and reorderable within cards
            html += '<div style="display:flex; align-items:center; justify-content:flex-start; padding:6px 8px; border-bottom:1px solid #333; font-size:11px; cursor:grab; text-align:left;" draggable="true" data-container-type="zone" data-container-id="' + zone.replace(/"/g, '&quot;') + '" data-point-index="' + pointIndex + '" data-point-data="' + pointDataStr + '" ondragstart="window.handlePointDragStart(event, \'' + pointDataStr.replace(/'/g, "\\'") + '\')" ondragend="window.handlePointDragEnd(event)" ondragover="window.handlePointDragOver(event)" ondrop="window.handlePointDrop(event)" ondblclick="window.showPointHelper(event, \'' + pointDataStr.replace(/'/g, "\\'") + '\')" class="draggable-point" title="Drag to move or reorder">';
            html += `<div style="flex:1; color:#fff; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;"><span class="drag-handle">⋮⋮</span> ${comp.name || comp.originalName || 'Unknown'}</div>`;
            html += `<div style="width:70px; color:#888; text-align:right; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${comp.inferredType || 'generic'}</div>`;
            html += `<div style="width:60px; text-align:center; white-space:nowrap;"><span style="color:${statusColor};">●</span> ${statusText}</div>`;
            html += `<div style="width:50px; text-align:center;"><button onclick="event.stopPropagation(); window.openPxGraphic('${comp.ord}', '${(comp.name || comp.originalName || 'Unknown').replace(/'/g, "\\'")}')" style="background:#2196F3; color:white; border:none; padding:3px 6px; border-radius:3px; cursor:pointer; font-size:10px;">PX</button></div>`;
            html += '</div>';
          });
        }
        html += '</div>';
        html += '</div>';
      });
      
      html += '</div>';
    }
    
    // Custom Cards Section
    html += '<div style="margin-top:40px; margin-bottom:30px;">';
    html += '<h3 style="color:#888; font-size:14px; text-transform:uppercase; margin-bottom:15px;">Custom Cards</h3>';
    html += '<div id="customCardsContainer" style="display:grid; grid-template-columns:repeat(auto-fill, minmax(300px, 1fr)); gap:15px;">';
    
    // Load custom cards from localStorage
    if (!window.customCards) {
      window.customCards = [];
      try {
        const saved = localStorage.getItem('dashboard_custom_cards');
        if (saved) {
          window.customCards = JSON.parse(saved);
        }
      } catch(e) {}
    }
    
    // Render existing custom cards
    window.customCards.forEach(function(card, index) {
      html += renderCustomCard(card, index);
    });
    
    // Create new card drop zone
    html += '<div class="create-card-zone" ondragover="window.handleDropZoneDragOver(event)" ondrop="window.handleCreateCardDrop(event)" ondragleave="this.classList.remove(\'drag-over\')">';
    html += '➕ Drop points here to create a new card';
    html += '</div>';
    
    // Add card button
    html += '<div style="background:#1e1e1e; border:2px dashed #4CAF50; border-radius:8px; padding:15px; cursor:pointer; text-align:center; color:#4CAF50; transition:all 0.3s;" onclick="window.addCustomCard()" onmouseover="this.style.background=\'#2a2a2a\'" onmouseout="this.style.background=\'#1e1e1e\'">➕ Add Custom Card</div>';
    
    html += '</div></div>';

    // Full device list (All Devices) with reorder support
    if (!window.DashboardState.allDevicesOrder) {
      window.DashboardState.allDevicesOrder = [];
    }
    html += '<div style="text-align:left; margin-left:0; width:100%;">';
    html += '<h3 style="color:#888; font-size:14px; text-transform:uppercase; margin-bottom:15px; text-align:left; margin-left:0; padding-left:0;">All Devices</h3>';
    
    // Calculate health summary for All Devices
    let snapshot = (global.snapshot || []).filter(function(comp) {
      const name = (comp.name || comp.originalName || '').toLowerCase();
      const slotPath = (comp.slotPath || '').toLowerCase();
      const systemNames = ['status', 'enabled', 'faultCause', 'ping', 'ackAlarm', 'upload', 'download', 
        'asyncPing', 'submitDeviceManagerJob', 'lookupDeviceById', 'lookupDeviceByAddress', 
        'lookupDeviceOrdById', 'lookupDeviceOrdByAddress', 'displayNames', 'privateTransferResultBlockFlag',
        'shouldSupportFaultForMultiState', 'uploadOnStart', 'writeOnFacetChange', 'health', 
        'alarmSourceInfo', 'monitor', 'historyPolicies', 'worker', 'writeWorker', 'bacnetComm',
        'localDevice', 'tuningPolicies', 'covWorker', 'HonBacnetDeviceConfig', 
        'honeywellBacnetDeviceManager_HonBacnetDeviceTypeHandler', 'HyperlinkList', 'BacnetLinkManagerUtil'];
      const isSystem = systemNames.some(function(sysName) {
        return name === sysName.toLowerCase() || 
               slotPath.includes('/' + sysName.toLowerCase() + '/') ||
               slotPath.endsWith('/' + sysName.toLowerCase());
      });
      if (slotPath) {
        const pathParts = slotPath.split('/');
        if (pathParts.includes('monitor') && pathParts.length > 3) return false;
        if (pathParts.length === 3 && pathParts[0] === 'drivers' && pathParts[1] === 'bacnetnetwork') return false;
      }
      return !isSystem;
    });
    
    // Ensure and apply saved order for All Devices if exists (helper on window for reuse)
    if (!window.normalizeAllDevicesOrder) {
      window.normalizeAllDevicesOrder = function(snap) {
        if (!window.DashboardState.allDevicesOrder) window.DashboardState.allDevicesOrder = [];
        let order = (window.DashboardState.allDevicesOrder || []).map(function(o) {
          return (o || '').replace(/slot:slot:/g, 'slot:');
        }).filter(Boolean);
        const normSnap = snap.map(function(c) {
          return (c.ord || c.slotPath || '').replace(/slot:slot:/g, 'slot:');
        }).filter(Boolean);
        // Drop ords not in snapshot
        order = order.filter(function(o) { return normSnap.indexOf(o) >= 0; });
        // Append any missing ords in snapshot order
        normSnap.forEach(function(o) {
          if (order.indexOf(o) === -1) order.push(o);
        });
        window.DashboardState.allDevicesOrder = order;
        return order;
      };
    }
    
    const allOrder = window.normalizeAllDevicesOrder(snapshot);
    if (allOrder.length > 0) {
      window.deviceListSortLocked = true;
      window.deviceListSort = { column: null, direction: 'asc' };
    }
    if (allOrder.length > 0) {
      const ordered = [];
      const remaining = snapshot.slice();
      allOrder.forEach(function(ord) {
        const normOrd = (ord || '').replace(/slot:slot:/g, 'slot:');
        const idx = remaining.findIndex(function(c) {
          const cOrd = (c.ord || c.slotPath || '').replace(/slot:slot:/g, 'slot:');
          return cOrd === normOrd;
        });
        if (idx >= 0) {
          ordered.push(remaining[idx]);
          remaining.splice(idx, 1);
        }
      });
      ordered.push.apply(ordered, remaining);
      snapshot = ordered;
    }

    let allDevicesHealthy = 0;
    let allDevicesTotal = snapshot.length;
    let allDevicesAlarms = 0;
    snapshot.forEach(function(comp) {
      const status = (comp.outStatus || comp.status || 'ok').toLowerCase();
      if (status === 'ok' || status === 'healthy') {
        allDevicesHealthy++;
      } else if (status === 'alarm' || status === 'fault') {
        allDevicesAlarms++;
      }
    });
    const allDevicesHealth = allDevicesTotal > 0 ? Math.round((allDevicesHealthy / allDevicesTotal) * 100) : 100;
    const allDevicesHealthColor = allDevicesHealth >= 90 ? '#4CAF50' : allDevicesHealth >= 70 ? '#FF9800' : '#f44336';
    
    // Health summary row
    html += '<div style="display:flex; align-items:center; gap:15px; margin-bottom:15px; padding:10px; background:#2d2d2d; border-radius:6px;">';
    html += `<div style="display:flex; align-items:center;"><span class="status-dot healthy"></span><span style="color:#888; font-size:12px;">${allDevicesHealthy} OK</span></div>`;
    if (allDevicesTotal - allDevicesHealthy > 0) {
      html += `<div style="display:flex; align-items:center;"><span class="status-dot ${allDevicesAlarms > 0 ? 'alarm' : 'warning'}"></span><span style="color:#888; font-size:12px;">${allDevicesTotal - allDevicesHealthy} Issue${allDevicesTotal - allDevicesHealthy !== 1 ? 's' : ''}</span></div>`;
    }
    if (allDevicesAlarms > 0) {
      html += `<div style="display:flex; align-items:center;"><span class="status-dot alarm"></span><span style="color:#f44336; font-size:12px; font-weight:bold;">🚨 ${allDevicesAlarms} Alarm${allDevicesAlarms !== 1 ? 's' : ''}</span></div>`;
    }
    html += `<div style="margin-left:auto; color:${allDevicesHealthColor}; font-weight:bold; font-size:14px;">${allDevicesHealth}% Health</div>`;
    html += '</div>';
    
      html += '<div style="max-height:500px; overflow-y:auto; max-width:100%; box-sizing:border-box;" class="points-container" data-container-type="alldevices" data-container-id="snapshot" ondragover="window.handlePointContainerDragOver(event)" ondrop="window.handlePointContainerDrop(event)" ondragleave="window.handlePointContainerDragLeave(event)">';
      
      // Initialize sort state if not exists
      if (!window.deviceListSort) {
        window.deviceListSort = { column: null, direction: 'asc' };
      }
      const sortState = window.deviceListSort;
      
      // Helper function to get sort indicator (inline)
      function getSortIndicator(col) {
        if (sortState.column !== col) return ' ↕️';
        return sortState.direction === 'asc' ? ' ↑' : ' ↓';
      }
      
      const nameIndicator = getSortIndicator('name');
      const typeIndicator = getSortIndicator('type');
      const valueIndicator = getSortIndicator('value');
      const statusIndicator = getSortIndicator('status');
      
      // Header row using flexbox - same style as Device Type cards
      html += '<div style="display:flex; background:#1e1e1e; padding:6px 8px; font-size:11px; color:#888; border-bottom:1px solid #333; position:sticky; top:0; z-index:1;">';
      html += `<div style="flex:1; cursor:pointer;" onclick="window.sortDeviceList('name')" title="Click to sort by Device Name">Device${nameIndicator}</div>`;
      html += `<div style="width:70px; text-align:right; cursor:pointer;" onclick="window.sortDeviceList('type')" title="Click to sort by Type">Type${typeIndicator}</div>`;
      html += `<div style="width:70px; text-align:right; cursor:pointer;" onclick="window.sortDeviceList('value')" title="Click to sort by Value/Temperature">Value${valueIndicator}</div>`;
      html += `<div style="width:60px; text-align:center; cursor:pointer;" onclick="window.sortDeviceList('status')" title="Click to sort by Status">Status${statusIndicator}</div>`;
      html += '<div style="width:50px; text-align:center;">Actions</div>';
      html += '</div>';

    // Filter out system components from snapshot
    const systemNames = ['status', 'enabled', 'faultCause', 'ping', 'ackAlarm', 'upload', 'download', 
      'asyncPing', 'submitDeviceManagerJob', 'lookupDeviceById', 'lookupDeviceByAddress', 
      'lookupDeviceOrdById', 'lookupDeviceOrdByAddress', 'displayNames', 'privateTransferResultBlockFlag',
      'shouldSupportFaultForMultiState', 'uploadOnStart', 'writeOnFacetChange', 'health', 
      'alarmSourceInfo', 'monitor', 'historyPolicies', 'worker', 'writeWorker', 'bacnetComm',
      'localDevice', 'tuningPolicies', 'covWorker', 'HonBacnetDeviceConfig', 
      'honeywellBacnetDeviceManager_HonBacnetDeviceTypeHandler', 'HyperlinkList', 'BacnetLinkManagerUtil'];
    
    // Reuse the snapshot already filtered above (line 4691)
    // Add debug logging for extracted devices
    snapshot.forEach(function(comp) {
      if (comp.isExtractedPoint) {
      }
    });
    
    // Apply sorting based on current sort state (skip if manual order is active)
    const manualOrderActive = window.deviceListSortLocked === true;
    if (!window.deviceListSort) {
      window.deviceListSort = { column: 'type', direction: 'asc' };
    }
    const currentSortState = window.deviceListSort;
    if (!manualOrderActive && currentSortState && currentSortState.column) {
      snapshot.sort(function(a, b) {
        let result = 0;
        
        if (currentSortState.column === 'name') {
          const nameA = (a.name || a.originalName || '').toLowerCase();
          const nameB = (b.name || b.originalName || '').toLowerCase();
          result = nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
        } else if (currentSortState.column === 'type') {
          const typeA = (a.inferredType || 'zzz_generic').toLowerCase();
          const typeB = (b.inferredType || 'zzz_generic').toLowerCase();
          result = typeA.localeCompare(typeB, undefined, { sensitivity: 'base' });
          // If types are equal, sort by name
          if (result === 0) {
            const nameA = (a.name || a.originalName || '').toLowerCase();
            const nameB = (b.name || b.originalName || '').toLowerCase();
            result = nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
          }
        } else if (currentSortState.column === 'value') {
          // Extract numeric value from outValue or zoneDisplay
          const isExtractedA = a.isExtractedPoint;
          const isExtractedB = b.isExtractedPoint;
          
          let valA = null;
          let valB = null;
          
          if (isExtractedA && a.outValue !== undefined && a.outValue !== null && a.outValue !== '') {
            valA = parseFloat(a.outValue);
          }
          if (isExtractedB && b.outValue !== undefined && b.outValue !== null && b.outValue !== '') {
            valB = parseFloat(b.outValue);
          }
          
          // If both have values, compare numerically
          if (valA !== null && valB !== null) {
            result = valA - valB;
          } else if (valA !== null) {
            result = -1; // A has value, B doesn't - A comes first
          } else if (valB !== null) {
            result = 1; // B has value, A doesn't - B comes first
          } else {
            // Neither has value, sort by name
            const nameA = (a.name || a.originalName || '').toLowerCase();
            const nameB = (b.name || b.originalName || '').toLowerCase();
            result = nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
          }
        } else if (currentSortState.column === 'status') {
          // Sort by status priority: healthy > stale > fault > down
          const statusPriority = { 'ok': 0, 'healthy': 0, 'stale': 1, 'fault': 2, 'down': 3, 'offline': 3, 'error': 2, 'alarm': 2 };
          const statusA = (a.isExtractedPoint ? (a.outStatus || a.status || 'ok') : (a.status || 'unknown')).toLowerCase();
          const statusB = (b.isExtractedPoint ? (b.outStatus || b.status || 'ok') : (b.status || 'unknown')).toLowerCase();
          
          const priorityA = statusPriority[statusA] !== undefined ? statusPriority[statusA] : 
                           (statusA.includes('alarm') || a.hasAlarm ? 2 : 4);
          const priorityB = statusPriority[statusB] !== undefined ? statusPriority[statusB] : 
                           (statusB.includes('alarm') || b.hasAlarm ? 2 : 4);
          
          result = priorityA - priorityB;
          // If same priority, sort by name
          if (result === 0) {
            const nameA = (a.name || a.originalName || '').toLowerCase();
            const nameB = (b.name || b.originalName || '').toLowerCase();
            result = nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
          }
        } else {
          // Default: Sort by Type first, then AlphaNumeric by name
          const typeA = (a.inferredType || 'zzz_generic').toLowerCase();
          const typeB = (b.inferredType || 'zzz_generic').toLowerCase();
          
          if (typeA !== typeB) {
            result = typeA.localeCompare(typeB, undefined, { sensitivity: 'base' });
          } else {
            const nameA = (a.name || a.originalName || '').toLowerCase();
            const nameB = (b.name || b.originalName || '').toLowerCase();
            result = nameA.localeCompare(nameB, undefined, { numeric: true, sensitivity: 'base' });
          }
        }
        
        // Apply direction
        return currentSortState.direction === 'asc' ? result : -result;
      });
    } else if (manualOrderActive) {
    }
    
    // Initialize expanded devices state
    if (!window.expandedDevices) {
      window.expandedDevices = {};
      try {
        const saved = localStorage.getItem('dashboard_expanded_devices');
        if (saved) {
          window.expandedDevices = JSON.parse(saved);
        }
      } catch(e) {}
    }
    
    snapshot.forEach(function(comp) {
      // For extracted points, use outStatus as health; for devices, use regular status
      const isExtracted = comp.isExtractedPoint;
      const status = isExtracted ? (comp.outStatus || comp.status || 'ok').toLowerCase() : (comp.status || 'unknown');
      let healthColor = '#4CAF50';
      let statusText = isExtracted ? 'OK' : 'Healthy';
      
      if (status.includes('down') || status === 'offline') {
        healthColor = '#9E9E9E';
        statusText = 'Offline';
      } else if (status.includes('fault')) {
        healthColor = '#f44336';
        statusText = 'Fault';
      } else if (status.includes('stale')) {
        healthColor = '#FF9800';
        statusText = 'Stale';
      } else if (status === 'error') {
        healthColor = '#f44336';
        statusText = 'Error';
      } else if (status.includes('alarm') || comp.hasAlarm) {
        healthColor = '#f44336';
        statusText = '🔴 ALARM' + (comp.alarmCount ? ' (' + comp.alarmCount + ')' : '');
      }
      
      // For extracted points: show VALUE in zone column, append zone in parentheses if available
      // For regular devices: show zone
      let zoneDisplay = comp.zone || 'Unassigned';
      if (isExtracted) {
        if (comp.outValue !== undefined && comp.outValue !== null && comp.outValue !== '') {
          const formattedValue = formatValue(comp.outValue);
          const zoneStr = comp.zone && comp.zone !== 'Unassigned' ? ' @ ' + comp.zone : '';
          zoneDisplay = formattedValue + zoneStr;
        } else {
          // No value - show zone with indicator
          zoneDisplay = comp.zone || 'No Value';
        }
      }
      
      // Format device type for display
      let typeDisplay = comp.inferredType || 'generic';
      if (typeDisplay === 'exhaustfan') typeDisplay = 'Exhaust Fan';
      else if (typeDisplay === 'watersensor') typeDisplay = 'Water Sensor';
      else if (typeDisplay === 'chilledwater') typeDisplay = 'Chilled Water';
      else if (typeDisplay === 'boiler') typeDisplay = 'Boiler';
      else if (typeDisplay === 'generator') typeDisplay = 'Generator';
      else if (typeDisplay === 'charger') typeDisplay = 'Charger';
      else if (typeDisplay === 'coolingtower') typeDisplay = 'Cooling Tower';
      else if (typeDisplay === 'pump') typeDisplay = 'Pump';
      else if (typeDisplay === 'heatpump') typeDisplay = 'Heat Pump';
      else if (typeDisplay === 'ahu') typeDisplay = 'AHU';
      else if (typeDisplay === 'mau') typeDisplay = 'MAU';
      else if (typeDisplay === 'vav') typeDisplay = 'VAV';
      
      const deviceId = comp.ord || comp.slotPath || comp.name;
      const isExpanded = window.expandedDevices[deviceId] || false;
      
      const pointData = {
        name: comp.name || comp.originalName || 'Unknown',
        ord: comp.ord || comp.slotPath || '',
        type: comp.inferredType || 'generic',
        value: comp.outValue,
        status: comp.outStatus || comp.status,
        zone: comp.zone,
        isExtracted: isExtracted
      };
      const pointDataStr = JSON.stringify(pointData);
      const pointDataStrEscaped = pointDataStr.replace(/'/g, "&#39;").replace(/"/g, '&quot;');
      const pointDataStrForJS = pointDataStr.replace(/'/g, "\\'").replace(/"/g, '\\"');
      const pointDataStrEncoded = encodeURIComponent(pointDataStr);
      
      const allDevicesIndex = snapshot.indexOf(comp);
      // Draggable and reorderable
      const ordNormalized = (pointData.ord || pointData.slotPath || '').replace(/slot:slot:/g, 'slot:');
      html += '<div style="display:flex; align-items:center; padding:6px 8px; border-bottom:1px solid #333; font-size:11px; cursor:grab; background:#1e1e1e;" draggable="true" data-container-type="alldevices" data-container-id="snapshot" data-point-index="' + allDevicesIndex + '" data-point-ord="' + ordNormalized + '" data-point-data="' + pointDataStrEncoded + '" ondragstart="window.handlePointDragStart(event)" ondragend="window.handlePointDragEnd(event)" ondragover="window.handlePointDragOver(event)" ondrop="window.handlePointDrop(event)" ondblclick="window.showPointHelper(event)" class="draggable-point" title="Drag to move to another card">';
      html += `<div style="flex:1; color:#fff; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; display:flex; align-items:center;">`;
      
      // For extracted points, don't show expand arrow (they don't have child points)
      if (!isExtracted) {
        html += `<span style="cursor:pointer; margin-right:8px; font-size:14px;" onclick="event.stopPropagation(); window.toggleDevicePoints('${deviceId.replace(/'/g, "\\'")}')">${isExpanded ? '▼' : '▶'}</span>`;
      } else {
        html += '<span style="margin-right:8px; font-size:14px; opacity:0.3;">📊</span>';
      }
      html += `<span class="drag-handle" style="margin-right:8px; cursor:grab; color:#888;" title="Drag to move">⋮⋮</span>`;
      html += `<span>${comp.name || comp.originalName || 'Unknown'}</span>`;
      html += `</div>`;
      html += `<div style="width:70px; color:#888; text-align:right; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${typeDisplay}</div>`;
      html += `<div style="width:70px; color:#888; text-align:right; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${zoneDisplay}</div>`;
      html += `<div style="width:60px; text-align:center; white-space:nowrap;"><span style="color:${healthColor};">●</span> ${statusText}</div>`;
      
      // For extracted points, show parent PX button; for devices, show their own PX
      if (isExtracted && comp.parentDevice) {
        html += `<div style="width:50px; text-align:center;"><button onclick="event.stopPropagation(); window.openPxGraphic('${comp.parentDevice}', '${(comp.parentName || 'Unknown').replace(/'/g, "\\'")}')" style="background:#2196F3; color:white; border:none; padding:3px 6px; border-radius:3px; cursor:pointer; font-size:10px;">PX</button></div>`;
      } else {
        html += `<div style="width:50px; text-align:center;"><button onclick="event.stopPropagation(); window.openPxGraphic('${comp.ord}', '${(comp.name || comp.originalName || 'Unknown').replace(/'/g, "\\'")}')" style="background:#2196F3; color:white; border:none; padding:3px 6px; border-radius:3px; cursor:pointer; font-size:10px;">PX</button></div>`;
      }
      html += '</div>';
      
      // Expandable points row (only for non-extracted devices)
      if (!isExtracted) {
        html += `<div id="device_points_${deviceId.replace(/[^a-zA-Z0-9]/g, '_')}" style="display:${isExpanded ? 'block' : 'none'}; background:#1a1a1a; padding:15px;">`;
        html += `<div id="device_points_content_${deviceId.replace(/[^a-zA-Z0-9]/g, '_')}" style="padding-left:30px;">`;
        if (isExpanded) {
          html += '<div style="color:#888; font-size:12px;">Loading control points...</div>';
        }
        html += '</div></div>';
      }
    });

    html += '</div></div>';

    // Overrides section
    html += '<div style="margin-top:30px;">';
    html += '<div style="background:#2d2d2d; padding:20px; border-radius:8px; border-top:4px solid #9C27B0;">';
    html += '<div style="display:flex; justify-content:space-between; margin-bottom:15px;">';
    html += '<h3 style="color:#AB47BC; margin:0;">🔧 Active Overrides / Manual Control</h3>';
    html += '<span id="dashOverrideCount" style="color:#888; font-size:12px;">Scanning...</span>';
    html += '</div>';
    html += '<div style="max-height:300px; overflow-y:auto;">';
    // Header row - same style as Device Type cards
    html += '<div style="display:flex; background:#1e1e1e; padding:6px 8px; font-size:11px; color:#888; border-bottom:1px solid #333; position:sticky; top:0; z-index:1;">';
    html += '<div style="flex:1;">Equipment</div>';
    html += '<div style="width:70px; text-align:right;">Point</div>';
    html += '<div style="width:60px; text-align:center;">Value</div>';
    html += '<div style="width:50px; text-align:center;">Action</div>';
    html += '</div>';
    html += '<div id="overrideTableBody">';
    html += '<div style="text-align:center; padding:20px; color:#888;">Scanning for overrides...</div>';
    html += '</div></div></div></div>';

    // Update content area
    if (contentArea) {
      contentArea.innerHTML = html;
    }
    
    // Load overrides
    loadOverrides();
    
    // Load points for any devices that were expanded (from saved state)
    setTimeout(function() {
      snapshot.forEach(function(comp) {
        const deviceId = comp.ord || comp.slotPath || comp.name;
        const isExpanded = window.expandedDevices[deviceId] || false;
        if (isExpanded) {
          loadDeviceControlPoints(deviceId);
        }
      });
      
      // Render existing history charts in custom cards
      if (window.customCards && window.customCards.length > 0) {
        window.customCards.forEach(function(card, cardIndex) {
          if (card.sections && card.sections.length > 0) {
            card.sections.forEach(function(section, sectionIndex) {
              if (section.type === 'history' && section.histories && section.histories.length > 0) {
                setTimeout(function() {
                  window.renderHistoryChartInCard(cardIndex, sectionIndex);
                }, 200 + (cardIndex * 50)); // Stagger rendering to avoid blocking
              }
            });
          }
        });
      }
    }, 100); // Small delay to ensure DOM is ready
  }
  
  // Load overrides
  function loadOverrides() {
    const overrideBql = "station:|slot:/Drivers|bql:select slotPath, displayName, out, status from control:ControlPoint where status.overridden = 'true'";
    
    baja.Ord.make(overrideBql).get()
      .then(function(table) {
        const overrides = [];
        return table.cursor({
          each: function(row) {
            const path = row.get('slotPath');
            const disp = row.get('displayName');
            const val = row.get('out');
            
            if (!path) return;
            const ord = 'station:|' + path;
            
            const parts = path.split('/');
            let equipName = "Unknown";
            const ptsIdx = parts.indexOf('points');
            if (ptsIdx > 0) equipName = parts[ptsIdx - 1];
            else if (parts.length > 2) equipName = parts[parts.length - 2];
            
            overrides.push({
              equip: equipName,
              point: disp ? disp.toString() : 'Unknown',
              val: val ? val.toString() : 'Null',
              ord: ord
            });
          },
          after: function() {
            const ovTable = document.getElementById('overrideTableBody');
            const countSpan = document.getElementById('dashOverrideCount');
            if (countSpan) countSpan.textContent = overrides.length + " Found";
            
            if (ovTable) {
              if (overrides.length === 0) {
                ovTable.innerHTML = '<div style="text-align:center; padding:15px; color:#4CAF50;">✅ No manual overrides detected.</div>';
              } else {
                let html = '';
                overrides.forEach(function(o) {
                  // Same style as Device Type cards
                  html += '<div style="display:flex; align-items:center; padding:6px 8px; border-bottom:1px solid #333; font-size:11px;">';
                  html += '<div style="flex:1; color:#e0e0e0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">' + o.equip + '</div>';
                  html += '<div style="width:70px; color:#e0e0e0; text-align:right; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">' + o.point + '</div>';
                  html += '<div style="width:60px; color:#AB47BC; text-align:center; font-weight:bold;">' + o.val + '</div>';
                  html += '<div style="width:50px; text-align:center;">';
                  html += '<button onclick="window.invokeOverrideAction(\'' + o.ord + '\', \'auto\')" style="background:#4CAF50; color:white; border:none; border-radius:3px; cursor:pointer; padding:2px 4px; font-size:9px;">A</button>';
                  html += '</div>';
                  html += '</div>';
                });
                ovTable.innerHTML = html;
              }
            }
          }
        });
      })
      .catch(function(err) {
        const countSpan = document.getElementById('dashOverrideCount');
        if (countSpan) countSpan.textContent = "Error";
      });
  }

    // Expose functions globally
  window.refreshDiscovery = runFullDiscovery;
  
  // --- EXPANDABLE DEVICE POINTS ---
  window.toggleDevicePoints = function(deviceId) {
    const isExpanded = window.expandedDevices[deviceId] || false;
    window.expandedDevices[deviceId] = !isExpanded;
    
    // Save to localStorage
    try {
      localStorage.setItem('dashboard_expanded_devices', JSON.stringify(window.expandedDevices));
    } catch(e) {}
    
    // Toggle visibility
    const rowId = 'device_points_' + deviceId.replace(/[^a-zA-Z0-9]/g, '_');
    const row = document.getElementById(rowId);
    if (row) {
      row.style.display = !isExpanded ? 'block' : 'none';
    }
    
    // Update expand/collapse icon in the device row
    const deviceRow = row ? row.previousElementSibling : null;
    if (deviceRow) {
      const iconSpan = deviceRow.querySelector('span[onclick*="toggleDevicePoints"]');
      if (iconSpan) {
        iconSpan.textContent = !isExpanded ? '▼' : '▶';
      }
    }
    
    // Load points if expanding
    if (!isExpanded) {
      loadDeviceControlPoints(deviceId);
    } else {
      // Clean up subscriptions when collapsing
      window.cleanupDevicePointsSubscriptions(deviceId);
    }
  };
  
  // Load control points for a device
  async function loadDeviceControlPoints(deviceId) {
    const contentId = 'device_points_content_' + deviceId.replace(/[^a-zA-Z0-9]/g, '_');
    const contentDiv = document.getElementById(contentId);
    if (!contentDiv) {
      return;
    }
    
    // Find the device component
    const global = dashboardConfig?.global || dashboardConfig || {};
    const snapshot = global.snapshot || [];
    const device = snapshot.find(function(comp) {
      return (comp.ord || comp.slotPath || comp.name) === deviceId;
    });
    if (!device || !device.ord) {
      contentDiv.innerHTML = '<div style="color:#888; font-size:12px;">Device not found</div>';
      return;
    }
    
    const deviceOrd = device.ord;
    const deviceSlotPath = deviceOrd.replace('station:|slot:', '');
    contentDiv.innerHTML = '<div style="color:#888; font-size:12px;">Loading control points...</div>';
    
    try {
      const points = [];
      
      // Initialize subscriber for live data if not exists
      if (!window.devicePointsSubscribers) {
        window.devicePointsSubscribers = {};
      }
      if (!window.devicePointsSubscribers[deviceId]) {
        window.devicePointsSubscribers[deviceId] = new baja.Subscriber();
      }
      const subscriber = window.devicePointsSubscribers[deviceId];
      
      // Primary method: Use BQL to find control points (more reliable)
      const bqlQuery = `station:|slot:${deviceSlotPath}|bql:select slotPath, displayName, name, typeName, out, status from control:ControlPoint`;
      try {
        await new Promise(function(resolve, reject) {
          // Set a timeout to prevent endless waiting
          const timeout = setTimeout(function() {
            reject(new Error('Query timeout'));
          }, 30000);
          
          baja.Ord.make(bqlQuery).get().then(function(table) {
            clearTimeout(timeout);
            table.cursor({
              limit: 500, // Limit results to prevent endless processing
              each: function(record) {
                try {
                  const slotPath = record.get('slotPath') ? record.get('slotPath').toString() : '';
                  const displayName = record.get('displayName') ? record.get('displayName').toString() : '';
                  const name = record.get('name') ? record.get('name').toString() : '';
                  const typeName = record.get('typeName') ? record.get('typeName').toString() : '';
                  let value = 'N/A';
                  let pointStatus = 'ok';
                  
                  try {
                    const outVal = record.get('out');
                    if (outVal) {
                      const outStr = outVal.toString();
                      // Parse the value - format is typically "value {status}"
                      const match = outStr.match(/^(.+?)\s*\{([^}]+)\}/);
                      if (match) {
                        value = match[1].trim();
                        pointStatus = match[2].trim();
                      } else {
                        value = outStr;
                      }
                      // Format numeric values to max 2 decimal places
                      const numVal = parseFloat(value);
                      if (!isNaN(numVal)) {
                        value = numVal % 1 === 0 ? numVal.toString() : numVal.toFixed(2);
                      }
                    }
                  } catch(e) {}
                  
                  try {
                    const statusVal = record.get('status');
                    if (statusVal) {
                      const statusStr = statusVal.toString().toLowerCase();
                      if (statusStr.includes('alarm')) {
                        pointStatus = 'alarm';
                      } else if (statusStr.includes('fault')) {
                        pointStatus = 'fault';
                      } else if (statusStr.includes('stale')) {
                        pointStatus = 'stale';
                      } else if (statusStr.includes('down')) {
                        pointStatus = 'down';
                      }
                    }
                  } catch(e) {}
                  
                  // Skip logic components
                  const logicComponents = ['Or', 'Not', 'And', 'Xor', 'Nand', 'Nor', 'Or1'];
                  if (logicComponents.includes(name)) {
                    return;
                  }
                  
                  // Check hidden points
                  if (!window.hiddenPoints) {
                    window.hiddenPoints = {};
                    try {
                      const saved = localStorage.getItem('dashboard_hidden_points');
                      if (saved) {
                        window.hiddenPoints = JSON.parse(saved);
                      }
                    } catch(e) {}
                  }
                  
                  const pointKey = name.toLowerCase();
                  if (window.hiddenPoints[pointKey]) {
                    return;
                  }
                  
                  // Apply auto-filtering
                  if (shouldAutoFilterPoint(name, displayName)) {
                    return;
                  }
                  
                  // Clean up display name - if displayName is same as slot name, try to make it readable
                  let cleanDisplayName = displayName || name;
                  if (!displayName || displayName === name) {
                    // Remove common prefixes and add spaces at camelCase boundaries
                    cleanDisplayName = name
                      .replace(/^(in|out|no_|cfg_|ni_|gEnb)/i, '') // Remove prefixes
                      .replace(/([a-z])([A-Z])/g, '$1 $2') // Add space at camelCase
                      .replace(/_/g, ' ') // Replace underscores with spaces
                      .trim();
                    // Capitalize first letter of each word
                    cleanDisplayName = cleanDisplayName.replace(/\b\w/g, function(l) { return l.toUpperCase(); });
                  }
                  
                  console.log('✅ [DEBUG] BQL found point:', cleanDisplayName, '(slot:', name, ') value:', value);
                  
                  points.push({
                    name: cleanDisplayName,
                    originalName: name,
                    value: value,
                    status: pointStatus,
                    typeName: typeName,
                    ord: slotPath ? 'station:|slot:' + slotPath : null,
                    slotPath: slotPath,
                    hasHistory: false,
                    historyId: null
                  });
                } catch(e) {
                }
              },
              after: function() {
                resolve();
              }
            });
          }).catch(function(err) {
            clearTimeout(timeout);
            reject(err);
          });
        });
      } catch(bqlErr) {
      }
      // Render points
      if (points.length === 0) {
        contentDiv.innerHTML = '<div style="color:#888; font-size:12px;">No control points found. Check console for debug info.</div>';
        return;
      }
      // Add "Collapse All" button at the top
      let html = '<div style="margin-bottom:10px;">';
      html += '<button onclick="window.collapseAllDevices()" style="padding:4px 8px; font-size:11px; background:#f44336; color:white; border:none; border-radius:3px; cursor:pointer;">🔽 Collapse All Devices</button>';
      html += '</div>';
      
      html += '<div style="font-size:11px; margin-top:10px;">';
      // Header row - same style as Device Type cards
      html += '<div style="display:flex; background:#1e1e1e; padding:6px 8px; color:#888; border-bottom:1px solid #333;">';
      html += '<div style="flex:1;">Point</div>';
      html += '<div style="width:70px; text-align:right;">Value</div>';
      html += '<div style="width:60px; text-align:center;">Status</div>';
      html += '<div style="width:50px; text-align:center;">Actions</div>';
      html += '</div>';
      
      // Track points that should be extracted as separate devices
      const pointsToExtract = [];
      
      // Generic point names that appear on every device - don't extract these
      const genericPointNames = [
        'space temp', 'supply air', 'fan start', 'cool call', 'heat call',
        'location', 'alarm', 'status', 'mode', 'setpoint', 'occupied',
        'current mode', 'add', 'multiply', 'tuncos', 'breaker', 'ahu name'
      ];
      
      points.forEach(function(point) {
        // Check if this point should be extracted as a separate device
        const displayName = point.name || '';
        const slotName = point.originalName || '';
        const displayNameLower = displayName.toLowerCase();
        const slotNameLower = slotName.toLowerCase();
        
        // Skip if it's a generic point name
        const isGenericName = genericPointNames.some(function(generic) {
          return displayNameLower === generic || displayNameLower.includes(generic);
        });
        
        if (isGenericName) {
          return; // Skip generic points
        }
        
        // Check if displayName looks like a device/sensor that should be extracted
        // These patterns indicate a customized sensor reading that the user added
        const extractionPatterns = [
          /exfan/i, /exhfan/i, /exhaust\s*fan/i, /^ef\d/i, /^exf/i, // Exhaust fans
          /water/i, /h20/i, /h2o/i, /hhw/i, /^dom\s*(hot|cold)/i, // Water sensors
          /chw/i, /chilled/i, // Chilled water
          /boiler/i, /outlet\s*temp/i, /stack\s*temp/i, /lead\s*lag/i, // Boiler
          /genset/i, /generator/i, /gen\s*running/i, /coolant/i, /fuel\s*level/i, // Generator
          /battery\s*voltage/i, /oil\s*pressure/i, /engine\s*temp/i, // Generator continued
          /charger/i, /batt/i, /ac_on/i, /ac_fail/i, // Charger
          /cooling\s*tower/i, /^tower/i, /ctp\d*\s*psi/i, // Cooling Tower
          /pump/i, /clp\d*\s*psi/i // Pumps
        ];
        
        const looksLikeExtractableDevice = extractionPatterns.some(function(pattern) {
          return pattern.test(displayName);
        });
        
        // Only extract if:
        // 1. displayName is different from slotName (was customized)
        // 2. displayName matches extraction patterns (is a specific device/sensor)
        // 3. displayName is long enough (more than 3 chars)
        const displayNameChanged = displayName && displayName !== slotName && displayName.length > 3;
        
        if (displayNameChanged && looksLikeExtractableDevice) {
          // Extract equipment name from point's ord/slotPath
          let equipmentName = 'Unknown';
          if (point.slotPath) {
            const parts = point.slotPath.split('/').filter(function(p) { return p; });
            const pointsIndex = parts.indexOf('points');
            if (pointsIndex > 0) {
              equipmentName = parts[pointsIndex - 1];
            }
          }
          
          // Determine proper type based on display name
          let extractedType = 'sensor';
          const displayNameLower = displayName.toLowerCase();
          if (/exfan|exhfan|exhaust\s*fan|^ex\s*fan|^exh\s*fan|^ef\d|^exf/i.test(displayName)) {
            extractedType = 'exhaustfan';
          } else if (/water|h20|h2o|hhw|^dom\s*(hot|cold)/i.test(displayName)) {
            extractedType = 'watersensor';
          } else if (/chw|chilled/i.test(displayName)) {
            extractedType = 'chilledwater';
          } else if (/boiler|outlet\s*temp|stack\s*temp|lead\s*lag/i.test(displayName)) {
            extractedType = 'boiler';
          } else if (/genset|generator|gen\s*running|coolant|fuel\s*level|battery\s*voltage|oil\s*pressure|engine\s*temp/i.test(displayName)) {
            extractedType = 'generator';
          } else if (/charger|batt|ac_on|ac_fail/i.test(displayName)) {
            extractedType = 'charger';
          } else if (/tower|cooling\s*tower|ctp\d*\s*psi/i.test(displayName)) {
            extractedType = 'coolingtower';
          } else if (/pump|clp\d*\s*psi/i.test(displayName)) {
            extractedType = 'pump';
          }
          
          pointsToExtract.push({
            name: displayName + ' (' + equipmentName + ')',
            originalName: slotName,
            ord: point.ord,
            slotPath: point.slotPath,
            parentDevice: deviceId,
            parentName: equipmentName,
            inferredType: extractedType,
            isExtractedPoint: true,
            outValue: point.value,
            outStatus: point.status
          });
        }
        
        let statusColor = '#4CAF50';
        let statusText = 'OK';
        if (point.status === 'down') {
          statusColor = '#9E9E9E';
          statusText = 'Down';
        } else if (point.status === 'fault') {
          statusColor = '#f44336';
          statusText = 'Fault';
        } else if (point.status === 'stale') {
          statusColor = '#FF9800';
          statusText = 'Stale';
        } else if (point.status === 'alarm') {
          statusColor = '#f44336';
          statusText = 'Alarm';
        }
        
        // Create unique IDs for live updates
        const pointId = point.ord.replace(/[^a-zA-Z0-9]/g, '_');
        const valueCellId = 'point_value_' + pointId;
        const statusCellId = 'point_status_' + pointId;
        const historyContainerId = 'point_history_' + pointId;
        const pointKey = (point.originalName || point.name || '').toLowerCase();
        
        // Same style as Device Type cards
        html += '<div style="display:flex; align-items:center; padding:6px 8px; border-bottom:1px solid #2a2a2a;">';
        html += `<div style="flex:1; color:#e0e0e0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${point.name}</div>`;
        html += `<div id="${valueCellId}" style="width:70px; color:#888; text-align:right;">${formatValue(point.value)}</div>`;
        html += `<div id="${statusCellId}" style="width:60px; text-align:center;"><span style="color:${statusColor};">●</span> ${statusText}</div>`;
        
        // Actions column - simplified to match Device Type card style
        const pointNameEscaped = (point.name || point.originalName || '').replace(/'/g, "\\'");
        const originalNameEscaped = (point.originalName || point.name || '').replace(/'/g, "\\'");
        let equipmentName = 'Dashboard';
        if (point.slotPath) {
          const parts = point.slotPath.split('/').filter(function(p) { return p; });
          const pointsIndex = parts.indexOf('points');
          if (pointsIndex > 0) equipmentName = parts[pointsIndex - 1];
        }
        html += '<div style="width:50px; text-align:center;">';
        html += '<button onclick="window.toggleInlineHistoryWithDiscovery(\'' + pointId + '\', \'' + equipmentName.replace(/'/g, "\\'") + '\', \'' + pointNameEscaped + '\', \'' + originalNameEscaped + '\')" style="background:#9c27b0; color:white; border:none; padding:3px 6px; border-radius:3px; cursor:pointer; font-size:10px;" title="View history">📈</button>';
        html += '</div>';
        html += '</div>';
        
        // Inline history container (hidden by default)
        html += '<div id="' + historyContainerId + '" style="display:none; padding:15px; background:#1a1a1a; border-top:2px solid #333;">';
        html += '<div id="' + historyContainerId + '_content" style="font-size:10px; color:#888;">Loading history...</div>';
        html += '</div>';
      });
      
      // After rendering points, extract devices and add them to the snapshot
      if (pointsToExtract.length > 0) {
        // Ensure dashboardConfig and global exist
        if (!dashboardConfig) dashboardConfig = {};
        if (!dashboardConfig.global) dashboardConfig.global = {};
        if (!dashboardConfig.global.snapshot) dashboardConfig.global.snapshot = [];
        
        let newExtractions = 0;
        
        // Find the zone from Location point in the same folder
        let parentZone = null;
        
        // First, try to find the Location point from the loaded points
        const locationPoint = points.find(function(p) {
          const name = (p.originalName || p.name || '').toLowerCase();
          return name === 'location';
        });
        if (locationPoint && locationPoint.value) {
          // Clean up the zone value (remove status markers like {ok})
          parentZone = locationPoint.value.toString()
            .replace(/\{[^}]*\}/g, '')
            .replace(/@[^@]*$/, '')
            .trim();
        }
        
        // Fallback: try to find from parent device in snapshot
        if (!parentZone) {
          const deviceSlotPath = device.slotPath || '';
          const parentDevice = dashboardConfig.global.snapshot.find(function(comp) {
            return comp.ord === device.ord || comp.slotPath === deviceSlotPath;
          });
          parentZone = parentDevice ? parentDevice.zone : device.zone;
        }
        
        pointsToExtract.forEach(function(extractedPoint) {
          // Check if already exists
          const existsIdx = dashboardConfig.global.snapshot.findIndex(function(comp) {
            return comp.ord === extractedPoint.ord;
          });
          
          const extractedDevice = {
            name: extractedPoint.name,
            originalName: extractedPoint.originalName,
            ord: extractedPoint.ord,
            slotPath: extractedPoint.slotPath,
            parentDevice: extractedPoint.parentDevice,
            parentName: extractedPoint.parentName,
            parentPath: extractedPoint.parentPath,
            inferredType: extractedPoint.inferredType,
            isExtractedPoint: true,
            extractedFrom: extractedPoint.parentDevice,
            outValue: extractedPoint.outValue,
            outStatus: extractedPoint.outStatus,
            zone: parentZone || 'Unassigned'
          };
          
          if (existsIdx === -1) {
            dashboardConfig.global.snapshot.push(extractedDevice);
            newExtractions++;
          } else {
            // Update existing entry with latest value and status
            dashboardConfig.global.snapshot[existsIdx].outValue = extractedPoint.outValue;
            dashboardConfig.global.snapshot[existsIdx].outStatus = extractedPoint.outStatus;
            dashboardConfig.global.snapshot[existsIdx].zone = parentZone || dashboardConfig.global.snapshot[existsIdx].zone;
          }
        });
        
        // Only save and update if we actually extracted new devices
        if (newExtractions > 0) {
          // Also add to byType groups so they appear in device type cards
          if (!dashboardConfig.global.byType) dashboardConfig.global.byType = {};
          if (!dashboardConfig.global.groups) dashboardConfig.global.groups = {};
          
          pointsToExtract.forEach(function(extractedPoint) {
            const typeKey = extractedPoint.inferredType || 'sensor';
            
            if (!dashboardConfig.global.byType[typeKey]) {
              dashboardConfig.global.byType[typeKey] = [];
              dashboardConfig.global.groups[typeKey] = { count: 0, healthy: 0, health: 100 };
            }
            
            // Check if already in byType
            const existsInType = dashboardConfig.global.byType[typeKey].some(function(c) {
              return c.ord === extractedPoint.ord;
            });
            
            if (!existsInType) {
              dashboardConfig.global.byType[typeKey].push({
                name: extractedPoint.name,
                originalName: extractedPoint.originalName,
                ord: extractedPoint.ord,
                slotPath: extractedPoint.slotPath,
                zone: parentZone || 'Unassigned',
                status: extractedPoint.outStatus,
                isExtractedPoint: true,
                outValue: extractedPoint.outValue,
                outStatus: extractedPoint.outStatus
              });
              dashboardConfig.global.groups[typeKey].count++;
              // If status is ok, count as healthy
              const status = (extractedPoint.outStatus || 'ok').toLowerCase();
              if (!status.includes('alarm') && !status.includes('fault') && !status.includes('down') && !status.includes('stale')) {
                dashboardConfig.global.groups[typeKey].healthy++;
              }
              // Recalculate health percentage
              dashboardConfig.global.groups[typeKey].health = Math.round(
                (dashboardConfig.global.groups[typeKey].healthy / dashboardConfig.global.groups[typeKey].count) * 100
              );
            }
          });
          
          saveConfig(dashboardConfig).then(function() {
            // Trigger a soft dashboard update to show the new device type cards
            updateDashboard();
          }).catch(function(err) {
          });
        }
      }
      
      html += '</div>';
      contentDiv.innerHTML = html;
      
      // Now that UI is rendered, trigger initial value updates for all subscribed points
      // This ensures we get the latest values after subscription
      if (points.length > 0 && subscriber) {
        points.forEach(function(point) {
          if (point.component) {
            try {
              // Get current value and update UI
              let currentValue = 'N/A';
              if (point.component.getOutDisplay && typeof point.component.getOutDisplay === 'function') {
                const outDisplay = point.component.getOutDisplay();
                if (outDisplay && typeof outDisplay.then === 'function') {
                  outDisplay.then(function(val) {
                    const valueCellId = 'point_value_' + point.ord.replace(/[^a-zA-Z0-9]/g, '_');
                    const valueCell = document.getElementById(valueCellId);
                    if (valueCell) {
                      valueCell.textContent = formatValue(val.toString());
                    }
                  });
                } else if (outDisplay) {
                  currentValue = formatValue(outDisplay.toString());
                }
              } else {
                const out = point.component.get('out');
                if (out) {
                  const outValue = out.get ? out.get('value') : out;
                  if (outValue !== null && outValue !== undefined) {
                    currentValue = outValue.toString();
                    currentValue = currentValue.replace(/\{[^}]*\}/g, '').trim();
                  }
                }
              }
              
              if (currentValue !== 'N/A') {
                const valueCellId = 'point_value_' + point.ord.replace(/[^a-zA-Z0-9]/g, '_');
                const valueCell = document.getElementById(valueCellId);
                if (valueCell) {
                  valueCell.textContent = formatValue(currentValue);
                }
              }
            } catch(e) {
            }
          }
        });
      }
    } catch(err) {
      contentDiv.innerHTML = '<div style="color:#f44336; font-size:12px;">Error loading control points: ' + (err.message || 'Unknown error') + '<br>Check console for details.</div>';
    }
  }

  // --- VALUE FORMATTING ---
  // Format numeric values to max 2 decimal places
  function formatValue(value) {
    if (value === null || value === undefined || value === 'N/A') return value;
    const strVal = String(value).replace(/\{[^}]*\}/g, '').trim();
    const numVal = parseFloat(strVal);
    if (!isNaN(numVal)) {
      // Return whole number if no decimal, otherwise max 2 decimal places
      return numVal % 1 === 0 ? numVal.toString() : numVal.toFixed(2);
    }
    return strVal;
  }

  // --- AUTOMATIC POINT FILTERING ---
  // Automatically filter out points that match certain patterns UNLESS their displayName has been changed
  function shouldAutoFilterPoint(slotName, displayName) {
    if (!slotName) return false;
    
    const slotNameLower = slotName.toLowerCase();
    const displayNameLower = (displayName || '').toLowerCase();
    
    // Check if displayName is different from slotName (meaning it was customized)
    const displayNameChanged = displayName && displayNameLower !== slotNameLower;
    
    // If displayName was changed, don't filter (user customized it)
    if (displayNameChanged) {
      return false;
    }
    
    // Filter patterns:
    // 1. Starts with "Cfg_" or "cfg_"
    if (slotName.startsWith('Cfg_') || slotName.startsWith('cfg_')) {
      return true;
    }
    
    // 2. Contains "Custom" or "custom"
    if (slotNameLower.includes('custom')) {
      return true;
    }
    
    // 3. Starts with "no_" or "No_"
    if (slotName.startsWith('no_') || slotName.startsWith('No_')) {
      return true;
    }
    
    // 4. Starts with "gEnb" or "genb" (case-insensitive)
    if (slotNameLower.startsWith('genb')) {
      return true;
    }
    
    // 5. Starts with "inhibit" (case-insensitive)
    if (slotNameLower.startsWith('inhibit')) {
      return true;
    }
    
    // 6. Starts with "ni_" (case-insensitive)
    if (slotNameLower.startsWith('ni_')) {
      return true;
    }
    
    // 7. Exact matches for specific patterns
    if (slotName === 'NotEqual65536' || slotName === 'notEqual65536' || slotName === 'notequal65536') {
      return true;
    }
    
    if (slotName === 'EqualOffInhibitAlarms' || slotName === 'equalOffInhibitAlarms' || slotName === 'equaloffinhibitalarms') {
      return true;
    }
    
    return false;
  }
  
  // --- POINT FILTERING & HISTORY FUNCTIONS ---
  
  // Initialize hidden points from localStorage
  if (!window.hiddenPoints) {
    window.hiddenPoints = {};
    try {
      const saved = localStorage.getItem('dashboard_hidden_points');
      if (saved) {
        window.hiddenPoints = JSON.parse(saved);
      }
    } catch(e) {
    }
  }
  
  // Hide a point (persistent across all devices)
  window.hidePoint = function(pointKey) {
    if (!pointKey) return;
    const key = pointKey.toLowerCase();
    window.hiddenPoints[key] = true;
    
    // Save to localStorage
    try {
      localStorage.setItem('dashboard_hidden_points', JSON.stringify(window.hiddenPoints));
    } catch(e) {
    }
    
    // Refresh all expanded device views
    if (window.expandedDevices) {
      Object.keys(window.expandedDevices).forEach(function(deviceId) {
        if (window.expandedDevices[deviceId]) {
          // Re-load points for this device
          window.toggleDevicePoints(deviceId);
          setTimeout(function() {
            window.toggleDevicePoints(deviceId);
          }, 100);
        }
      });
    }
    
    // Update dashboard to reflect changes immediately
    if (window.currentTab === 'universal') {
      updateDashboard();
    }
  };
  
  // Add point to history chart from dashboard (discovers history if needed)
  window.addPointToChartFromDashboard = function(equipmentName, pointName, slotName, pointOrd) {
    if (!equipmentName || !pointName) {
      alert('Invalid point data');
      return;
    }
    
    // Use addPointToChartWithOrd which will discover history
    window.addPointToChartWithOrd(equipmentName, pointName, slotName || pointName);
  };
  
  // Add point to history chart tab
  window.addPointToChart = function(historyId, pointName) {
    if (!historyId || !pointName) {
      alert('Invalid history data');
      return;
    }
    
    // Check if already in selectedHistoryPoints
    const existing = selectedHistoryPoints.find(function(p) {
      return p.historyId === historyId;
    });
    
    if (existing) {
      alert('Point "' + pointName + '" is already in the chart.');
      return;
    }
    
    // Add to selectedHistoryPoints
    selectedHistoryPoints.push({
      equipment: 'Dashboard',
      pointName: pointName,
      historyId: historyId,
      displayName: pointName
    });
    
    // Switch to history tab and refresh
    window.switchTab('histories');
    
    // Refresh history dropdown
    setTimeout(function() {
      refreshHistoryPointDropdown();
      // Auto-select the point if dropdown exists
      const dropdown = document.getElementById('histPointDropdown');
      if (dropdown) {
        for (let i = 0; i < dropdown.options.length; i++) {
          if (dropdown.options[i].value === historyId) {
            dropdown.selectedIndex = i;
            break;
          }
        }
      }
    }, 500);
    
    alert('Point "' + pointName + '" added to history chart. Viewing history tab...');
  };
  
  // Toggle inline history view with history discovery
  window.toggleInlineHistoryWithDiscovery = function(pointId, equipmentName, pointName, slotName) {
    const containerId = 'point_history_' + pointId;
    const container = document.getElementById(containerId);
    const contentId = containerId + '_content';
    const contentDiv = document.getElementById(contentId);
    
    if (!container) {
      return;
    }
    
    const isVisible = container.style.display !== 'none' && container.style.display !== '';
    
    if (isVisible) {
      // Hide
      container.style.display = 'none';
      return;
    }
    
    // Show and discover history
    container.style.display = 'table-row';
    if (contentDiv) {
      contentDiv.innerHTML = '<div style="font-size:10px; color:#888; padding:10px;">Discovering history for ' + pointName + '...</div>';
    } else {
      container.innerHTML = '<td colspan="4" style="padding:15px; background:#1a1a1a; border-top:2px solid #333;"><div style="font-size:10px; color:#888; padding:10px;">Discovering history for ' + pointName + '...</div></td>';
    }
    
    // Discover history using BQL - same approach as History Chart tab (discoverHistoriesForEquipment)
    const escapedEquipment = (equipmentName || '').replace(/'/g, "''");
    const slotNameLower = (slotName || '').toLowerCase();
    
    // Use same BQL query as History Chart tab - search for histories under equipment folder
    const bqlOrd = "station:|slot:/Drivers|bql:select id, slotPath from history:HistoryConfig where slotPath like '%/" + escapedEquipment + "/%'";
    baja.Ord.make(bqlOrd).get().then(function(table) {
      const historyRecords = [];
      
      table.cursor({
        each: function(record) {
          try {
            const historyId = record.get('id').toString();
            const slotPathVal = record.get('slotPath') ? record.get('slotPath').toString() : '';
            
            // Parse the slot path to extract point name (same as History Chart tab)
            // Format: /Drivers/BacnetNetwork/HP49/points/no_CtrlSpaceTemp/NumericCov/historyConfig
            const pathMatch = slotPathVal.match(/^(.+)\/(Numeric|Boolean|String|Enum)Cov\/historyConfig$/);
            if (pathMatch) {
              const pointPath = pathMatch[1];
              // Extract the actual point slot name from the path
              const pathParts = pointPath.split('/');
              const pointSlotName = pathParts[pathParts.length - 1];
              historyRecords.push({ 
                id: historyId, 
                slotPath: slotPathVal, 
                pointSlotName: pointSlotName 
              });
            }
          } catch(e) {
          }
        },
        after: function() {
          if (historyRecords.length > 0) {
            // Log all found history point names for debugging
            historyRecords.forEach(function(r) {  });
            
            let foundHistory = null;
            const displayNameLower = (pointName || '').toLowerCase().replace(/\s+/g, '');
            
            // Priority 1: Exact match on slot name
            for (let i = 0; i < historyRecords.length; i++) {
              const rec = historyRecords[i];
              if (rec.pointSlotName && rec.pointSlotName.toLowerCase() === slotNameLower) {
                foundHistory = rec.id;
                break;
              }
            }
            
            // Priority 2: Match based on normalized names (remove prefixes and compare)
            if (!foundHistory) {
              for (let i = 0; i < historyRecords.length; i++) {
                const rec = historyRecords[i];
                const pointLower = (rec.pointSlotName || '').toLowerCase();
                // Remove common prefixes like no_, in_, Ctrl, etc.
                const normalizedHistory = pointLower.replace(/^(no_|in_|out_|ctrl)/gi, '').replace(/_/g, '');
                const normalizedSlot = slotNameLower.replace(/^(no_|in_|out_|ctrl)/gi, '').replace(/_/g, '');
                const normalizedDisplay = displayNameLower.replace(/^(no_|in_|out_|ctrl)/gi, '');
                
                // Check if normalized names match
                if (normalizedHistory === normalizedSlot || normalizedHistory === normalizedDisplay ||
                    normalizedHistory.includes(normalizedSlot) || normalizedSlot.includes(normalizedHistory) ||
                    normalizedHistory.includes(normalizedDisplay) || normalizedDisplay.includes(normalizedHistory)) {
                  foundHistory = rec.id;
                  break;
                }
              }
            }
            
            // Priority 3: Partial match - any overlap
            if (!foundHistory) {
              for (let i = 0; i < historyRecords.length; i++) {
                const rec = historyRecords[i];
                const pointLower = (rec.pointSlotName || '').toLowerCase();
                if (pointLower.includes(slotNameLower) || slotNameLower.includes(pointLower)) {
                  foundHistory = rec.id;
                  break;
                }
              }
            }
            if (foundHistory) {
              // Found history - now load it inline
              window.toggleInlineHistory(pointId, foundHistory, pointName);
            } else {
              const noHistoryHtml = '<div style="font-size:10px; color:#888; padding:10px;">No history found for ' + pointName + '. This point may not have history enabled.</div>';
              if (contentDiv) {
                contentDiv.innerHTML = noHistoryHtml;
              } else {
                container.innerHTML = '<td colspan="4" style="padding:15px; background:#1a1a1a; border-top:2px solid #333;">' + noHistoryHtml + '</td>';
              }
            }
          } else {
            const noHistoryHtml = '<div style="font-size:10px; color:#888; padding:10px;">No history found for ' + pointName + '. This point may not have history enabled.</div>';
            if (contentDiv) {
              contentDiv.innerHTML = noHistoryHtml;
            } else {
              container.innerHTML = '<td colspan="4" style="padding:15px; background:#1a1a1a; border-top:2px solid #333;">' + noHistoryHtml + '</td>';
            }
          }
        }
      });
    }).catch(function(err) {
      const errorHtml = '<div style="font-size:10px; color:#f44336; padding:10px;">Error discovering history: ' + (err.message || err.toString() || 'Unknown error') + '</div>';
      if (contentDiv) {
        contentDiv.innerHTML = errorHtml;
      } else {
        container.innerHTML = '<td colspan="4" style="padding:15px; background:#1a1a1a; border-top:2px solid #333;">' + errorHtml + '</td>';
      }
    });
  };
  
  // Outdoor air temp history cache
  window.outdoorAirTempHistory = null;
  window.outdoorAirTempHistoryId = null;
  
  // Discover outdoor air temp history from air handlers
  window.discoverOutdoorAirTemp = async function() {
    if (window.outdoorAirTempHistoryId) {
      return window.outdoorAirTempHistoryId; // Already found
    }
    try {
      // APPROACH 1: Query history configs to find OAT, get the ID slot from the historyConfig
      const bqlQuery = "select slotPath from history:HistoryConfig where slotPath like '%OaTemp%' or slotPath like '%Outdoor%Air%' or slotPath like '%OA_Temp%' or slotPath like '%OutdoorTemp%' or slotPath like '%LocalOATemp%' or slotPath like '%LocalOA%' or slotPath like '%AHU%OA%'";
      const ord = baja.Ord.make('station:|slot:/|bql:' + bqlQuery);
      const table = await ord.get();
      
      let historyConfigPath = null;
      if (table && table.cursor) {
        table.cursor({
          each: function(record) {
            if (!historyConfigPath) {
              const slotPath = record.get('slotPath');
              if (slotPath && typeof slotPath === 'string') {
                historyConfigPath = slotPath;
              }
            }
          }
        });
      }
      
      // If we found a historyConfig, get its actual history ID
      if (historyConfigPath) {
        try {
          // Get the historyConfig component directly - need to use proper slot path format
          const fullOrd = 'station:|' + historyConfigPath;
          const configOrd = baja.Ord.make(fullOrd);
          const historyConfig = await configOrd.get();
          if (historyConfig) {
            // Try to get the history ID from the 'id' slot
            let histId = null;
            
            // Method 1: Try get('id')
            if (historyConfig.get) {
              try {
                const idSlot = historyConfig.get('id');
                console.log('🔍 [DEBUG] historyConfig.get("id"):', idSlot, 'type:', typeof idSlot);
                if (idSlot) {
                  // The ID might be a BHistoryId object - try to get its string value
                  if (typeof idSlot === 'string') {
                    histId = idSlot;
                  } else if (idSlot.encodeToString) {
                    histId = idSlot.encodeToString();
                  } else if (idSlot.format) {
                    histId = idSlot.format();
                  } else if (idSlot.toString) {
                    const str = idSlot.toString();
                    // The toString might give us something like "/MJHOptimizer1/AHU1 LocalOATemp"
                    if (str && str.includes('/') && str.length > 5) {
                      histId = str;
                    }
                  }
                }
              } catch(e) {
              }
            }
            
            // Method 2: Try slots iterator
            if (!histId && historyConfig.getSlots) {
              try {
                const slots = historyConfig.getSlots();
                if (slots && slots.cursor) {
                  slots.cursor({
                    each: function(slot) {
                      const name = slot.getName ? slot.getName() : '';
                      if (name === 'id' && !histId) {
                        const val = slot.getValue ? slot.getValue() : null;
                        if (val) {
                          histId = typeof val === 'string' ? val : val.toString();
                        }
                      }
                    }
                  });
                }
              } catch(e) {
              }
            }
            
            // Method 3: Log all available properties for debugging
            if (!histId) {
              console.log('🔍 [DEBUG] historyConfig properties:', Object.keys(historyConfig).slice(0, 30));
              if (historyConfig.constructor) {
              }
            }
            
            if (histId && histId.length > 3 && !histId.includes('slot:')) {
              // URL encode spaces as $20 if needed
              if (histId.includes(' ')) {
                histId = histId.replace(/ /g, '$20');
              }
              window.outdoorAirTempHistoryId = histId;
            }
          }
        } catch(e2) {
        }
      }
      
      // APPROACH 2: If still not found, try subscribing to the historyConfig to get its id
      if (!window.outdoorAirTempHistoryId && historyConfigPath) {
        try {
          const subscriber = new baja.Subscriber();
          await new Promise(function(resolve) {
            subscriber.attach('sub', function(err) {
              if (err) { resolve(); return; }
              
              const configOrd = baja.Ord.make('station:|' + historyConfigPath);
              configOrd.get({ subscriber: subscriber }).then(function(config) {
                if (config && config.get) {
                  const idVal = config.get('id');
                  if (idVal) {
                    let histId = typeof idVal === 'string' ? idVal : idVal.toString();
                    if (histId && histId.includes('/') && histId.length > 5) {
                      if (histId.includes(' ')) {
                        histId = histId.replace(/ /g, '$20');
                      }
                      window.outdoorAirTempHistoryId = histId;
                    }
                  }
                }
                subscriber.detach();
                resolve();
              }).catch(function(e) {
                subscriber.detach();
                resolve();
              });
            });
            
            // Timeout after 3 seconds
            setTimeout(function() { subscriber.detach(); resolve(); }, 3000);
          });
        } catch(e3) {
        }
      }
      
      // APPROACH 3: If still not found, try to find history by searching the history database directly
      if (!window.outdoorAirTempHistoryId) {
        try {
          // Query histories from the history service - look for OAT patterns in the ID itself
          const histOrd = baja.Ord.make('history:/');
          const historyDb = await histOrd.get();
          if (historyDb) {
            // Try to iterate through histories
            let foundOAT = false;
            
            // Check if there's a getHistories or similar method
            if (historyDb.getSlots) {
              const slots = historyDb.getSlots();
            }
            
            // Try to get children/histories
            if (historyDb.getNavChildren) {
              historyDb.getNavChildren({
                each: function(child) {
                  if (!foundOAT) {
                    const name = child.getDisplayName ? child.getDisplayName() : '';
                    const id = child.getId ? child.getId() : (child.getNavOrd ? child.getNavOrd() : '');
                    const searchName = (name + ' ' + id).toLowerCase();
                    if (searchName.includes('outdoor') || searchName.includes('oatemp') || searchName.includes('localoatemp') || searchName.includes('localoa')) {
                      const idStr = typeof id === 'string' ? id : id.toString();
                      if (idStr && idStr.length > 3) {
                        window.outdoorAirTempHistoryId = idStr;
                        foundOAT = true;
                      }
                    }
                  }
                }
              });
            }
          }
        } catch(e4) {
        }
      }
      
      // APPROACH 4: Try known history ID patterns based on station name
      if (!window.outdoorAirTempHistoryId) {
        try {
          // Common OAT history ID patterns - try each one
          const stationName = window.stationName || 'MJHOptimizer1';
          const oatPatterns = [
            '/' + stationName + '/AHU1$20LocalOATemp',
            '/' + stationName + '/AHU1$20OutdoorTemp',
            '/' + stationName + '/OutdoorTemp',
            '/' + stationName + '/LocalOATemp',
            '/' + stationName + '/OATemp',
            '/' + stationName + '/Outdoor$20Air$20Temp'
          ];
          
          for (let i = 0; i < oatPatterns.length && !window.outdoorAirTempHistoryId; i++) {
            const testId = oatPatterns[i];
            try {
              const testOrd = baja.Ord.make('history:' + testId.substring(1)); // Remove leading /
              const testHist = await testOrd.get();
              if (testHist) {
                window.outdoorAirTempHistoryId = testId;
              }
            } catch(e) {
              // This pattern didn't work, try next
            }
          }
        } catch(e5) {
        }
      }
      
      if (window.outdoorAirTempHistoryId) {
      } else {
      }
    } catch(e) {
    }
    
    return window.outdoorAirTempHistoryId;
  };
  
  // Open history chart in modal
  window.toggleInlineHistory = function(pointId, historyId, pointName) {
    // Discover outdoor air temp in background
    window.discoverOutdoorAirTemp();
    
    // Create modal if it doesn't exist
    let modal = document.getElementById('historyChartModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'historyChartModal';
      modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:10000; display:flex; align-items:center; justify-content:center;';
      modal.innerHTML = `
        <div style="background:#2d2d2d; border-radius:8px; width:90%; max-width:900px; max-height:90vh; overflow:auto; position:relative;">
          <div style="display:flex; justify-content:space-between; align-items:center; padding:15px; border-bottom:1px solid #444;">
            <h3 id="historyModalTitle" style="margin:0; color:#e0e0e0;">📈 History Chart</h3>
            <div style="display:flex; align-items:center; gap:15px;">
              <label id="oatToggleContainer" style="display:none; align-items:center; gap:6px; cursor:pointer; font-size:12px; color:#888;">
                <input type="checkbox" id="showOATToggle" style="cursor:pointer;">
                <span>🌡️ Show Outdoor Air</span>
              </label>
              <button onclick="document.getElementById('historyChartModal').style.display='none'" style="background:none; border:none; color:#888; font-size:24px; cursor:pointer;">&times;</button>
            </div>
          </div>
          <div id="historyModalContent" style="padding:20px;">
            <div style="color:#888;">Loading...</div>
          </div>
          <div id="historyModalLegend" style="display:none; padding:10px 20px 15px; border-top:1px solid #333; font-size:11px;">
            <span id="mainDataLegend" style="display:inline-flex; align-items:center; gap:5px; margin-right:20px;"><span style="background:#2196f3; width:12px; height:3px; border-radius:2px;"></span> Point Data</span>
            <span id="oatLegend" style="display:none; align-items:center; gap:5px;"><span style="background:#FF9800; width:12px; height:3px; border-radius:2px;"></span> Outdoor Air Temp</span>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
    }
    
    // Store current data for redrawing
    window.currentHistoryData = { pointName: pointName, historyId: historyId, dataPoints: null, oatData: null };
    
    modal.style.display = 'flex';
    document.getElementById('historyModalTitle').textContent = '📈 ' + pointName + ' (Last 24 Hours)';
    document.getElementById('historyModalContent').innerHTML = '<div style="color:#888; text-align:center; padding:40px;">Loading history data...</div>';
    document.getElementById('historyModalLegend').style.display = 'none';
    
    // Reset OAT toggle
    const oatToggle = document.getElementById('showOATToggle');
    if (oatToggle) {
      oatToggle.checked = false;
      oatToggle.onchange = function() {
        window.redrawHistoryChart();
      };
    }
    
    // Query history data (last 24 hours)
    const endDate = new Date();
    const startDate = new Date(endDate.getTime() - (24 * 60 * 60 * 1000));
    
    queryHistoryData(historyId, startDate, endDate).then(async function(result) {
      const dataPoints = result.data || (Array.isArray(result) ? result : []);
      const isBoolean = result.isBoolean || false;
      
      // Store for redrawing
      window.currentHistoryData.dataPoints = dataPoints;
      window.currentHistoryData.isBoolean = isBoolean;
      window.currentHistoryData.startDate = startDate;
      window.currentHistoryData.endDate = endDate;
      
      if (!dataPoints || !Array.isArray(dataPoints) || dataPoints.length === 0) {
        document.getElementById('historyModalContent').innerHTML = '<div style="color:#888; text-align:center; padding:40px;">No history data available for this point.</div>';
        return;
      }
      
      // Check for OAT availability and show toggle
      const oatId = await window.discoverOutdoorAirTemp();
      const oatContainer = document.getElementById('oatToggleContainer');
      if (oatId && oatContainer) {
        oatContainer.style.display = 'flex';
      }
      
      // Draw the chart
      window.redrawHistoryChart();
    }).catch(function(err) {
      document.getElementById('historyModalContent').innerHTML = '<div style="color:#f44336; text-align:center; padding:40px;">Error loading history: ' + (err.message || err) + '</div>';
    });
  };
  
  // Redraw history chart (supports OAT toggle)
  window.redrawHistoryChart = async function() {
    const data = window.currentHistoryData;
    if (!data || !data.dataPoints) return;
    
    const dataPoints = data.dataPoints;
    const isBoolean = data.isBoolean || false;
    const showOAT = document.getElementById('showOATToggle')?.checked || false;
    
    // Create chart HTML
    const chartHtml = `
      <canvas id="historyModalChart" style="width:100%; height:400px;"></canvas>
      <div style="margin-top:10px; font-size:11px; color:#666;">Data points: ${dataPoints.length} | Range: ${new Date(data.startDate).toLocaleString()} - ${new Date(data.endDate).toLocaleString()}</div>
    `;
    document.getElementById('historyModalContent').innerHTML = chartHtml;
    document.getElementById('historyModalLegend').style.display = 'flex';
    document.getElementById('oatLegend').style.display = showOAT ? 'inline-flex' : 'none';
    
    // Update legend with point name
    const mainLegend = document.getElementById('mainDataLegend');
    if (mainLegend) {
      mainLegend.innerHTML = '<span style="background:#2196f3; width:12px; height:3px; border-radius:2px;"></span> ' + (data.pointName || 'Point Data');
    }
    
    // Load OAT data if needed
    let oatData = null;
    if (showOAT && window.outdoorAirTempHistoryId) {
      try {
        const oatResult = await queryHistoryData(window.outdoorAirTempHistoryId, data.startDate, data.endDate);
        oatData = oatResult.data || (Array.isArray(oatResult) ? oatResult : []);
        window.currentHistoryData.oatData = oatData;
      } catch(e) {
      }
    }
    
    // Draw chart using canvas
    setTimeout(function() {
      const canvas = document.getElementById('historyModalChart');
      if (!canvas) return;
      
      // Set actual canvas dimensions
      canvas.width = canvas.offsetWidth || 800;
      canvas.height = 400;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 60;
      const rightPadding = showOAT && oatData && oatData.length > 0 ? 80 : 60;
      
      // Find min/max for main data
      let minVal = Infinity, maxVal = -Infinity, minTime = Infinity, maxTime = -Infinity;
      dataPoints.forEach(function(dp) {
        const val = isBoolean ? (dp.y ? 1 : 0) : parseFloat(dp.y);
        if (!isNaN(val)) { minVal = Math.min(minVal, val); maxVal = Math.max(maxVal, val); }
        if (dp.x) { minTime = Math.min(minTime, dp.x); maxTime = Math.max(maxTime, dp.x); }
      });
      
      // Find min/max for OAT (separate scale)
      let minOAT = Infinity, maxOAT = -Infinity;
      if (oatData && oatData.length > 0) {
        oatData.forEach(function(dp) {
          const val = parseFloat(dp.y);
          if (!isNaN(val)) { minOAT = Math.min(minOAT, val); maxOAT = Math.max(maxOAT, val); }
        });
      }
      
      if (minVal === Infinity) { ctx.fillStyle = '#888'; ctx.fillText('No valid data', width/2, height/2); return; }
      
      const valRange = maxVal - minVal || 1;
      const timeRange = maxTime - minTime || 1;
      const oatRange = maxOAT - minOAT || 1;
      
      // Background
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, width, height);
      
      // Grid lines
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = padding + (height - 2 * padding) * i / 5;
        ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(width - rightPadding, y); ctx.stroke();
        
        // Left Y-axis labels (main data)
        ctx.fillStyle = '#2196f3'; ctx.font = '10px Arial';
        ctx.fillText((maxVal - valRange * i / 5).toFixed(1), 5, y + 4);
        
        // Right Y-axis labels (OAT)
        if (showOAT && oatData && oatData.length > 0 && minOAT !== Infinity) {
          ctx.fillStyle = '#FF9800';
          ctx.fillText((maxOAT - oatRange * i / 5).toFixed(1) + '°', width - 45, y + 4);
        }
      }
      
      // Draw OAT line first (behind main line)
      if (showOAT && oatData && oatData.length > 0 && minOAT !== Infinity) {
        ctx.strokeStyle = '#FF9800';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        let first = true;
        oatData.forEach(function(dp) {
          if (dp.x >= minTime && dp.x <= maxTime) {
            const x = padding + ((dp.x - minTime) / timeRange) * (width - padding - rightPadding);
            const y = height - padding - ((parseFloat(dp.y)) - minOAT) / oatRange * (height - 2 * padding);
            if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
          }
        });
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Draw main data line
      ctx.strokeStyle = '#2196f3';
      ctx.lineWidth = 2;
      ctx.beginPath();
      let first = true;
      dataPoints.forEach(function(dp) {
        const x = padding + ((dp.x - minTime) / timeRange) * (width - padding - rightPadding);
        const y = height - padding - ((isBoolean ? (dp.y ? 1 : 0) : parseFloat(dp.y)) - minVal) / valRange * (height - 2 * padding);
        if (first) { ctx.moveTo(x, y); first = false; } else { ctx.lineTo(x, y); }
      });
      ctx.stroke();
      
      // Time labels
      ctx.fillStyle = '#666'; ctx.font = '9px Arial';
      ctx.fillText(new Date(minTime).toLocaleTimeString(), padding, height - 10);
      ctx.fillText(new Date(maxTime).toLocaleTimeString(), width - rightPadding - 50, height - 10);
      
      // Axis labels
      ctx.fillStyle = '#2196f3'; ctx.font = 'bold 10px Arial';
      ctx.save();
      ctx.translate(12, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(data.pointName || 'Value', 0, 0);
      ctx.restore();
      
      if (showOAT && oatData && oatData.length > 0) {
        ctx.fillStyle = '#FF9800';
        ctx.save();
        ctx.translate(width - 12, height / 2);
        ctx.rotate(Math.PI / 2);
        ctx.fillText('Outdoor Air °F', 0, 0);
        ctx.restore();
      }
      
      console.log('✅ [DEBUG] Chart drawn successfully' + (showOAT ? ' with OAT overlay' : ''));
    }, 100);
  };
  
  // Legacy inline chart function (fallback)
  window.toggleInlineHistoryLegacy = function(pointId, historyId, pointName) {
    const containerId = 'point_history_' + pointId;
    const container = document.getElementById(containerId);
    if (container) {
      container.style.display = container.style.display === 'none' ? 'table-row' : 'none';
    }
    // Use modal instead
    window.toggleInlineHistory(pointId, historyId, pointName);
  };
  
  
  // Collapse all expanded devices
  window.collapseAllDevices = function() {
    if (!window.expandedDevices) return;
    
    let collapsed = 0;
    Object.keys(window.expandedDevices).forEach(function(deviceId) {
      if (window.expandedDevices[deviceId]) {
        window.toggleDevicePoints(deviceId);
        collapsed++;
      }
    });
    
    if (collapsed > 0) {
    } else {
      alert('No devices are currently expanded.');
    }
  };
  
  // --- EXPANDABLE SECTIONS TOGGLE ---
  window.toggleSection = function(sectionType, sectionKey) {
    if (event) event.stopPropagation();
    const key = sectionType + '_' + sectionKey;
    const isExpanded = window.dashboardExpandedSections[key] || false;
    window.dashboardExpandedSections[key] = !isExpanded;
    
    // Save to localStorage
    try {
      localStorage.setItem('dashboard_expanded_sections', JSON.stringify(window.dashboardExpandedSections));
    } catch(e) {}
    
    // Update UI without full re-render
    const sectionId = 'section_' + sectionType + '_' + sectionKey.replace(/[^a-zA-Z0-9]/g, '_');
    const sectionDiv = document.getElementById(sectionId);
    const card = document.querySelector(`[data-section-type="${sectionType}"][data-section-key="${sectionKey}"]`);
    if (sectionDiv) {
      sectionDiv.style.maxHeight = !isExpanded ? '500px' : '0';
      sectionDiv.style.overflowY = !isExpanded ? 'auto' : 'hidden';
      sectionDiv.style.height = !isExpanded ? '' : '0';
      // Never do full re-render - just toggle visibility
    } else {
      // If section not found, do full re-render only as last resort
      setTimeout(function() {
        updateDashboard();
      }, 100);
    }
    
    if (card) {
      const icon = card.querySelector('span[style*="font-size:18px"]');
      if (icon) {
        icon.textContent = !isExpanded ? '▼' : '▶';
      } else {
        // Try alternative selector
        const altIcon = card.querySelector('span[style*="color:#888"]');
        if (altIcon && altIcon.textContent && (altIcon.textContent.includes('▼') || altIcon.textContent.includes('▶'))) {
          altIcon.textContent = !isExpanded ? '▼' : '▶';
        }
      }
    } else {
    }
  };
  
  // --- SHOW ALARMS FOR DEVICE TYPE ---
  window.showAlarmsForType = function(typeKey) {
    const global = dashboardConfig?.global || dashboardConfig || {};
    const byType = global.byType || {};
    const components = byType[typeKey] || [];
    
    // Find components with alarms
    const alarmedDevices = components.filter(function(c) {
      const status = (c.outStatus || c.status || '').toLowerCase();
      return status.includes('alarm') || c.hasAlarm;
    });
    
    if (alarmedDevices.length === 0) {
      alert('No active alarms for ' + typeKey);
      return;
    }
    
    // Create alarm investigation modal
    let modal = document.getElementById('alarmInvestigationModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'alarmInvestigationModal';
      document.body.appendChild(modal);
    }
    
    // Format type name
    let displayName = typeKey.charAt(0).toUpperCase() + typeKey.slice(1);
    if (typeKey === 'exhaustfan') displayName = 'Exhaust Fans';
    else if (typeKey === 'watersensor') displayName = 'Water Sensors';
    else if (typeKey === 'heatpump') displayName = 'Heat Pumps';
    else if (typeKey === 'boiler') displayName = 'Boilers';
    else if (typeKey === 'generator') displayName = 'Generators';
    
    let content = `
      <div style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:10001; display:flex; justify-content:center; align-items:center;">
        <div style="background:#1e1e1e; border-radius:12px; max-width:700px; width:90%; max-height:80vh; overflow:hidden; box-shadow:0 20px 60px rgba(244,67,54,0.3); border:2px solid #f44336;">
          <div style="background:linear-gradient(135deg, #f44336, #d32f2f); padding:20px; display:flex; justify-content:space-between; align-items:center;">
            <div>
              <h2 style="color:white; margin:0; font-size:20px;">🚨 Active Alarms - ${displayName}</h2>
              <div style="color:rgba(255,255,255,0.8); font-size:13px; margin-top:5px;">${alarmedDevices.length} device${alarmedDevices.length !== 1 ? 's' : ''} in alarm</div>
            </div>
            <button onclick="document.getElementById('alarmInvestigationModal').style.display='none'" style="background:rgba(255,255,255,0.2); border:none; color:white; font-size:24px; cursor:pointer; width:40px; height:40px; border-radius:50%; display:flex; align-items:center; justify-content:center;">×</button>
          </div>
          <div style="padding:20px; overflow-y:auto; max-height:calc(80vh - 100px);">
    `;
    
    alarmedDevices.forEach(function(device, idx) {
      const value = device.outValue !== undefined ? formatValue(device.outValue) : '';
      const zone = device.zone || 'Unknown Location';
      
      content += `
        <div style="background:#2d2d2d; border-radius:8px; padding:15px; margin-bottom:12px; border-left:4px solid #f44336; animation:alarm-item-pulse 2s infinite ${idx * 0.2}s;">
          <div style="display:flex; justify-content:space-between; align-items:flex-start;">
            <div style="flex:1;">
              <div style="font-weight:bold; color:#fff; font-size:15px; display:flex; align-items:center; gap:8px;">
                <span class="status-dot alarm"></span>
                ${device.name || device.originalName || 'Unknown Device'}
              </div>
              <div style="color:#888; font-size:12px; margin-top:6px;">📍 ${zone}</div>
              ${value ? `<div style="color:#4CAF50; font-size:14px; margin-top:4px;">Value: <strong>${value}</strong></div>` : ''}
            </div>
            <div style="display:flex; gap:8px;">
              <button onclick="window.openPxGraphic('${device.ord}', '${(device.name || device.originalName || '').replace(/'/g, "\\'")}')" style="background:#2196F3; color:white; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; font-size:11px; font-weight:bold;">🖼️ Open PX</button>
            </div>
          </div>
        </div>
      `;
    });
    
    content += `
          </div>
          <div style="padding:15px 20px; background:#252525; border-top:1px solid #333; display:flex; justify-content:flex-end; gap:10px;">
            <button onclick="document.getElementById('alarmInvestigationModal').style.display='none'" style="background:#555; color:white; border:none; padding:10px 20px; border-radius:6px; cursor:pointer; font-weight:bold;">Close</button>
          </div>
        </div>
      </div>
    `;
    
    // Add animation style if not already present
    if (!document.getElementById('alarmItemStyle')) {
      const style = document.createElement('style');
      style.id = 'alarmItemStyle';
      style.textContent = '@keyframes alarm-item-pulse { 0%, 100% { background:#2d2d2d; } 50% { background:#3d2020; } }';
      document.head.appendChild(style);
    }
    
    modal.innerHTML = content;
    modal.style.display = 'block';
  };

  // --- GRAPHICAL MINI-EDITOR (Phase 1) - SIMPLIFIED ---
  var currentModal = null; // Track current modal for closing
  
  function openRulesEditor() {
    if (!dashboardConfig) {
      dashboardConfig = getDefaultConfig();
    }

    // Close any existing modal
    if (currentModal) {
      currentModal.remove();
    }

    const modal = document.createElement('div');
    modal.id = 'rulesEditorModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10000; display:flex; align-items:center; justify-content:center;';
    currentModal = modal;
    
    const content = document.createElement('div');
    content.style.cssText = 'background:#2d2d2d; padding:30px; border-radius:8px; max-width:600px; max-height:80vh; overflow-y:auto; width:90%;';
    
    let html = '<h2 style="color:#4CAF50; margin-top:0;">Device Type Rules</h2>';
    html += '<p style="color:#888; font-size:12px; margin-bottom:20px;">These rules automatically detect device types. Works out of the box - no editing needed!</p>';
    
    // Add option to hide generic type
    const hideGeneric = dashboardConfig.global?.hideGenericType || false;
    html += '<div style="background:#1e1e1e; padding:15px; border-radius:4px; margin-bottom:20px;">';
    html += `<label style="color:#fff; display:flex; align-items:center; cursor:pointer;">`;
    html += `<input type="checkbox" id="hideGenericCheckbox" ${hideGeneric ? 'checked' : ''} style="margin-right:10px; width:18px; height:18px;">`;
    html += `<span>Hide "generic" type from dashboard (devices will still be categorized, just not shown in type cards)</span>`;
    html += `</label>`;
    html += '</div>';
    
    html += '<div style="max-height:400px; overflow-y:auto; margin-bottom:20px;">';
    
    const rules = dashboardConfig.global?.rules || dashboardConfig.rules || [];
    rules.forEach(function(rule, idx) {
      html += `<div style="background:#1e1e1e; padding:15px; border-radius:4px; margin-bottom:10px; display:flex; justify-content:space-between; align-items:center;">`;
      html += `<div style="flex:1;">`;
      html += `<div style="color:#fff; font-weight:bold; margin-bottom:5px;">${rule.type}</div>`;
      html += `<div style="color:#888; font-size:11px;">Matches: ${rule.pattern.replace(/\|/g, ' or ')}</div>`;
      html += `</div>`;
      html += `<button onclick="window.deleteRule(${idx})" style="background:#f44336; color:white; border:none; padding:8px 15px; border-radius:4px; cursor:pointer; margin-left:10px;">Delete</button>`;
      html += `</div>`;
    });
    
    html += '</div>';
    html += '<div style="display:flex; gap:10px; margin-bottom:20px;">';
    html += '<button id="addRuleBtn" style="background:#4CAF50; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; flex:1;">+ Add Custom Rule</button>';
    html += '</div>';
    html += '<div style="display:flex; gap:10px;">';
    html += '<button id="saveRulesBtn" style="background:#2196F3; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; flex:1;">💾 Save & Re-run Discovery</button>';
    html += '<button id="cancelRulesBtn" style="background:#666; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer;">Cancel</button>';
    html += '</div>';
    
    content.innerHTML = html;
    modal.appendChild(content);
    document.body.appendChild(modal);

    // Attach event listeners properly
    document.getElementById('cancelRulesBtn').onclick = function() {
      modal.remove();
      currentModal = null;
    };
    document.getElementById('saveRulesBtn').onclick = async function() {
      // Save hide generic setting
      const hideGenericCheckbox = document.getElementById('hideGenericCheckbox');
      if (hideGenericCheckbox) {
        if (!dashboardConfig.global) dashboardConfig.global = {};
        dashboardConfig.global.hideGenericType = hideGenericCheckbox.checked;
      }
      await saveConfig(dashboardConfig);
      modal.remove();
      currentModal = null;
      await runFullDiscovery();
    };
    document.getElementById('addRuleBtn').onclick = function() {
      const newType = prompt('Enter device type name (e.g., "chiller", "pump"):');
      if (newType) {
        const newPattern = prompt('Enter pattern to match (e.g., "chiller|chill"):');
        if (newPattern) {
          if (!dashboardConfig.global) dashboardConfig.global = {};
          if (!dashboardConfig.global.rules) dashboardConfig.global.rules = [];
          dashboardConfig.global.rules.push({ pattern: '.*' + newPattern.toLowerCase() + '.*', type: newType.toLowerCase(), icon: 'sensor.svg' });
          openRulesEditor(); // Refresh
        }
      }
    };
  }

  window.openRulesEditor = openRulesEditor;
  window.deleteRule = function(idx) {
    if (confirm('Delete this rule?')) {
      if (!dashboardConfig.global) dashboardConfig.global = {};
      const rules = dashboardConfig.global.rules || dashboardConfig.rules || [];
      rules.splice(idx, 1);
      if (dashboardConfig.global) {
        dashboardConfig.global.rules = rules;
      } else {
        dashboardConfig.rules = rules;
      }
      openRulesEditor();
    }
  };
  
  // --- DASHBOARD MANAGEMENT UI ---
  async function renderDashboardSelector() {
    try {
      const selector = document.getElementById('dashboardSelector');
      if (!selector) {
        console.log('💡 Dashboard selector not found (may not be in DOM yet)');
        return;
      }
      if (!currentUser || !currentUser.name) {
        return;
      }
      
      // Determine user role
      const isSuperUser = currentUser.isSuperUser;
      const userRole = isSuperUser ? 'super' : (currentUser.permissions && currentUser.permissions.maintenance ? 'maintenance' : 'regular');
      
      // Get visible dashboards based on permissions
      const dashboards = await getVisibleDashboards(currentUser.name, userRole);
      
      selector.innerHTML = '<option value="">-- Select Dashboard --</option>';
      
      dashboards.forEach(function(dashboard) {
        const option = document.createElement('option');
        option.value = dashboard.id;
        let displayName = dashboard.name;
        // Show owner for maintenance users
        if (userRole === 'maintenance' && dashboard.owner && dashboard.owner !== currentUser.name) {
          displayName += ' (' + dashboard.owner + ')';
        }
        option.textContent = displayName;
        if (currentUserConfig && currentUserConfig.activeDashboard === dashboard.id) {
          option.selected = true;
        }
        selector.appendChild(option);
      });
    } catch (err) {
    }
  }
  
  async function switchToDashboard(dashboardId) {
    if (!dashboardId || !currentUser.name) return;
    
    const dashboard = await loadDashboard(currentUser.name, dashboardId);
    if (!dashboard) {
      return;
    }
    
    // Load user config from file (source of truth)
    let userConfig = await loadUserConfig(currentUser.name);
    userConfig.activeDashboard = dashboardId;
    
    // Save to user-specific file (source of truth)
    await saveUserConfig(currentUser.name, userConfig);
    
    // Update in-memory config for immediate access
    if (!dashboardConfig.users) {
      dashboardConfig.users = {};
    }
    dashboardConfig.users[currentUser.name] = userConfig;
    currentUserConfig = userConfig;
    
    // Restore dashboard state
    if (dashboard.pxGraphics) {
      window.openPxGraphics = {};
      dashboard.pxGraphics.forEach(function(graphic) {
        window.openPxGraphics[graphic.id] = graphic;
      });
      loadPxGraphicsState();
    }
    
    if (dashboard.expandedSections) {
      window.dashboardExpandedSections = dashboard.expandedSections;
    }
    
    // Switch to first tab in dashboard
    if (dashboard.tabs && dashboard.tabs.length > 0) {
      window.switchTab(dashboard.tabs[0]);
    }
    
    // Update dashboard
    updateDashboard();
    await renderDashboardSelector();
  }
  
  window.switchToDashboard = switchToDashboard;
  
  async function openSaveDashboardModal() {
    if (!currentUser.name) {
      alert('User not loaded. Please refresh the page.');
      return;
    }
    
    if (currentModal) {
      currentModal.remove();
    }
    
    const modal = document.createElement('div');
    modal.id = 'saveDashboardModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10000; display:flex; align-items:center; justify-content:center;';
    currentModal = modal;
    
    const allTabs = [
      { id: 'universal', name: 'Universal Dashboard' },
      { id: 'alarmDashboard', name: 'Alarm Dashboard' },
      { id: 'history', name: 'History Chart' },
      { id: 'multi', name: 'Multi-View' },
      { id: 'buildingSearch', name: 'Building-Wide Search' }
    ];
    
    let html = '<div style="background:#2d2d2d; padding:30px; border-radius:8px; max-width:500px; width:90%;">';
    html += '<h2 style="color:#4CAF50; margin-top:0;">Save Dashboard</h2>';
    html += '<div style="margin-bottom:20px;">';
    html += '<label style="color:#fff; display:block; margin-bottom:8px;">Dashboard Name:</label>';
    html += '<input type="text" id="dashboardNameInput" placeholder="e.g., Main Operations" style="width:100%; padding:10px; background:#1e1e1e; color:#fff; border:1px solid #444; border-radius:4px; box-sizing:border-box;">';
    html += '</div>';
    html += '<div style="margin-bottom:20px;">';
    html += '<label style="color:#fff; display:block; margin-bottom:8px;">Include Tabs:</label>';
    allTabs.forEach(function(tab) {
      if (checkTabAccess(tab.id)) {
        html += `<label style="display:flex; align-items:center; margin-bottom:8px; color:#fff; cursor:pointer;">`;
        html += `<input type="checkbox" value="${tab.id}" checked style="margin-right:8px;"> ${tab.name}`;
        html += `</label>`;
      }
    });
    html += '</div>';
    html += '<div style="margin-bottom:20px;">';
    html += '<label style="display:flex; align-items:center; color:#fff; cursor:pointer;">';
    html += '<input type="checkbox" id="savePxGraphics" checked style="margin-right:8px;"> Save PX Graphics State';
    html += '</label>';
    html += '<label style="display:flex; align-items:center; color:#fff; cursor:pointer; margin-top:8px;">';
    html += '<input type="checkbox" id="saveExpandedSections" checked style="margin-right:8px;"> Save Expanded Sections';
    html += '</label>';
    html += '</div>';
    html += '<div style="display:flex; gap:10px;">';
    html += '<button id="saveDashboardBtn" style="background:#4CAF50; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; flex:1;">💾 Save</button>';
    html += '<button id="cancelSaveDashboardBtn" style="background:#666; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer;">Cancel</button>';
    html += '</div>';
    html += '</div>';
    
    modal.innerHTML = html;
    document.body.appendChild(modal);
    
    document.getElementById('cancelSaveDashboardBtn').onclick = function() {
      modal.remove();
      currentModal = null;
    };
    
    document.getElementById('saveDashboardBtn').onclick = async function() {
      const name = document.getElementById('dashboardNameInput').value.trim();
      if (!name) {
        alert('Please enter a dashboard name');
        return;
      }
      
      const selectedTabs = Array.from(document.querySelectorAll('#saveDashboardModal input[type="checkbox"]:checked'))
        .map(cb => cb.value)
        .filter(v => v);
      
      if (selectedTabs.length === 0) {
        alert('Please select at least one tab');
        return;
      }
      
      const dashboardData = {
        id: 'dashboard_' + Date.now(),
        name: name,
        tabs: selectedTabs,
        pxGraphics: document.getElementById('savePxGraphics').checked ? Object.values(window.openPxGraphics || {}) : [],
        expandedSections: document.getElementById('saveExpandedSections').checked ? (window.dashboardExpandedSections || {}) : {},
        customCards: window.USE_FILE_PERSISTENCE ? (window.customCards || []) : undefined, // Include custom cards if using file persistence
        timestamp: new Date().toISOString()
      };
      
      await saveDashboard(currentUser.name, dashboardData);
      
      // Also save custom cards state separately if using file persistence
      if (window.USE_FILE_PERSISTENCE) {
        window.saveCustomCards();
      }
      
      modal.remove();
      currentModal = null;
      await renderDashboardSelector();
      alert('Dashboard saved successfully!');
    };
  }
  
  window.openSaveDashboardModal = openSaveDashboardModal;
  
  // --- FLOATING ACTION BUTTON (FAB) ---
  function initFAB() {
    updateFABMenu();
  }
  
  window.clearHistoryChart = function() {
    if (window.clearAllHistoryPoints) {
      window.clearAllHistoryPoints();
      window.toggleFABMenu();
    }
  };
  
  window.toggleFABMenu = function() {
    const menu = document.getElementById('fabMenu');
    const mainBtn = document.getElementById('fabMain');
    if (menu && mainBtn) {
      const isOpen = menu.classList.contains('show');
      if (isOpen) {
        menu.classList.remove('show');
        mainBtn.classList.remove('active');
      } else {
        menu.classList.add('show');
        mainBtn.classList.add('active');
      }
    }
  };
  
  window.updateFABMenu = function() {
    const menu = document.getElementById('fabMenu');
    if (!menu) return;
    
    const currentTab = window.currentTab || 'universal';
    let html = '';
    
    // Undo/Redo buttons (always visible)
    const undoCount = window.DashboardState ? window.DashboardState.undoHistory.length : 0;
    const redoCount = window.DashboardState ? window.DashboardState.redoHistory.length : 0;
    
    html += '<button class="fab-action" id="undoBtn" onclick="window.undo()" ' + (undoCount === 0 ? 'disabled' : '') + '>';
    html += '<span class="fab-action-icon">↶</span>';
    html += '<span>Undo' + (undoCount > 0 ? ' (' + undoCount + ')' : '') + '</span>';
    html += '</button>';
    
    html += '<button class="fab-action" id="redoBtn" onclick="window.redo()" ' + (redoCount === 0 ? 'disabled' : '') + '>';
    html += '<span class="fab-action-icon">↷</span>';
    html += '<span>Redo' + (redoCount > 0 ? ' (' + redoCount + ')' : '') + '</span>';
    html += '</button>';
    
    html += '<div style="border-top:1px solid #444; margin:8px 0;"></div>';
    
    if (currentTab === 'universal') {
      // Universal Dashboard actions
      html += '<button class="fab-action" onclick="window.collapseAllCards()">';
      html += '<span class="fab-action-icon">🔽</span>';
      html += '<span>Collapse All</span>';
      html += '</button>';
      
      html += '<button class="fab-action" onclick="window.createNewCustomCard()">';
      html += '<span class="fab-action-icon">➕</span>';
      html += '<span>New Custom Card</span>';
      html += '</button>';
      
      // Hidden cards count
      const hiddenCardsCount = Object.keys(window.hiddenCards || {}).filter(k => window.hiddenCards[k]).length;
      const customHiddenCount = (window.customCards || []).filter(c => c.hidden).length;
      const totalHidden = hiddenCardsCount + customHiddenCount;
      
      html += '<button class="fab-action" onclick="window.showCardManager()">';
      html += '<span class="fab-action-icon">👁️</span>';
      html += '<span>Show/Hide Cards' + (totalHidden > 0 ? ' (' + totalHidden + ' hidden)' : '') + '</span>';
      html += '</button>';
      
      html += '<button class="fab-action" onclick="window.showHiddenPoints()">';
      html += '<span class="fab-action-icon">👁️</span>';
      html += '<span>Show Hidden Points</span>';
      html += '</button>';
      
      html += '<button class="fab-action" onclick="window.openSaveDashboardModal()">';
      html += '<span class="fab-action-icon">💾</span>';
      html += '<span>Save Dashboard</span>';
      html += '</button>';
      
      html += '<div style="border-top:1px solid #444; margin:8px 0;"></div>';
      
      html += '<button class="fab-action" style="background:#3a2a2a; border-color:#f44336;" onclick="window.DashboardState.resetAll()">';
      html += '<span class="fab-action-icon">🔄</span>';
      html += '<span>Reset Customizations</span>';
      html += '</button>';
    } else if (currentTab === 'history') {
      // History Chart actions
      html += '<button class="fab-action" onclick="window.clearHistoryChart()">';
      html += '<span class="fab-action-icon">🗑️</span>';
      html += '<span>Clear Chart</span>';
      html += '</button>';
    } else if (currentTab === 'multi') {
      // Multi-View actions
      html += '<button class="fab-action" onclick="window.showHiddenPoints()">';
      html += '<span class="fab-action-icon">👁️</span>';
      html += '<span>Show Hidden Points</span>';
      html += '</button>';
    }
    
    // Always show hidden points option if there are any
    if (!window.hiddenPoints) {
      window.hiddenPoints = {};
      try {
        const saved = localStorage.getItem('dashboard_hidden_points');
        if (saved) {
          window.hiddenPoints = JSON.parse(saved);
        }
      } catch(e) {}
    }
    
    const hiddenCount = Object.keys(window.hiddenPoints).length;
    if (hiddenCount > 0 && !html.includes('Show Hidden Points')) {
      html += '<button class="fab-action" onclick="window.showHiddenPoints()">';
      html += '<span class="fab-action-icon">👁️</span>';
      html += '<span>Show Hidden Points (' + hiddenCount + ')</span>';
      html += '</button>';
    }
    
    menu.innerHTML = html || '<div style="padding:20px; color:#888; text-align:center;">No actions available</div>';
  }
  
  // Sort card list by column
  window.sortCardList = function(cardKey, column) {
    if (!window.cardSortState) window.cardSortState = {};
    if (!window.cardSortState[cardKey]) window.cardSortState[cardKey] = { column: 'name', direction: 'asc' };
    
    const sortState = window.cardSortState[cardKey];
    if (sortState.column === column) {
      // Toggle direction
      sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
    } else {
      // New column, default to ascending
      sortState.column = column;
      sortState.direction = 'asc';
    }
    
    // Re-render dashboard to apply new sort
    updateDashboard();
    window.showToast('Sorted by ' + column + ' (' + sortState.direction + ')', 'info');
  };
  
  window.collapseAllCards = function() {
    // Collapse all device type cards
    if (window.dashboardExpandedSections) {
      Object.keys(window.dashboardExpandedSections).forEach(function(key) {
        window.dashboardExpandedSections[key] = false;
      });
      try {
        localStorage.setItem('dashboard_expanded_sections', JSON.stringify(window.dashboardExpandedSections));
      } catch(e) {}
    }
    
    // Collapse all devices
    window.collapseAllDevices();
    
    // Collapse all zones
    if (window.dashboardExpandedSections) {
      Object.keys(window.dashboardExpandedSections).forEach(function(key) {
        if (key.startsWith('zone_')) {
          window.dashboardExpandedSections[key] = false;
        }
      });
      try {
        localStorage.setItem('dashboard_expanded_sections', JSON.stringify(window.dashboardExpandedSections));
      } catch(e) {}
    }
    
    // Refresh dashboard
    if (window.currentTab === 'universal') {
      updateDashboard();
    }
    
    // Close FAB menu
    window.toggleFABMenu();
  };
  
  window.showHiddenPoints = function() {
    const panel = document.getElementById('hiddenPointsPanel');
    const list = document.getElementById('hiddenPointsList');
    if (!panel || !list) return;
    
    // Load hidden points
    if (!window.hiddenPoints) {
      window.hiddenPoints = {};
      try {
        const saved = localStorage.getItem('dashboard_hidden_points');
        if (saved) {
          window.hiddenPoints = JSON.parse(saved);
        }
      } catch(e) {}
    }
    
    const hiddenKeys = Object.keys(window.hiddenPoints);
    
    if (hiddenKeys.length === 0) {
      list.innerHTML = '<div class="hidden-points-empty">No points are currently hidden</div>';
    } else {
      let html = '';
      hiddenKeys.sort().forEach(function(key) {
        html += '<div class="hidden-point-item">';
        html += '<span class="hidden-point-name">' + key + '</span>';
        html += '<button class="unhide-btn" onclick="window.unhidePoint(\'' + key.replace(/'/g, "\\'") + '\')">Unhide</button>';
        html += '</div>';
      });
      list.innerHTML = html;
    }
    
    panel.classList.add('show');
    // Close FAB menu
    window.toggleFABMenu();
  };
  
  window.closeHiddenPointsPanel = function() {
    const panel = document.getElementById('hiddenPointsPanel');
    if (panel) {
      panel.classList.remove('show');
    }
  };
  
  window.unhidePoint = function(pointKey) {
    if (!pointKey) return;
    const key = pointKey.toLowerCase();
    
    if (window.hiddenPoints && window.hiddenPoints[key]) {
      delete window.hiddenPoints[key];
      
      // Save to localStorage
      try {
        localStorage.setItem('dashboard_hidden_points', JSON.stringify(window.hiddenPoints));
      } catch(e) {
      }
      
      // Refresh all expanded device views
      if (window.expandedDevices) {
        Object.keys(window.expandedDevices).forEach(function(deviceId) {
          if (window.expandedDevices[deviceId]) {
            window.toggleDevicePoints(deviceId);
            setTimeout(function() {
              window.toggleDevicePoints(deviceId);
            }, 100);
          }
        });
      }
      
      // Update dashboard
      if (window.currentTab === 'universal') {
        updateDashboard();
      }
      
      // Update hidden points panel
      window.showHiddenPoints();
    }
  };
  
  // Close hidden points panel when clicking outside
  document.addEventListener('click', function(e) {
    const panel = document.getElementById('hiddenPointsPanel');
    const fabContainer = document.getElementById('fabContainer');
    if (panel && panel.classList.contains('show') && fabContainer) {
      if (!fabContainer.contains(e.target) && !panel.contains(e.target)) {
        window.closeHiddenPointsPanel();
      }
    }
  });
  
  // --- DRAG AND DROP FUNCTIONS ---
  window.renderCustomCard = function(card, index) {
    const positionStyle = card.position ? `left:${card.position.x}px; top:${card.position.y}px;` : '';
    const sizeStyle = card.size ? `width:${card.size.width}px; height:${card.size.height}px;` : '';
    const positionableClass = card.positionable ? 'positionable' : '';
    const hiddenClass = card.hidden ? 'hidden' : '';
    
    let html = '<div class="custom-card resizable ' + positionableClass + ' ' + hiddenClass + '" data-card-index="' + index + '" style="' + positionStyle + sizeStyle + '" ';
    html += 'ondragover="event.preventDefault(); window.handleCardDragOver(event, ' + index + ')" ';
    html += 'ondrop="window.handleCardContentDrop(event, ' + index + ')" ';
    html += 'ondragleave="window.handleCardDragLeave(event, ' + index + ')" ';
    html += 'draggable="true" ondragstart="window.handleCustomCardDragStart(event, ' + index + ')" ';
    html += 'ondragend="window.handleCustomCardDragEnd(event)">';
    
    // Resize handles
    html += '<div class="resize-handle right" onmousedown="window.startResize(event, ' + index + ', \'right\')"></div>';
    html += '<div class="resize-handle bottom" onmousedown="window.startResize(event, ' + index + ', \'bottom\')"></div>';
    html += '<div class="resize-handle corner" onmousedown="window.startResize(event, ' + index + ', \'corner\')"></div>';
    
    html += '<div class="custom-card-header">';
    html += '<span class="card-drag-handle" title="Drag to move card" style="cursor:grab;">⋮⋮</span>';
    html += '<div class="custom-card-title">';
    if (card.editing) {
      html += '<input type="text" value="' + (card.title || 'Untitled Card') + '" onblur="window.saveCustomCardTitle(' + index + ', this.value)" onkeypress="if(event.key===\'Enter\'){this.blur()}">';
    } else {
      html += '<span ondblclick="window.editCustomCardTitle(' + index + ')">' + (card.title || 'Untitled Card') + '</span>';
    }
    html += '</div>';
    html += '<div class="custom-card-actions">';
    html += '<button onclick="event.stopPropagation(); window.addBlankHistoryChart(' + index + ')" style="background:#9C27B0; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer; font-size:11px; margin-right:5px;" title="Add history chart">📊</button>';
    html += '<button onclick="event.stopPropagation(); window.addHeadingToCard(' + index + ')" style="background:#607D8B; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer; font-size:11px; margin-right:5px;" title="Add heading">📝</button>';
    html += '<button onclick="event.stopPropagation(); window.toggleCustomCardHidden(' + index + ')" style="background:#FF9800; color:white; border:none; padding:4px 8px; border-radius:3px; cursor:pointer; font-size:11px; margin-right:5px;" title="Hide this card">👁️</button>';
    html += '<button class="custom-card-delete" onclick="event.stopPropagation(); window.deleteCustomCard(' + index + ')">🗑️</button>';
    html += '</div>';
    html += '</div>';
    html += '<div class="custom-card-content points-container" data-container-type="custom" data-container-id="' + index + '" ondragover="window.handlePointContainerDragOver(event)" ondrop="window.handlePointContainerDrop(event)" ondragleave="window.handlePointContainerDragLeave(event)">';
    
    // Render card sections
    if (card.sections && card.sections.length > 0) {
      card.sections.forEach(function(section, sectionIndex) {
        if (section.type === 'heading') {
          html += '<div class="card-section-heading" draggable="true" ondragstart="window.handleSectionDragStart(event, ' + index + ', ' + sectionIndex + ')" ondragend="window.handleSectionDragEnd(event)">';
          html += '<span class="drag-handle">⋮⋮</span>' + (section.text || 'Section');
          html += '<button onclick="window.removeSectionFromCard(' + index + ', ' + sectionIndex + ')" style="background:#f44336; color:white; border:none; padding:2px 6px; border-radius:3px; cursor:pointer; font-size:10px; float:right;">×</button>';
          html += '</div>';
        } else if (section.type === 'point') {
          const pointDataStr = encodeURIComponent(JSON.stringify(section.data));
          html += '<div class="draggable-point" draggable="true" ';
          html += 'data-container-type="custom" data-container-id="' + index + '" data-point-index="' + sectionIndex + '" data-point-data="' + pointDataStr + '" ';
          html += 'ondragstart="window.handlePointDragStart(event, \'' + pointDataStr.replace(/'/g, "\\'") + '\')" ';
          html += 'ondragend="window.handlePointDragEnd(event)" ';
          html += 'ondragover="window.handlePointDragOver(event)" ';
          html += 'ondrop="window.handlePointDrop(event)" ';
          html += 'ondblclick="window.showPointHelper(event, ' + JSON.stringify(section.data).replace(/"/g, '&quot;') + ')">';
          html += '<span class="drag-handle">⋮⋮</span>';
          html += '<span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">' + (section.data.name || 'Unknown') + '</span>';
          html += '<button onclick="event.stopPropagation(); window.removePointFromCard(' + index + ', ' + sectionIndex + ')" style="background:#f44336; color:white; border:none; padding:2px 6px; border-radius:3px; cursor:pointer; font-size:10px; margin-left:auto;">×</button>';
          html += '</div>';
        } else if (section.type === 'history') {
          html += '<div class="history-chart-in-card" id="card-history-' + index + '-' + sectionIndex + '" ';
          html += 'ondragover="event.preventDefault(); this.classList.add(\'drag-over\')" ';
          html += 'ondrop="window.handleHistoryChartDrop(event, ' + index + ', ' + sectionIndex + ')" ';
          html += 'ondragleave="this.classList.remove(\'drag-over\')">';
          html += '<div style="color:#888; font-size:12px; margin-bottom:5px;">History Chart - Drop points here</div>';
          if (section.histories && section.histories.length > 0) {
            html += '<div id="card-history-canvas-' + index + '-' + sectionIndex + '" style="min-height:150px;"></div>';
            html += '<div style="font-size:10px; color:#666; margin-top:5px;">' + section.histories.length + ' point(s) loaded</div>';
          } else {
            html += '<div style="color:#666; font-size:11px; padding:20px; text-align:center;">No histories yet. Drag points here to add.</div>';
          }
          html += '<button onclick="window.removeHistoryFromCard(' + index + ', ' + sectionIndex + ')" style="background:#f44336; color:white; border:none; padding:2px 6px; border-radius:3px; cursor:pointer; font-size:10px; margin-top:5px;">Remove</button>';
          html += '</div>';
        }
      });
    } else {
      html += '<div class="drop-zone" style="min-height:50px;">Drop points or history charts here</div>';
    }
    
    html += '</div>';
    html += '</div>';
    return html;
  };
  
  window.handleCardDragStart = function(event, cardId) {
    event.dataTransfer.setData('text/plain', JSON.stringify({ type: 'card', id: cardId }));
    event.dataTransfer.effectAllowed = 'move';
    event.currentTarget.classList.add('dragging');
  };
  
  window.handleCardDragEnd = function(event) {
    event.currentTarget.classList.remove('dragging');
    document.querySelectorAll('.device-type-card, .zone-card').forEach(function(card) {
      card.classList.remove('drag-over');
    });
    // Clear dragState
    if (window.dragState && window.dragState.type === 'card') {
      window.dragState = { item: null, type: null, cardId: null };
    }
  };
  
  window.handleCardDragOver = function(event) {
    // Check if this is a card drag by checking dragState
    let isCardDrag = false;
    if (window.dragState && window.dragState.type === 'card') {
      isCardDrag = true;
    } else if (event.dataTransfer.types.includes('text/plain')) {
      // Can't read getData during dragover, but we can check types
      // Assume it's a card drag if we have text/plain and the current target is a card
      const targetCard = event.currentTarget;
      if (targetCard.dataset.cardType && targetCard.dataset.cardId) {
        isCardDrag = true;
      }
    }
    
    if (isCardDrag) {
      event.preventDefault();
      event.currentTarget.classList.add('drag-over');
    }
  };
  
  window.handleCardDrop = function(event) {
    event.preventDefault();
    event.stopPropagation();
    
    try {
      // Try to get data from dragState first, then dataTransfer
      let sourceCardId = null;
      if (window.dragState && window.dragState.type === 'card') {
        sourceCardId = window.dragState.cardId;
      } else {
        const data = JSON.parse(event.dataTransfer.getData('text/plain'));
        if (data.type === 'card') {
          sourceCardId = data.id;
        }
      }
      
      if (sourceCardId) {
        const targetCard = event.currentTarget;
        const targetCardId = targetCard.dataset.cardId;
        const targetCardType = targetCard.dataset.cardType;
        
        // Only reorder if same card type
        if (sourceCardId && targetCardId && sourceCardId.startsWith(targetCardType + '_')) {
          // Get card order from state
          if (!window.DashboardState.cardOrder) {
            window.DashboardState.cardOrder = { types: [], zones: [] };
          }
          
          const orderKey = targetCardType === 'type' ? 'types' : 'zones';
          // Reorder based on current visible DOM order (by rows): sort by top then left
          const domCards = Array.from(document.querySelectorAll(`[data-card-type="${targetCardType}"]`));
          const visual = domCards.map(c => ({
            id: c.dataset.cardId,
            top: c.getBoundingClientRect().top,
            left: c.getBoundingClientRect().left
          })).sort((a, b) => a.top === b.top ? a.left - b.left : a.top - b.top);
          let order = visual.map(v => v.id); // align order with current DOM
          
            // Build a map for fast lookups
            const idToIndex = {};
            order.forEach((id, idx) => { idToIndex[id] = idx; });
            const sourceIdx = idToIndex[sourceCardId] ?? -1;
            const targetIdx = idToIndex[targetCardId] ?? -1;
            
          if (sourceIdx >= 0 && targetIdx >= 0 && sourceIdx !== targetIdx) {
              const before = order.slice();
              order.splice(sourceIdx, 1);
              let insertIdx = targetIdx;
              if (sourceIdx < targetIdx) insertIdx = targetIdx - 1; // adjust when moving down
              if (insertIdx < 0) insertIdx = 0;
              if (insertIdx > order.length) insertIdx = order.length;
              order.splice(insertIdx, 0, sourceCardId);
              window.DashboardState.cardOrder[orderKey] = order;
              window.DashboardState.save('cardOrder');
              updateDashboard();
              if (window.showToast) window.showToast('Cards reordered', 'success');
            console.log('✅ Cards reordered:', JSON.stringify({
              orderKey,
              before,
              after: order,
              sourceCardId,
              targetCardId,
              sourceIdx,
              targetIdx,
              insertIdx,
              visualIds: order
            }));
            } else {
            }
        }
      }
    } catch(e) {
    }
    
    event.currentTarget.classList.remove('drag-over');
    // Clear dragState
    if (window.dragState && window.dragState.type === 'card') {
      window.dragState = { item: null, type: null, cardId: null };
    }
  };
  
  function parsePointDataSafe(raw) {
    if (!raw) return null;
    try {
      if (typeof raw !== 'string') return raw;
      let str = raw;
      // If URI-encoded, decode first
      if (str.startsWith('%7B') || str.startsWith('%7b') || str.includes('%22')) {
        str = decodeURIComponent(str);
      }
      // Replace HTML entities
      str = str.replace(/&quot;/g, '"').replace(/&#39;/g, "'");
      return JSON.parse(str);
    } catch(e) {
      try {
        return JSON.parse(raw);
      } catch(inner) {
        return null;
      }
    }
  }

  window.handlePointDragStart = function(event, pointDataStr) {
    try {
      const point = event.currentTarget;
      let pointData = parsePointDataSafe(pointDataStr);
      if (!pointData) {
        pointData = parsePointDataSafe(point.dataset.pointData);
      }
      if (!pointData) {
        return;
      }
      
      // Get source container info
      const sourceContainer = point.dataset.containerType || null;
      const sourceContainerId = point.dataset.containerId || null;
      let sourceIndex = point.dataset.pointIndex || null;
      
      // Handle custom_ prefix for custom points (keep as string)
      if (sourceIndex && typeof sourceIndex === 'string' && sourceIndex.startsWith('custom_')) {
        // Keep as string for custom points
      } else if (sourceIndex !== null && sourceIndex !== undefined) {
        sourceIndex = parseInt(sourceIndex);
      }
      
      // Set dragState for improved drop handling
      window.dragState = {
        item: point,
        type: 'point',
        data: pointData,
        sourceContainer: sourceContainer,
        sourceContainerId: sourceContainerId,
        sourceIndex: sourceIndex
      };
      event.dataTransfer.setData('text/plain', JSON.stringify({ type: 'point', dragType: 'point', data: pointData }));
      event.dataTransfer.effectAllowed = 'move';
      event.dataTransfer.dropEffect = 'move';
      event.currentTarget.classList.add('dragging');
    } catch(e) {
    }
  };
  
  window.handlePointDragEnd = function(event) {
    event.currentTarget.classList.remove('dragging');
    document.querySelectorAll('.drop-zone, .custom-card, .create-card-zone, .points-container').forEach(function(zone) {
      zone.classList.remove('drag-over');
    });
    // Clear dragState
    if (window.dragState) {
      window.dragState = { item: null, type: null, data: null, sourceContainer: null, sourceIndex: null };
    }
  };
  
  // Improved container drag handlers with fallback dataTransfer reading
  window.handlePointContainerDragOver = function(event) {
    // Allow drops if we have a point in dragState
    // If dragState doesn't exist yet, still allow (might be from helper modal)
    if (window.dragState && window.dragState.type !== 'point') {
      // Check if it's a card drag instead
      if (window.dragState.type === 'card') {
        return; // Don't allow card drags on point containers
      }
      return; // Not a point drag
    }
    
    // Allow the dragover (either point drag or dragState not set yet)
    event.preventDefault();
    event.stopPropagation();
    if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
    
    // Add visual feedback
    event.currentTarget.classList.add('drag-over');
  };
  
  window.handlePointContainerDragLeave = function(event) {
    // Only clear if we're actually leaving the container (not just moving to a child)
    const container = event.currentTarget;
    const relatedTarget = event.relatedTarget;
    
    // Check if we're moving to a child element
    if (relatedTarget && container.contains(relatedTarget)) {
      return; // Still inside container, don't clear
    }
    
    // Actually leaving the container
    container.classList.remove('drag-over');
  };
  
  window.handlePointContainerDrop = function(event) {
    event.preventDefault();
    event.stopPropagation();
    
    // Try to get data from dragState or dataTransfer
    let pointData = null;
    let sourceContainer = null;
    let sourceContainerId = null;
    let sourceIndex = null;
    let wasFromHelper = false;
    
    if (window.dragState && window.dragState.type === 'point') {
      pointData = window.dragState.data;
      sourceContainer = window.dragState.sourceContainer;
      sourceContainerId = window.dragState.sourceContainerId;
      sourceIndex = window.dragState.sourceIndex;
      wasFromHelper = sourceContainer === 'helper';
    } else {
      // Fallback: read from dataTransfer
      try {
        const transferData = JSON.parse(event.dataTransfer.getData('text/plain'));
        if ((transferData.type === 'point' || transferData.dragType === 'point') && transferData.data) {
          pointData = transferData.data;
          sourceContainer = 'helper'; // Assume helper if we're reading from dataTransfer
          sourceContainerId = null;
          sourceIndex = null;
          wasFromHelper = true;
        }
      } catch(e) {
        return;
      }
    }
    
    if (!pointData) return;
    
    const container = event.currentTarget;
    const targetContainerType = container.dataset.containerType;
    const targetContainerId = container.dataset.containerId;
    
    // Calculate target index (append to end)
    let targetIndex = 0;
    if (targetContainerType === 'custom' && targetContainerId !== undefined) {
      const cardIndex = parseInt(targetContainerId);
      if (window.customCards && window.customCards[cardIndex] && window.customCards[cardIndex].sections) {
        targetIndex = window.customCards[cardIndex].sections.length;
      }
    }
    
    // Use movePoint function to handle the move
    window.movePoint(
      sourceContainer,
      sourceContainerId,
      sourceIndex,
      targetContainerType,
      targetContainerId,
      targetIndex,
      pointData
    );
    
    // Clear drag state
    window.dragState = { item: null, type: null, data: null, sourceContainer: null, sourceIndex: null };
    
    // Remove dragging-active class and close helper modal if item was dragged from it
    if (wasFromHelper) {
      const modal = document.querySelector('.point-helper-modal');
      if (modal) {
        modal.classList.remove('dragging-active');
        setTimeout(function() {
          const closeBtn = modal.querySelector('.point-helper-close');
          if (closeBtn) closeBtn.click();
        }, 100);
      }
    }
  };
  
  // Helper modal drag handlers
  window.handleHelperItemDragStart = function(event) {
    event.stopPropagation(); // Prevent closing modal
    const item = event.currentTarget;
    let pointData = null;
    
    try {
      // Try to get point data from data attribute
      if (item.dataset.pointData) {
        pointData = JSON.parse(decodeURIComponent(item.dataset.pointData));
      } else {
        // Fallback: try to parse from innerHTML or other attributes
        return;
      }
    } catch(e) {
      return;
    }
    
    window.dragState = {
      item: item,
      type: 'point',
      data: pointData,
      sourceContainer: 'helper',
      sourceContainerId: null,
      sourceIndex: null
    };
    
    event.dataTransfer.effectAllowed = 'move';
    event.dataTransfer.setData('text/plain', JSON.stringify({ type: 'point', dragType: 'point', data: pointData }));
    
    // Make modal backdrop allow pointer events through during drag
    const modal = document.querySelector('.point-helper-modal');
    if (modal) {
      modal.classList.add('dragging-active');
    }
    
    setTimeout(function() {
      item.classList.add('dragging');
    }, 0);
  };
  
  window.handleHelperItemDragEnd = function(event) {
    event.stopPropagation(); // Prevent closing modal
    event.currentTarget.classList.remove('dragging');
    
    // Remove dragging-active class from modal
    const modal = document.querySelector('.point-helper-modal');
    if (modal) {
      modal.classList.remove('dragging-active');
    }
    
    // Only close modal if drop was NOT successful (no drop happened)
    // Successful drops will close the modal themselves
    setTimeout(function() {
      // Check if dragState still exists and is from helper (means drop didn't happen)
      if (window.dragState && window.dragState.sourceContainer === 'helper') {
        const modal = document.querySelector('.point-helper-modal');
        if (modal) modal.remove();
        // Clear drag state
        window.dragState = { item: null, type: null, data: null, sourceContainer: null, sourceIndex: null };
      }
    }, 300);
  };
  
  // Point helper modal functions
  window.showPointHelper = function(event, pointData) {
    event.stopPropagation();
    event.preventDefault();
    
    // Fallback to dataset if not provided
    if (!pointData && event && event.currentTarget && event.currentTarget.dataset) {
      pointData = parsePointDataSafe(event.currentTarget.dataset.pointData);
    }
    
    if (!pointData) {
      return;
    }
    
    // Parse pointData if it's a string (from HTML attribute)
    if (typeof pointData === 'string') {
      try {
        pointData = parsePointDataSafe(pointData);
      } catch(e) {
        return;
      }
      if (!pointData) {
        console.error('showPointHelper: Failed to parse pointData (empty after parse)');
        return;
      }
    }
    
    // Get device ORD to find similar points
    const deviceOrd = pointData.ord || pointData.deviceOrd || '';
    const pointName = pointData.name || pointData.originalName || 'Unknown';
    
    // Get snapshot from global config
    const global = window.dashboardConfig?.global || window.dashboardConfig || {};
    const snapshot = global.snapshot || window.foundEquipment || [];
    
    // Find similar points from snapshot (same device)
    const similarPoints = [];
    const allDevices = [];
    const seenDevices = {};
    
    snapshot.forEach(function(comp) {
      const compOrd = comp.ord || '';
      const compDeviceOrd = comp.deviceOrd || '';
      const compName = comp.name || comp.originalName || 'Unknown';
      
      // Find points from same device (sharing similar ORD path)
      const devicePath = deviceOrd.split('/').slice(0, -1).join('/');
      const compPath = compOrd.split('/').slice(0, -1).join('/');
      
      if (devicePath && compPath === devicePath && comp.ord !== pointData.ord) {
        similarPoints.push({
          name: compName,
          ord: comp.ord,
          value: comp.outValue,
          status: comp.outStatus || comp.status || 'ok',
          type: comp.inferredType || 'generic',
          deviceOrd: compDeviceOrd
        });
      }
      
      // Collect unique devices (different parent path)
      if (compPath && compPath !== devicePath && !seenDevices[compPath]) {
        seenDevices[compPath] = true;
        allDevices.push({
          name: compName,
          ord: comp.ord,
          value: comp.outValue,
          status: comp.outStatus || comp.status || 'ok',
          type: comp.inferredType || 'generic',
          deviceOrd: compDeviceOrd
        });
      }
    });
    
    // Limit similar points and devices
    const limitedSimilar = similarPoints.slice(0, 10);
    const limitedDevices = allDevices.slice(0, 10);
    
    let html = '<div class="point-helper-modal" onclick="if(event.target===this)window.closePointHelper()" ondragstart="event.stopPropagation()" ondrag="event.stopPropagation()" ondragend="event.stopPropagation()">';
    html += '<div class="point-helper-content" onclick="event.stopPropagation()" ondragstart="event.stopPropagation()" ondrag="event.stopPropagation()" ondragend="event.stopPropagation()" ondragover="event.stopPropagation()" ondrop="event.stopPropagation()">';
    html += '<div class="point-helper-header">';
    html += '<div class="point-helper-title">🔍 ' + pointName + '</div>';
    html += '<button class="point-helper-close" onclick="window.closePointHelper()">✕ Close</button>';
    html += '</div>';
    
    // Similar points section
    if (limitedSimilar.length > 0) {
      html += '<div class="point-helper-section">';
      html += '<div class="point-helper-section-title">🔗 Similar Points (Same Device)</div>';
      limitedSimilar.forEach(function(similar) {
        const similarDataAttr = encodeURIComponent(JSON.stringify(similar));
        html += '<div class="point-helper-item" draggable="true" data-point-data="' + similarDataAttr + '" ondragstart="window.handleHelperItemDragStart(event)" ondragend="window.handleHelperItemDragEnd(event)" onclick="event.stopPropagation()">';
        html += '<div>' + similar.name;
        if (similar.value !== undefined && similar.value !== null) {
          html += ' <span style="color:#888;">(' + similar.value + ')</span>';
        }
        html += '</div>';
        html += '<span class="status-dot ' + (similar.status || 'ok') + '"></span>';
        html += '</div>';
      });
      html += '</div>';
    }
    
    // Other devices section
    if (limitedDevices.length > 0) {
      html += '<div class="point-helper-section">';
      html += '<div class="point-helper-section-title">🏢 Other Devices (Drag to add to cards)</div>';
      limitedDevices.forEach(function(device) {
        const deviceDataAttr = encodeURIComponent(JSON.stringify(device));
        html += '<div class="point-helper-item" draggable="true" data-point-data="' + deviceDataAttr + '" ondragstart="window.handleHelperItemDragStart(event)" ondragend="window.handleHelperItemDragEnd(event)" onclick="event.stopPropagation()">';
        html += '<div>' + device.name;
        if (device.value !== undefined && device.value !== null) {
          html += ' <span style="color:#888;">(' + device.value + ')</span>';
        }
        html += '</div>';
        html += '<span class="status-dot ' + (device.status || 'ok') + '"></span>';
        html += '</div>';
      });
      html += '</div>';
    }
    
    html += '</div></div>';
    document.body.insertAdjacentHTML('beforeend', html);
  };
  
  window.closePointHelper = function() {
    const modal = document.querySelector('.point-helper-modal');
    if (modal) modal.remove();
  };
  
  // Central function for moving points between containers
  window.movePoint = function(srcType, srcId, srcIdx, destType, destId, destIdx, pointData) {
    // Save state for undo before making changes
    window.saveStateForUndo();
    
    // Track point assignment for persistence
    // Normalize ORD - remove duplicate "slot:" prefixes
    let pointOrd = pointData.ord || pointData.slotPath || '';
    if (pointOrd && pointOrd.includes('slot:slot:')) {
      pointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
    }
    
    // Handle same-card reordering first (before any removal)
    // Custom cards
    if (srcType === 'custom' && destType === 'custom' && srcId === destId && srcIdx !== null && destIdx !== null) {
      const srcCardIndex = parseInt(srcId);
      if (window.customCards && window.customCards[srcCardIndex] && window.customCards[srcCardIndex].sections) {
        const section = window.customCards[srcCardIndex].sections[srcIdx];
        window.customCards[srcCardIndex].sections.splice(srcIdx, 1);
        // Adjust target index if source was before target
        let adjustedDestIdx = parseInt(destIdx);
        if (srcIdx < adjustedDestIdx) adjustedDestIdx--;
        window.customCards[srcCardIndex].sections.splice(adjustedDestIdx, 0, section);
        window.saveCustomCards();
        updateDashboard();
        if (window.showToast) window.showToast('Point reordered', 'success');
        return;
      }
    }
    
    // Type cards - reorder points within same card (both regular and custom)
    // This must be checked FIRST before any removal/addition logic
    // IMPORTANT: Only reorder if same card (srcId === destId) AND different indices
    let reorderSucceeded = false;
    if (srcType === 'type' && destType === 'type' && srcId === destId && srcIdx !== null && destIdx !== null && srcIdx !== destIdx) {
      const cardKey = 'type_' + srcId;
      
      // Initialize cardCustomizations if needed
      if (!window.DashboardState.cardCustomizations) {
        window.DashboardState.cardCustomizations = {};
      }
      if (!window.DashboardState.cardCustomizations[cardKey]) {
        window.DashboardState.cardCustomizations[cardKey] = { customPoints: [], pointOrder: [] };
      }
      
      const customizations = window.DashboardState.cardCustomizations[cardKey];
      const customPoints = customizations.customPoints || [];
      let pointOrder = customizations.pointOrder || [];
      
      // Parse indices
      let srcIdxNum = null;
      let destIdxNum = null;
      let srcIsCustom = false;
      let destIsCustom = false;
      
      if (typeof srcIdx === 'string' && srcIdx.startsWith('custom_')) {
        srcIdxNum = parseInt(srcIdx.replace('custom_', ''));
        srcIsCustom = true;
      } else {
        srcIdxNum = parseInt(srcIdx);
        srcIsCustom = false;
      }
      
      if (typeof destIdx === 'string' && destIdx.startsWith('custom_')) {
        destIdxNum = parseInt(destIdx.replace('custom_', ''));
        destIsCustom = true;
      } else {
        destIdxNum = parseInt(destIdx);
        destIsCustom = false;
      }
      
      // Reorder custom points (assigned points)
      if (srcIsCustom && destIsCustom && srcIdxNum !== null && !isNaN(srcIdxNum) && destIdxNum !== null && !isNaN(destIdxNum) &&
          srcIdxNum >= 0 && srcIdxNum < customPoints.length && destIdxNum >= 0 && destIdxNum <= customPoints.length) {
        const point = customPoints[srcIdxNum];
        customPoints.splice(srcIdxNum, 1);
        let targetIdx = destIdxNum;
        if (targetIdx < 0) targetIdx = 0;
        if (targetIdx > customPoints.length) targetIdx = customPoints.length;
        customPoints.splice(targetIdx, 0, point);
        window.DashboardState.save('cardCustomizations');
        updateDashboard();
        if (window.showToast) window.showToast('Point reordered', 'success');
        reorderSucceeded = true;
        return;
      } else if (srcIsCustom || destIsCustom) {
        console.log('⚠️ Custom point reorder path (simplified):', { srcIsCustom, destIsCustom, srcIdxNum, destIdxNum, customPointsLength: customPoints.length });
        // Normalize dest index for safety
        if (destIdxNum === null || isNaN(destIdxNum)) destIdxNum = customPoints.length;
        if (destIdxNum < 0) destIdxNum = 0;

        // Get components count to translate rendered index to custom index
        const dashboardConfig = window.dashboardConfig || {};
        const global = dashboardConfig.global || {};
        const byType = global.byType || {};
        const components = byType[srcId] || [];
        const regularCount = components.length;

        // Map rendered index to customPoints index: anything after regulars maps to (destIdxNum - regularCount), else to 0
        let targetCustomIdx = destIsCustom ? destIdxNum : Math.max(0, destIdxNum - regularCount);
        if (targetCustomIdx < 0) targetCustomIdx = 0;
        if (targetCustomIdx > customPoints.length) targetCustomIdx = customPoints.length;

        // Find source point in customPoints
        let sourceIdxInCustom = srcIsCustom ? srcIdxNum : -1;
        if (sourceIdxInCustom === null || isNaN(sourceIdxInCustom) || sourceIdxInCustom < 0 || sourceIdxInCustom >= customPoints.length) {
          // Try by ORD
          let pointOrd = pointData.ord || pointData.slotPath || '';
          if (pointOrd && pointOrd.includes('slot:slot:')) pointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
          const normalizedPointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
          sourceIdxInCustom = customPoints.findIndex(cp => {
            const cpOrd = (cp.ord || cp.data?.ord || '').replace(/slot:slot:/g, 'slot:');
            return cpOrd === normalizedPointOrd;
          });
        }

        if (sourceIdxInCustom >= 0 && sourceIdxInCustom < customPoints.length) {
          const point = customPoints[sourceIdxInCustom];
          customPoints.splice(sourceIdxInCustom, 1);
          if (targetCustomIdx > customPoints.length) targetCustomIdx = customPoints.length;
          customPoints.splice(targetCustomIdx, 0, point);
          window.DashboardState.save('cardCustomizations');
          updateDashboard();
          if (window.showToast) window.showToast('Point reordered', 'success');
          console.log('✅ Reordered/moved custom point in type card:', cardKey, sourceIdxInCustom, '->', targetCustomIdx, '(regularCount:', regularCount, ')');
          reorderSucceeded = true;
          return;
        }
      }
      
      // Reorder regular points (store order in pointOrder array)
      if (!srcIsCustom && !destIsCustom && srcIdxNum !== null && !isNaN(srcIdxNum) && destIdxNum !== null && !isNaN(destIdxNum) && srcIdxNum >= 0 && destIdxNum >= 0) {
        // Get the component ORD to identify it
        const dashboardConfig = window.dashboardConfig || {};
        const global = dashboardConfig.global || {};
        const byType = global.byType || {};
        const components = byType[srcId] || [];
        
        // Get the point ORD from the dragged point data and normalize it
        let pointOrd = pointData.ord || pointData.slotPath || '';
        if (pointOrd && pointOrd.includes('slot:slot:')) {
          pointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
        }
        // Initialize pointOrder if needed - but preserve manually assigned points
        if (pointOrder.length === 0) {
          // First time initialization - create from components
          pointOrder = components.map(function(c) {
            let ord = c.ord || c.slotPath || '';
            // Normalize ORD - remove duplicate "slot:" prefixes
            if (ord && ord.includes('slot:slot:')) {
              ord = ord.replace(/slot:slot:/g, 'slot:');
            }
            return ord;
          });
          // Also add any customPoints that aren't in components
          const customPoints = customizations.customPoints || [];
          customPoints.forEach(function(cp) {
            const cpOrd = (cp.ord || cp.data?.ord || '').replace(/slot:slot:/g, 'slot:');
            if (cpOrd && pointOrder.indexOf(cpOrd) < 0) {
              pointOrder.push(cpOrd);
            }
          });
          customizations.pointOrder = pointOrder;
          console.log('📝 Initialized pointOrder for type card:', cardKey, 'with', pointOrder.length, 'points (', components.length, 'regular +', customPoints.length, 'custom)');
        } else {
          // pointOrder exists - merge in any new components that aren't in pointOrder yet
          const existingOrds = pointOrder.map(ord => (ord || '').replace(/slot:slot:/g, 'slot:'));
          let addedComponents = 0;
          components.forEach(function(c) {
            let ord = c.ord || c.slotPath || '';
            if (ord && ord.includes('slot:slot:')) {
              ord = ord.replace(/slot:slot:/g, 'slot:');
            }
            if (ord && existingOrds.indexOf(ord) < 0) {
              pointOrder.push(ord);
              existingOrds.push(ord);
              addedComponents++;
            }
          });
          // Also add any customPoints that aren't in pointOrder
          let addedCustom = 0;
          customPoints.forEach(function(cp) {
            const cpOrd = (cp.ord || cp.data?.ord || '').replace(/slot:slot:/g, 'slot:');
            if (cpOrd && existingOrds.indexOf(cpOrd) < 0) {
              pointOrder.push(cpOrd);
              existingOrds.push(cpOrd);
              addedCustom++;
            }
          });
          customizations.pointOrder = pointOrder;
          if (addedComponents > 0 || addedCustom > 0) {
          }
        }
        
        // Find the point by ORD in pointOrder (normalize ORDs for comparison)
        const normalizedPointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
        const srcOrdIndex = pointOrder.findIndex(ord => {
          const normalizedOrd = (ord || '').replace(/slot:slot:/g, 'slot:');
          return normalizedOrd === normalizedPointOrd;
        });
        
        if (srcOrdIndex >= 0) {
          // We found the point in pointOrder, now reorder based on destIdxNum
          // destIdxNum is the target position in the rendered list (0-based)
          // Clamp destIdxNum to valid range
          let targetOrdIndex = Math.max(0, Math.min(destIdxNum, pointOrder.length - 1));
          
          // If same position, no need to reorder
          if (srcOrdIndex === targetOrdIndex) {
            reorderSucceeded = true; // Mark as succeeded even though no change
            return;
          }
          
          // Remove from source position
          pointOrder.splice(srcOrdIndex, 1);
          
          // Insert at target position (no downward adjustment; dest index reflects rendered order)
          let insertIdx = targetOrdIndex;
          if (insertIdx < 0) insertIdx = 0;
          if (insertIdx > pointOrder.length) insertIdx = pointOrder.length;
          
          pointOrder.splice(insertIdx, 0, pointOrd);
          customizations.pointOrder = pointOrder;
          
          window.DashboardState.save('cardCustomizations');
          updateDashboard();
          if (window.showToast) window.showToast('Point reordered', 'success');
          reorderSucceeded = true;
          return;
        } else {
          // Check if this is a custom point (assigned point) - if so, we can't reorder it using pointOrder
          // Instead, we should check if it's in customPoints and handle reordering there
          const customPoints = customizations.customPoints || [];
          const customPointIndex = customPoints.findIndex(cp => {
            const cpOrd = cp.ord || cp.data?.ord || '';
            const normalizedCpOrd = cpOrd.replace(/slot:slot:/g, 'slot:');
            return normalizedCpOrd === normalizedPointOrd;
          });
          if (customPointIndex >= 0) {
          // Found the point in customPoints - reorder it
          const point = customPoints[customPointIndex];
          customPoints.splice(customPointIndex, 1);
          let insertIdx = destIdxNum;
          if (insertIdx < 0) insertIdx = 0;
          if (insertIdx > customPoints.length) insertIdx = customPoints.length;
          customPoints.splice(insertIdx, 0, point);
            customizations.pointOrder = pointOrder;
            window.DashboardState.save('cardCustomizations');
            updateDashboard();
            if (window.showToast) window.showToast('Point reordered', 'success');
            reorderSucceeded = true;
            return;
          } else if (pointOrd) {
            // Point not in pointOrder and not in customPoints - add it to pointOrder
            const insertIndex = Math.max(0, Math.min(destIdxNum, pointOrder.length));
            pointOrder.splice(insertIndex, 0, pointOrd);
            customizations.pointOrder = pointOrder;
            window.DashboardState.save('cardCustomizations');
            updateDashboard();
            reorderSucceeded = true;
            return;
          }
        }
      } else {
      }
    }
    
    // All Devices reorder (display-only list)
    if (srcType === 'alldevices' && destType === 'alldevices' && srcIdx !== null && destIdx !== null) {
      if (!window.DashboardState.allDevicesOrder) window.DashboardState.allDevicesOrder = [];
      let order = window.normalizeAllDevicesOrder ? window.normalizeAllDevicesOrder(window.dashboardConfig?.global?.snapshot || []) : (window.DashboardState.allDevicesOrder || []);
      // Normalize ORD
      let ord = pointData.ord || pointData.slotPath || '';
      if (!ord) {
        return;
      }
      if (ord && ord.includes('slot:slot:')) ord = ord.replace(/slot:slot:/g, 'slot:');
      const sourceIdx = order.indexOf(ord);
      
      // Support ord-targeted drops: destIdx may be "ord:<ord>:above|below"
      let destIdxNum = null;
      if (typeof destIdx === 'string' && destIdx.startsWith('ord:')) {
        const parts = destIdx.split(':');
        const targetOrd = (parts[1] || '').replace(/slot:slot:/g, 'slot:');
        const position = parts[2] || 'above';
        const targetPos = order.indexOf(targetOrd);
        if (targetPos >= 0) {
          destIdxNum = position === 'below' ? targetPos + 1 : targetPos;
        } else {
          destIdxNum = order.length;
        }
      } else {
        // destIdx is the visual index in the rendered list
        // We need to map it to the order array
        destIdxNum = parseInt(destIdx);
        if (isNaN(destIdxNum)) destIdxNum = 0;
        // Clamp to valid range
        if (destIdxNum < 0) destIdxNum = 0;
        if (destIdxNum > order.length) destIdxNum = order.length;
      }
      
      // Remove from source position first
      if (sourceIdx >= 0) {
        order.splice(sourceIdx, 1);
        // Adjust target index if removing from before target
        if (sourceIdx < destIdxNum) {
          destIdxNum = destIdxNum - 1;
        }
      }
      
      // Insert at target position
      order.splice(destIdxNum, 0, ord);
      window.DashboardState.allDevicesOrder = order;
      window.DashboardState.save('allDevicesOrder');
      // Lock sort so manual order stays visible
      window.deviceListSortLocked = true;
      if (window.deviceListSort) {
        window.deviceListSort = { column: null, direction: 'asc' };
      }
      updateDashboard();
      if (window.showToast) window.showToast('All Devices reordered', 'success');
      return;
    }

    // Zone cards - reorder points within same card (both regular and custom)
    if (srcType === 'zone' && destType === 'zone' && srcId === destId && srcIdx !== null && destIdx !== null) {
      const cardKey = 'zone_' + srcId;
      
      // Initialize cardCustomizations if needed
      if (!window.DashboardState.cardCustomizations) {
        window.DashboardState.cardCustomizations = {};
      }
      if (!window.DashboardState.cardCustomizations[cardKey]) {
        window.DashboardState.cardCustomizations[cardKey] = { customPoints: [], pointOrder: [] };
      }
      
      const customizations = window.DashboardState.cardCustomizations[cardKey];
      const customPoints = customizations.customPoints || [];
      let pointOrder = customizations.pointOrder || [];
      
      // Parse indices
      let srcIdxNum = null;
      let destIdxNum = null;
      let srcIsCustom = false;
      let destIsCustom = false;
      
      if (typeof srcIdx === 'string' && srcIdx.startsWith('custom_')) {
        srcIdxNum = parseInt(srcIdx.replace('custom_', ''));
        srcIsCustom = true;
      } else {
        srcIdxNum = parseInt(srcIdx);
        srcIsCustom = false;
      }
      
      if (typeof destIdx === 'string' && destIdx.startsWith('custom_')) {
        destIdxNum = parseInt(destIdx.replace('custom_', ''));
        destIsCustom = true;
      } else {
        destIdxNum = parseInt(destIdx);
        destIsCustom = false;
      }
      
      // Reorder custom points
      if (srcIsCustom && destIsCustom && srcIdxNum >= 0 && srcIdxNum < customPoints.length && destIdxNum >= 0 && destIdxNum <= customPoints.length) {
        const point = customPoints[srcIdxNum];
        customPoints.splice(srcIdxNum, 1);
        let targetIdx = destIdxNum;
        if (targetIdx < 0) targetIdx = 0;
        if (targetIdx > customPoints.length) targetIdx = customPoints.length;
        customPoints.splice(targetIdx, 0, point);
        window.DashboardState.save('cardCustomizations');
        updateDashboard();
        if (window.showToast) window.showToast('Point reordered', 'success');
        return;
      }
      
      // Reorder regular points (store order in pointOrder array)
      if (!srcIsCustom && !destIsCustom && srcIdxNum >= 0 && destIdxNum >= 0) {
        // Get the component ORD to identify it
        const dashboardConfig = window.dashboardConfig || {};
        const global = dashboardConfig.global || {};
        const byZone = global.byZone || {};
        const components = byZone[srcId] || [];
        
        if (srcIdxNum < components.length && destIdxNum <= components.length) {
          // Store point order if not already stored
          if (pointOrder.length === 0) {
            pointOrder = components.map(function(c) { return c.ord || c.slotPath || ''; });
            customizations.pointOrder = pointOrder;
          }
          
          // Reorder the pointOrder array
          const ord = pointOrder[srcIdxNum];
          pointOrder.splice(srcIdxNum, 1);
          let insertIdx = destIdxNum;
          if (insertIdx < 0) insertIdx = 0;
          if (insertIdx > pointOrder.length) insertIdx = pointOrder.length;
          pointOrder.splice(insertIdx, 0, ord);
          customizations.pointOrder = pointOrder;
          
          window.DashboardState.save('cardCustomizations');
          updateDashboard();
          if (window.showToast) window.showToast('Point reordered', 'success');
          return;
        }
      }
    }
    
    // NOTE: Type card reordering is handled above in the unified reorder section (line 7692)
    // This duplicate section has been removed to prevent conflicts
    // If you're seeing this message, the reorder should have been handled above
    
    // Zone cards - reorder custom points within same card
    if (srcType === 'zone' && destType === 'zone' && srcId === destId && srcIdx !== null && destIdx !== null) {
      const cardKey = 'zone_' + srcId;
      if (window.DashboardState.cardCustomizations && window.DashboardState.cardCustomizations[cardKey]) {
        const customPoints = window.DashboardState.cardCustomizations[cardKey].customPoints || [];
        
        // Parse indices (handle custom_ prefix and number types)
        let srcIdxNum = null;
        let destIdxNum = null;
        
        if (typeof srcIdx === 'string' && srcIdx.startsWith('custom_')) {
          srcIdxNum = parseInt(srcIdx.replace('custom_', ''));
        } else if (typeof srcIdx === 'number') {
          srcIdxNum = srcIdx;
        } else {
          srcIdxNum = parseInt(srcIdx);
        }
        
        if (typeof destIdx === 'string' && destIdx.startsWith('custom_')) {
          destIdxNum = parseInt(destIdx.replace('custom_', ''));
        } else if (typeof destIdx === 'number') {
          destIdxNum = destIdx;
        } else {
          destIdxNum = parseInt(destIdx);
        }
        // Only reorder if both are custom points (within valid range)
        if (srcIdxNum !== null && !isNaN(srcIdxNum) && destIdxNum !== null && !isNaN(destIdxNum) &&
            srcIdxNum >= 0 && srcIdxNum < customPoints.length && destIdxNum >= 0 && destIdxNum <= customPoints.length) {
          const point = customPoints[srcIdxNum];
          customPoints.splice(srcIdxNum, 1);
          let targetIdx = destIdxNum;
          if (targetIdx < 0) targetIdx = 0;
          if (targetIdx > customPoints.length) targetIdx = customPoints.length;
          customPoints.splice(targetIdx, 0, point);
          window.DashboardState.save('cardCustomizations');
          updateDashboard();
          if (window.showToast) window.showToast('Point reordered', 'success');
          return;
        } else {
        }
      }
    }
    
    // Remove from source BEFORE adding to destination
    // BUT: Skip removal if reorder succeeded (already handled above)
    // Only skip removal if it was a reorder within the same card
    const wasReorder = srcType === destType && srcId === destId && srcIdx !== null && destIdx !== null && srcIdx !== destIdx && reorderSucceeded;
    if (!wasReorder) {
      // Remove from type card customizations
      if (srcType === 'type' && srcId !== undefined) {
        const srcCardKey = 'type_' + srcId;
        if (window.DashboardState.cardCustomizations && window.DashboardState.cardCustomizations[srcCardKey]) {
          const customizations = window.DashboardState.cardCustomizations[srcCardKey];
          const customPoints = customizations.customPoints || [];
          const pointIndex = typeof srcIdx === 'string' && srcIdx.startsWith('custom_') ? parseInt(srcIdx.replace('custom_', '')) : null;
          if (pointIndex !== null && pointIndex >= 0 && pointIndex < customPoints.length) {
            customPoints.splice(pointIndex, 1);
          } else if (pointOrd) {
            // Try to find by ORD (normalized)
            const normalizedPointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
            const foundIndex = customPoints.findIndex(cp => {
              const cpOrd = cp.ord || cp.data?.ord || '';
              const normalizedCpOrd = cpOrd.replace(/slot:slot:/g, 'slot:');
              return normalizedCpOrd === normalizedPointOrd;
            });
            if (foundIndex >= 0) {
              customPoints.splice(foundIndex, 1);
            }
          }
          // Also remove from pointOrder if it exists
          if (customizations.pointOrder && pointOrd) {
            const normalizedPointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
            const ordIndex = customizations.pointOrder.findIndex(ord => {
              const normalizedOrd = (ord || '').replace(/slot:slot:/g, 'slot:');
              return normalizedOrd === normalizedPointOrd;
            });
            if (ordIndex >= 0) {
              customizations.pointOrder.splice(ordIndex, 1);
            }
          }
          window.DashboardState.save('cardCustomizations');
        }
      }
    } else {
    }
    
      // Remove from zone card customizations
      if (srcType === 'zone' && srcId !== undefined) {
        const srcCardKey = 'zone_' + srcId;
        if (window.DashboardState.cardCustomizations && window.DashboardState.cardCustomizations[srcCardKey]) {
          const customPoints = window.DashboardState.cardCustomizations[srcCardKey].customPoints || [];
          const pointIndex = typeof srcIdx === 'string' && srcIdx.startsWith('custom_') ? parseInt(srcIdx.replace('custom_', '')) : null;
          if (pointIndex !== null && pointIndex >= 0 && pointIndex < customPoints.length) {
            customPoints.splice(pointIndex, 1);
          } else if (pointOrd) {
            // Try to find by ORD (normalized)
            const normalizedPointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
            const foundIndex = customPoints.findIndex(cp => {
              const cpOrd = cp.ord || cp.data?.ord || '';
              const normalizedCpOrd = cpOrd.replace(/slot:slot:/g, 'slot:');
              return normalizedCpOrd === normalizedPointOrd;
            });
            if (foundIndex >= 0) {
              customPoints.splice(foundIndex, 1);
            }
          }
          window.DashboardState.save('cardCustomizations');
        }
      }
    
    // Remove from custom card
    if (srcType === 'custom' && srcId !== undefined && srcIdx !== null) {
      const srcCardIndex = parseInt(srcId);
      if (window.customCards && window.customCards[srcCardIndex] && window.customCards[srcCardIndex].sections) {
        window.customCards[srcCardIndex].sections.splice(srcIdx, 1);
        window.saveCustomCards();
      }
    }
    
    // Note: "alldevices" is a read-only view of live data, so we don't remove from it
    // Points can be moved FROM alldevices TO other cards, but not removed from alldevices itself
    
    // Now add to destination
    if (pointOrd) {
      if (!window.DashboardState.pointAssignments) {
        window.DashboardState.pointAssignments = {};
      }
      window.DashboardState.pointAssignments[pointOrd] = {
        containerType: destType,
        containerId: destId,
        index: destIdx,
        timestamp: new Date().toISOString()
      };
      window.DashboardState.save('pointAssignments');
    }
    
    // Handle drops to device type cards
    // Skip if this was a reorder attempt (same card, same type, different indices) - reorder should have been handled above
    // But allow if moving from a different card (srcId !== destId) or same position (srcIdx === destIdx)
    const isReorderAttempt = srcType === 'type' && destType === 'type' && srcId === destId && srcIdx !== null && destIdx !== null && srcIdx !== destIdx;
    if (destType === 'type' && !isReorderAttempt) {
      if (!window.DashboardState.cardCustomizations) {
        window.DashboardState.cardCustomizations = {};
      }
      const cardKey = 'type_' + destId;
      if (!window.DashboardState.cardCustomizations[cardKey]) {
        window.DashboardState.cardCustomizations[cardKey] = { customPoints: [], hiddenPoints: [] };
      }
      if (!window.DashboardState.cardCustomizations[cardKey].customPoints) {
        window.DashboardState.cardCustomizations[cardKey].customPoints = [];
      }
      // Insert point at the correct position (destIdx) instead of always appending
      const customPoints = window.DashboardState.cardCustomizations[cardKey].customPoints;
      const insertIndex = (destIdx !== null && destIdx !== undefined && !isNaN(destIdx)) ? Math.max(0, Math.min(parseInt(destIdx), customPoints.length)) : customPoints.length;
      customPoints.splice(insertIndex, 0, {
        ord: pointOrd,
        data: pointData,
        index: insertIndex
      });
      
      // Also add to pointOrder (for regular points that were moved)
      const customizations = window.DashboardState.cardCustomizations[cardKey];
      if (!customizations.pointOrder) {
        // Initialize pointOrder from components first, then add customPoints
        const dashboardConfig = window.dashboardConfig || {};
        const global = dashboardConfig.global || {};
        const byType = global.byType || {};
        const components = byType[destId] || [];
        customizations.pointOrder = components.map(function(c) {
          let ord = c.ord || c.slotPath || '';
          if (ord && ord.includes('slot:slot:')) {
            ord = ord.replace(/slot:slot:/g, 'slot:');
          }
          return ord;
        });
      }
      // Only add to pointOrder if it's not already there (might be a regular point that was moved)
      const normalizedPointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
      const ordExists = customizations.pointOrder.some(ord => {
        const normalizedOrd = (ord || '').replace(/slot:slot:/g, 'slot:');
        return normalizedOrd === normalizedPointOrd;
      });
      if (pointOrd && !ordExists) {
        // Insert at the same position as in customPoints
        const pointOrderInsertIndex = Math.max(0, Math.min(insertIndex, customizations.pointOrder.length));
        customizations.pointOrder.splice(pointOrderInsertIndex, 0, pointOrd);
      }
      
      window.DashboardState.save('cardCustomizations');
      updateDashboard();
      if (window.showToast) window.showToast('Point moved to ' + destId + ' card', 'success');
      return;
    }
    
    // Handle drops to zone cards
    // Skip only if reorder succeeded (already handled above)
    // Allow if reorder failed or if moving from a different card
    if (destType === 'zone' && !(srcType === 'zone' && srcId === destId && srcIdx !== null && destIdx !== null && srcIdx !== destIdx && reorderSucceeded)) {
      if (!window.DashboardState.cardCustomizations) {
        window.DashboardState.cardCustomizations = {};
      }
      const cardKey = 'zone_' + destId;
      if (!window.DashboardState.cardCustomizations[cardKey]) {
        window.DashboardState.cardCustomizations[cardKey] = { customPoints: [], hiddenPoints: [] };
      }
      if (!window.DashboardState.cardCustomizations[cardKey].customPoints) {
        window.DashboardState.cardCustomizations[cardKey].customPoints = [];
      }
      // Insert point at the correct position (destIdx) instead of always appending
      const customPoints = window.DashboardState.cardCustomizations[cardKey].customPoints;
      const insertIndex = (destIdx !== null && destIdx !== undefined && !isNaN(destIdx)) ? Math.max(0, Math.min(parseInt(destIdx), customPoints.length)) : customPoints.length;
      customPoints.splice(insertIndex, 0, {
        ord: pointOrd,
        data: pointData,
        index: insertIndex
      });
      
      // Also add to pointOrder (for zone cards)
      const customizations = window.DashboardState.cardCustomizations[cardKey];
      if (!customizations.pointOrder) {
        // Initialize pointOrder from zone components first
        // Get components for this zone from dashboardConfig
        const dashboardConfig = window.dashboardConfig || {};
        const global = dashboardConfig.global || {};
        const byZone = global.byZone || {};
        const zoneComponents = byZone[destId] || [];
        customizations.pointOrder = zoneComponents.map(function(c) {
          let ord = c.ord || c.slotPath || '';
          if (ord && ord.includes('slot:slot:')) {
            ord = ord.replace(/slot:slot:/g, 'slot:');
          }
          return ord;
        });
      }
      // Only add to pointOrder if it's not already there
      const normalizedPointOrd = pointOrd.replace(/slot:slot:/g, 'slot:');
      const ordExists = customizations.pointOrder.some(ord => {
        const normalizedOrd = (ord || '').replace(/slot:slot:/g, 'slot:');
        return normalizedOrd === normalizedPointOrd;
      });
      if (pointOrd && !ordExists) {
        const pointOrderInsertIndex = Math.max(0, Math.min(insertIndex, customizations.pointOrder.length));
        customizations.pointOrder.splice(pointOrderInsertIndex, 0, pointOrd);
      }
      
      window.DashboardState.save('cardCustomizations');
      updateDashboard();
      if (window.showToast) window.showToast('Point moved to zone ' + destId, 'success');
      return;
    }
    
    // Handle drops to custom cards
    if (destType === 'custom') {
      const cardIndex = parseInt(destId);
      if (!window.customCards) window.customCards = [];
      if (!window.customCards[cardIndex]) {
        window.customCards[cardIndex] = { title: 'New Card', sections: [] };
      }
      if (!window.customCards[cardIndex].sections) {
        window.customCards[cardIndex].sections = [];
      }
      
      window.customCards[cardIndex].sections.splice(destIdx, 0, { type: 'point', data: pointData });
      window.saveCustomCards();
      updateDashboard();
      if (window.showToast) window.showToast('Point moved to card', 'success');
      return;
    }
    
    // Unknown destination type
    if (window.showToast) {
      window.showToast('Point assignment saved', 'success');
    }
  };
  
  // Helper functions for drag and drop
  window.clearDropIndicators = function() {
    document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(function(el) {
      el.classList.remove('drag-over-top', 'drag-over-bottom');
    });
  };
  
  window.clearAllDragClasses = function() {
    document.querySelectorAll('.dragging, .drag-over, .drag-over-top, .drag-over-bottom').forEach(function(el) {
      el.classList.remove('dragging', 'drag-over', 'drag-over-top', 'drag-over-bottom');
    });
  };
  
  // Point drag over handler for reordering
  window.handlePointDragOver = function(event) {
    // Allow drag over if we have a point in dragState OR if dataTransfer has point data
    let isPointDrag = false;
    if (window.dragState && window.dragState.type === 'point') {
      isPointDrag = true;
    } else {
      // Check dataTransfer
      try {
        const types = event.dataTransfer.types;
        if (types && types.length > 0) {
          // Try to get data
          const data = event.dataTransfer.getData('text/plain');
          if (data) {
            const transferData = JSON.parse(data);
            if (transferData.type === 'point' || transferData.dragType === 'point') {
              isPointDrag = true;
            }
          }
        }
      } catch(e) {
        // Ignore errors
      }
    }
    
    if (!isPointDrag) return;
    
    event.preventDefault();
    event.stopPropagation();
    
    const targetPoint = event.currentTarget;
    if (window.dragState && targetPoint === window.dragState.item) return;
    
    // Clear other indicators
    document.querySelectorAll('.drag-over-top, .drag-over-bottom').forEach(function(el) {
      if (el !== targetPoint) {
        el.classList.remove('drag-over-top', 'drag-over-bottom');
      }
    });
    
    // Determine if drop is above or below
    const rect = targetPoint.getBoundingClientRect();
    const midY = rect.top + rect.height / 2;
    
    if (event.clientY < midY) {
      targetPoint.classList.remove('drag-over-bottom');
      targetPoint.classList.add('drag-over-top');
    } else {
      targetPoint.classList.remove('drag-over-top');
      targetPoint.classList.add('drag-over-bottom');
    }
  };
  
  // Point drop handler for reordering
  window.handlePointDrop = function(event) {
    event.preventDefault();
    event.stopPropagation();
    const targetPoint = event.currentTarget;
    const isDropAbove = targetPoint.classList.contains('drag-over-top');
    targetPoint.classList.remove('drag-over-top', 'drag-over-bottom');
    
    // Try to get data from dragState or dataTransfer
    let pointData = null;
    let sourceContainer = null;
    let sourceContainerId = null;
    let sourceIndex = null;
    let wasFromHelper = false;
    
    if (window.dragState && window.dragState.type === 'point') {
      if (targetPoint === window.dragState.item) {
        return;
      }
      pointData = window.dragState.data;
      sourceContainer = window.dragState.sourceContainer;
      sourceContainerId = window.dragState.sourceContainerId;
      sourceIndex = window.dragState.sourceIndex;
      wasFromHelper = sourceContainer === 'helper';
    } else {
      // Fallback: read from dataTransfer
      try {
        const transferData = JSON.parse(event.dataTransfer.getData('text/plain'));
        if ((transferData.type === 'point' || transferData.dragType === 'point') && transferData.data) {
          pointData = transferData.data;
          sourceContainer = 'helper';
          sourceContainerId = null;
          sourceIndex = null;
          wasFromHelper = true;
        }
      } catch(e) {
        return;
      }
    }
    
    if (!pointData) {
      return;
    }
    
    const targetContainerType = targetPoint.dataset.containerType;
    const targetContainerId = targetPoint.dataset.containerId;
    let targetIndex = targetPoint.dataset.pointIndex;
    const targetOrdAttr = targetPoint.dataset.pointOrd;
    
    // Handle custom_ prefix for custom points
    if (typeof targetIndex === 'string' && targetIndex.startsWith('custom_')) {
      // Keep as string for custom points
      if (!isDropAbove) {
        // If dropping below, increment the index
        const idxNum = parseInt(targetIndex.replace('custom_', ''));
        targetIndex = 'custom_' + (idxNum + 1);
      }
    } else {
      // Regular point index
      targetIndex = parseInt(targetIndex) || 0;
      if (!isDropAbove) targetIndex++;
    }
    
    // For All Devices, prefer ord-based targeting to avoid index drift after sorts
    if (targetContainerType === 'alldevices' && targetOrdAttr) {
      targetIndex = 'ord:' + targetOrdAttr + (isDropAbove ? ':above' : ':below');
    }
    // Use movePoint function to handle the move
    window.movePoint(
      sourceContainer,
      sourceContainerId,
      sourceIndex,
      targetContainerType,
      targetContainerId,
      targetIndex,
      pointData
    );
    
    // Clear drag state
    if (window.dragState) {
      window.dragState = { item: null, type: null, data: null, sourceContainer: null, sourceContainerId: null, sourceIndex: null };
    }
    
    // Clear drag state
    window.dragState = { item: null, type: null, data: null, sourceContainer: null, sourceIndex: null };
    
    // Remove dragging-active class and close helper modal if item was dragged from it
    if (wasFromHelper) {
      const modal = document.querySelector('.point-helper-modal');
      if (modal) {
        modal.classList.remove('dragging-active');
        setTimeout(function() {
          window.closePointHelper();
        }, 100);
      }
    }
  };
  
  window.handleCreateCardDrop = function(event) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    // Try to get data from dragState or dataTransfer
    let pointData = null;
    let historyData = null;
    let wasFromHelper = false;
    
    if (window.dragState && window.dragState.type === 'point') {
      pointData = window.dragState.data;
      wasFromHelper = window.dragState.sourceContainer === 'helper';
    } else {
      // Fallback: read from dataTransfer
      try {
        const transferData = JSON.parse(event.dataTransfer.getData('text/plain'));
        if ((transferData.type === 'point' || transferData.dragType === 'point') && transferData.data) {
          pointData = transferData.data;
          wasFromHelper = true;
        } else if (transferData.type === 'history' && transferData.data) {
          historyData = transferData.data;
        }
      } catch(e) {
        return;
      }
    }
    
    if (pointData) {
      // Create new card with this point
      const newCard = {
        title: 'New Card',
        sections: [
          { type: 'point', data: pointData }
        ]
      };
      if (!window.customCards) window.customCards = [];
      window.customCards.push(newCard);
      window.saveCustomCards();
      updateDashboard();
    } else if (historyData) {
      // Create new card with history chart
      const newCard = {
        title: 'History Chart',
        sections: [
          { type: 'history', data: historyData }
        ]
      };
      if (!window.customCards) window.customCards = [];
      window.customCards.push(newCard);
      window.saveCustomCards();
      updateDashboard();
    }
    
    // Clear drag state
    window.dragState = { item: null, type: null, data: null, sourceContainer: null, sourceIndex: null };
    
    // Remove dragging-active class and close helper modal if item was dragged from it
    if (wasFromHelper) {
      const modal = document.querySelector('.point-helper-modal');
      if (modal) {
        modal.classList.remove('dragging-active');
        setTimeout(function() {
          const closeBtn = modal.querySelector('.point-helper-close');
          if (closeBtn) closeBtn.click();
        }, 100);
      }
    }
  };
  
  window.handleCardContentDrop = function(event, cardIndex) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    try {
      const data = JSON.parse(event.dataTransfer.getData('text/plain'));
      
      if (!window.customCards || !window.customCards[cardIndex]) return;
      
      if (data.type === 'point') {
        // Add point to card
        if (!window.customCards[cardIndex].sections) {
          window.customCards[cardIndex].sections = [];
        }
        window.customCards[cardIndex].sections.push({ type: 'point', data: data.data });
        window.saveCustomCards();
        updateDashboard();
      } else if (data.type === 'history') {
        // Add history chart to card
        if (!window.customCards[cardIndex].sections) {
          window.customCards[cardIndex].sections = [];
        }
        window.customCards[cardIndex].sections.push({ type: 'history', data: data.data });
        window.saveCustomCards();
        updateDashboard();
      }
    } catch(e) {
    }
  };
  
  // Dashboard Persistence using Program Object
  // Configure this with the ORD of your persistence program
  window.DASHBOARD_PERSISTENCE_PROGRAM_ORD = "station:|slot:/JsonHelper"; // Your program's ORD
  window.DASHBOARD_PERSISTENCE_DIRECTORY = "file:^web"; // Directory where files will be saved
  window.USE_FILE_PERSISTENCE = true; // Set to true to use file persistence instead of localStorage
  
  // Get current username for user-specific persistence
  window.getCurrentUsername = function() {
    return (window.currentUser && window.currentUser.name) || 'default';
  };
  
  // User-specific data key generator
  window.getUserDataKey = function(baseKey) {
    const username = window.getCurrentUsername();
    return username + '_' + baseKey;
  };
  
  // Test function - call this from browser console: testDashboardPersistence()
  window.testDashboardPersistence = async function() {
    // Test with a simple JSON object
    const testData = { test: true, timestamp: new Date().toISOString(), message: 'Test save from browser console' };
    const testJson = JSON.stringify(testData);
    const result = await window.saveDashboardDataToFile('test', testJson);
    
    if (result) {
    } else {
    }
    
    return result;
  };
  
  // Save data to file using program object (user-specific)
  window.saveDashboardDataToFile = async function(dataKey, jsonData) {
    // Make data key user-specific
    const userDataKey = window.getUserDataKey(dataKey);
    if (!window.DASHBOARD_PERSISTENCE_PROGRAM_ORD || !window.DASHBOARD_PERSISTENCE_DIRECTORY) {
      return false;
    }
    
    try {
      console.log('💾 [PERSISTENCE] Starting save for:', userDataKey, '(user:', window.getCurrentUsername() + ')');
      const programOrd = window.DASHBOARD_PERSISTENCE_PROGRAM_ORD;
      const program = await baja.Ord.make(programOrd).get();
      
      if (!program) {
        return false;
      }
      // Set program properties using object syntax: {slot: 'propertyName', value: value}
      // This is more reliable than separate arguments
      const propertiesToSet = [
        { slot: 'operation', value: 'save' },
        { slot: 'dataKey', value: userDataKey },
        { slot: 'jsonData', value: jsonData },
        { slot: 'directory', value: baja.Ord.make(window.DASHBOARD_PERSISTENCE_DIRECTORY) }
      ];
      
      let propertiesSet = 0;
      for (let prop of propertiesToSet) {
        try {
          // Use object syntax for set()
          await program.set({ slot: prop.slot, value: prop.value });
          propertiesSet++;
        } catch(e) {
          // Property might not exist or might be read-only - that's okay, continue
        }
      }
      // Execute the program - invoke returns a promise
      await program.invoke('execute');
      
      // Wait a bit for the program to complete
      await new Promise(resolve => setTimeout(resolve, 1000));
      return true;
    } catch(e) {
      return false;
    }
  };
  
  // Load data from file using program object (user-specific)
  window.loadDashboardDataFromFile = async function(dataKey) {
    // Make data key user-specific
    const userDataKey = window.getUserDataKey(dataKey);
    if (!window.DASHBOARD_PERSISTENCE_PROGRAM_ORD || !window.DASHBOARD_PERSISTENCE_DIRECTORY) {
      return null;
    }
    
    try {
      const programOrd = window.DASHBOARD_PERSISTENCE_PROGRAM_ORD;
      const program = await baja.Ord.make(programOrd).get();
      
      if (!program) {
        return null;
      }
      
      // Set program properties
      program.set('operation', 'load');
      program.set('dataKey', userDataKey);
      program.set('directory', baja.Ord.make(window.DASHBOARD_PERSISTENCE_DIRECTORY));
      
      // Execute the program
      program.invoke('execute');
      
      // Wait a bit for the program to complete, then read the loadedData property
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Re-fetch the program to get updated properties
      const updatedProgram = await baja.Ord.make(programOrd).get();
      const loadedData = updatedProgram.get('loadedData');
      
      if (loadedData) {
        // BString objects need to be converted to string
        const jsonData = loadedData.toString ? loadedData.toString() : String(loadedData);
        console.log('✅ Loaded dashboard data from file:', userDataKey, '(' + jsonData.length + ' chars)');
        return jsonData;
      }
      
      return null;
    } catch(e) {
      return null;
    }
  };
  
  // Enhanced save function that uses file persistence if configured
  window.saveCustomCards = function() {
    try {
      // Sync with state manager
      window.DashboardState.customCards = window.customCards || [];
      
      const jsonData = JSON.stringify(window.DashboardState.customCards);
      if (window.USE_FILE_PERSISTENCE) {
        // Try to save to file, fallback to localStorage
        window.saveDashboardDataToFile('customCards', jsonData).then(function(success) {
          if (!success) {
            // Fallback to localStorage
            window.DashboardState.save('customCards');
          } else {
            // Also save to localStorage as backup
            window.DashboardState.save('customCards');
          }
        }).catch(function(err) {
          // Fallback to localStorage
          window.DashboardState.save('customCards');
        });
      } else {
        // Use localStorage
        window.DashboardState.save('customCards');
      }
    } catch(e) {
    }
  };
  
  window.editCustomCardTitle = function(index) {
    if (!window.customCards || !window.customCards[index]) return;
    window.customCards[index].editing = true;
    updateDashboard();
    setTimeout(function() {
      const input = document.querySelector('[data-card-index="' + index + '"] input');
      if (input) {
        input.focus();
        input.select();
      }
    }, 100);
  };
  
  window.saveCustomCardTitle = function(index, title) {
    if (!window.customCards || !window.customCards[index]) return;
    window.customCards[index].title = title || 'Untitled Card';
    window.customCards[index].editing = false;
    window.saveCustomCards();
    updateDashboard();
  };
  
  window.deleteCustomCard = function(index) {
    if (!window.customCards || !window.customCards[index]) return;
    if (confirm('Delete this custom card?')) {
      window.saveStateForUndo();
      const cardTitle = window.customCards[index].title || 'Card';
      window.customCards.splice(index, 1);
      window.saveCustomCards();
      updateDashboard();
      window.showToast('Deleted: ' + cardTitle, 'info');
    }
  };
  
  window.removePointFromCard = function(cardIndex, sectionIndex) {
    if (!window.customCards || !window.customCards[cardIndex]) return;
    window.saveStateForUndo();
    if (window.customCards[cardIndex].sections) {
      window.customCards[cardIndex].sections.splice(sectionIndex, 1);
      window.saveCustomCards();
      updateDashboard();
    }
  };
  
  // Remove point from container (type, zone, or custom card)
  window.removePointFromContainer = function(containerType, containerId, index) {
    if (containerType === 'custom') {
      window.removePointFromCard(parseInt(containerId), index);
      return;
    }
    // For type/zone cards, we don't actually modify the original data
    // but we can hide the point or add it to a hidden list
  };
  
  // Remove point from history chart
  window.removePointFromChart = function(cardIndex, sectionIndex, pointIndex) {
    if (!window.customCards || !window.customCards[cardIndex]) return;
    const section = window.customCards[cardIndex].sections[sectionIndex];
    if (section && section.points) {
      section.points.splice(pointIndex, 1);
      window.saveCustomCards();
      updateDashboard();
    }
  };
  
  // Remove section from card
  window.removeFromCard = function(cardIndex, sectionIndex) {
    window.removePointFromCard(cardIndex, sectionIndex);
  };
  
  // Add new device type card
  window.addNewDeviceTypeCard = function() {
    // For LivePoints, this would require adding to the device types
    // For now, redirect to creating a custom card
    window.createNewCustomCard();
  };
  
  // Add new zone card
  window.addNewZoneCard = function() {
    // For LivePoints, this would require adding to zones
    // For now, redirect to creating a custom card
    window.createNewCustomCard();
  };
  
  // Alias for addCustomCard
  window.addCustomCard = function() {
    window.createNewCustomCard();
  };
  
  // Edit heading (for type/zone cards)
  window.startEditHeading = function(element, cardId) {
    const currentText = element.textContent;
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentText;
    input.style.cssText = 'background:#1e1e1e; border:2px solid #4CAF50; color:#fff; font-size:inherit; font-weight:bold; padding:2px 6px; border-radius:3px; outline:none; width:' + Math.max(100, element.offsetWidth + 20) + 'px;';
    
    element.replaceWith(input);
    input.focus();
    input.select();
    
    function save() {
      const newTitle = input.value.trim() || currentText;
      if (!window.cardTitles) window.cardTitles = {};
      window.cardTitles[cardId] = newTitle;
      try {
        localStorage.setItem('dashboard_card_titles', JSON.stringify(window.cardTitles));
      } catch(e) {}
      updateDashboard();
    }
    
    input.onblur = save;
    input.onkeydown = function(e) {
      if (e.key === 'Enter') { e.preventDefault(); save(); }
      if (e.key === 'Escape') { updateDashboard(); }
    };
  };
  
  // Edit custom card title
  window.startEditCustomCardTitle = function(element, index) {
    const currentText = element.textContent;
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentText;
    input.style.cssText = 'background:#1e1e1e; border:2px solid #4CAF50; color:#fff; font-size:inherit; font-weight:bold; padding:2px 6px; border-radius:3px; outline:none; width:' + Math.max(100, element.offsetWidth + 20) + 'px;';
    
    element.replaceWith(input);
    input.focus();
    input.select();
    
    function save() {
      const newTitle = input.value.trim() || 'Untitled Card';
      if (window.customCards && window.customCards[index]) {
        window.customCards[index].title = newTitle;
        window.saveCustomCards();
        updateDashboard();
      }
    }
    
    input.onblur = save;
    input.onkeydown = function(e) {
      if (e.key === 'Enter') { e.preventDefault(); save(); }
      if (e.key === 'Escape') { updateDashboard(); }
    };
  };
  
  // Handle drop zone drag over
  window.handleDropZoneDragOver = function(event) {
    if (!window.dragState || window.dragState.type !== 'point') return;
    event.preventDefault();
    event.currentTarget.classList.add('drag-over');
  };
  
  window.removeHistoryFromCard = function(cardIndex, sectionIndex) {
    if (!window.customCards || !window.customCards[cardIndex]) return;
    if (window.customCards[cardIndex].sections) {
      window.customCards[cardIndex].sections.splice(sectionIndex, 1);
      window.saveCustomCards();
      updateDashboard();
    }
  };
  
  // Add heading to card
  window.addHeadingToCard = function(cardIndex) {
    if (!window.customCards || !window.customCards[cardIndex]) return;
    const headingText = prompt('Enter heading text:');
    if (headingText) {
      if (!window.customCards[cardIndex].sections) {
        window.customCards[cardIndex].sections = [];
      }
      window.customCards[cardIndex].sections.push({ type: 'heading', text: headingText });
      window.saveCustomCards();
      updateDashboard();
    }
  };
  
  window.createNewCustomCard = function() {
    window.saveStateForUndo();
    if (!window.customCards) window.customCards = [];
    const newCard = {
      title: 'New Card',
      sections: [],
      positionable: false,
      hidden: false,
      size: { width: 300, height: 200 }
    };
    window.customCards.push(newCard);
    window.saveCustomCards();
    updateDashboard();
    if (window.toggleFABMenu) window.toggleFABMenu();
    window.showToast('New card created', 'success');
    // Scroll to new card
    setTimeout(function() {
      const cards = document.querySelectorAll('.custom-card');
      if (cards.length > 0) {
        cards[cards.length - 1].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }, 100);
  };
  
  window.addBlankHistoryChart = function(cardIndex) {
    if (!window.customCards) {
      window.customCards = [];
    }
    if (!window.customCards[cardIndex]) {
      // Create card if it doesn't exist
      while (window.customCards.length <= cardIndex) {
        window.customCards.push({ title: 'New Card', sections: [] });
      }
    }
    if (!window.customCards[cardIndex].sections) {
      window.customCards[cardIndex].sections = [];
    }
    window.customCards[cardIndex].sections.push({
      type: 'history',
      histories: []
    });
    window.saveCustomCards();
    updateDashboard();
  };
  
  // Resize functionality
  window.startResize = function(event, cardIndex, direction) {
    event.preventDefault();
    event.stopPropagation();
    window.resizing = { cardIndex: cardIndex, direction: direction, startX: event.clientX, startY: event.clientY };
    const card = window.customCards[cardIndex];
    if (card) {
      window.resizing.startWidth = card.size ? card.size.width : 300;
      window.resizing.startHeight = card.size ? card.size.height : 200;
    }
    document.addEventListener('mousemove', window.handleResize);
    document.addEventListener('mouseup', window.stopResize);
  };
  
  window.handleResize = function(event) {
    if (!window.resizing) return;
    const card = window.customCards[window.resizing.cardIndex];
    if (!card) return;
    
    const deltaX = event.clientX - window.resizing.startX;
    const deltaY = event.clientY - window.resizing.startY;
    
    if (!card.size) card.size = { width: 300, height: 200 };
    
    if (window.resizing.direction === 'right' || window.resizing.direction === 'corner') {
      card.size.width = Math.max(200, window.resizing.startWidth + deltaX);
    }
    if (window.resizing.direction === 'bottom' || window.resizing.direction === 'corner') {
      card.size.height = Math.max(150, window.resizing.startHeight + deltaY);
    }
    
    const cardEl = document.querySelector('[data-card-index="' + window.resizing.cardIndex + '"]');
    if (cardEl) {
      cardEl.style.width = card.size.width + 'px';
      cardEl.style.height = card.size.height + 'px';
    }
  };
  
  window.stopResize = function() {
    if (window.resizing) {
      window.saveCustomCards();
      window.resizing = null;
    }
    document.removeEventListener('mousemove', window.handleResize);
    document.removeEventListener('mouseup', window.stopResize);
  };
  
  window.toggleCardPositionable = function(cardIndex) {
    if (!window.customCards || !window.customCards[cardIndex]) return;
    window.customCards[cardIndex].positionable = !window.customCards[cardIndex].positionable;
    if (window.customCards[cardIndex].positionable && !window.customCards[cardIndex].position) {
      const cardEl = document.querySelector('[data-card-index="' + cardIndex + '"]');
      if (cardEl) {
        const rect = cardEl.getBoundingClientRect();
        window.customCards[cardIndex].position = { x: rect.left, y: rect.top };
      }
    }
    window.saveCustomCards();
    updateDashboard();
  };
  
  window.toggleCardHidden = function(cardIndex) {
    if (!window.customCards || !window.customCards[cardIndex]) return;
    window.customCards[cardIndex].hidden = !window.customCards[cardIndex].hidden;
    window.saveCustomCards();
    updateDashboard();
  };
  
  window.handleCustomCardDragStart = function(event, cardIndex) {
    event.dataTransfer.setData('text/plain', JSON.stringify({ type: 'custom-card', index: cardIndex }));
    event.currentTarget.classList.add('dragging');
  };
  
  window.handleCustomCardDragEnd = function(event) {
    event.currentTarget.classList.remove('dragging');
  };
  
  window.handleCardDragOver = function(event, cardIndex) {
    event.preventDefault();
    event.currentTarget.classList.add('drag-over');
  };
  
  window.handleCardDragLeave = function(event, cardIndex) {
    event.currentTarget.classList.remove('drag-over');
  };
  
  window.handleHistoryChartDrop = async function(event, cardIndex, sectionIndex) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    // Try to get data from dragState or dataTransfer
    let pointData = null;
    let wasFromHelper = false;
    
    if (window.dragState && window.dragState.type === 'point') {
      pointData = window.dragState.data;
      wasFromHelper = window.dragState.sourceContainer === 'helper';
    } else {
      // Fallback: read from dataTransfer
      try {
        const transferData = JSON.parse(event.dataTransfer.getData('text/plain'));
        if ((transferData.type === 'point' || transferData.dragType === 'point') && transferData.data) {
          pointData = transferData.data;
          wasFromHelper = true;
        }
      } catch(e) {
        return;
      }
    }
    
    if (!pointData) return;
    
    // Add point history to chart
    if (!window.customCards[cardIndex] || !window.customCards[cardIndex].sections[sectionIndex]) return;
    
    const section = window.customCards[cardIndex].sections[sectionIndex];
    if (section.type !== 'history') return;
    
    if (!section.histories) section.histories = [];
    
    // Discover history for this point
    const pointName = pointData.name || '';
    const historyId = await window.discoverHistoryForPoint(pointName, pointData.ord);
    
    if (historyId) {
      section.histories.push({
        pointName: pointName,
        historyId: historyId,
        data: pointData
      });
      window.saveCustomCards();
      updateDashboard();
      
      // Load and render chart
      setTimeout(function() {
        window.renderHistoryChartInCard(cardIndex, sectionIndex);
      }, 100);
    } else {
      alert('Could not find history for point: ' + pointName);
    }
    
    // Clear drag state
    window.dragState = { item: null, type: null, data: null, sourceContainer: null, sourceIndex: null };
    
    // Remove dragging-active class and close helper modal if item was dragged from it
    if (wasFromHelper) {
      const modal = document.querySelector('.point-helper-modal');
      if (modal) {
        modal.classList.remove('dragging-active');
        setTimeout(function() {
          const closeBtn = modal.querySelector('.point-helper-close');
          if (closeBtn) closeBtn.click();
        }, 100);
      }
    }
  };
  
  window.renderHistoryChartInCard = async function(cardIndex, sectionIndex) {
    const section = window.customCards[cardIndex].sections[sectionIndex];
    if (!section || section.type !== 'history' || !section.histories || section.histories.length === 0) return;
    
    const canvasId = 'card-history-canvas-' + cardIndex + '-' + sectionIndex;
    const canvasEl = document.getElementById(canvasId);
    if (!canvasEl) return;
    
    // Destroy existing chart instance if it exists
    const existingChartId = 'chart-' + canvasId;
    if (window.cardChartInstances && window.cardChartInstances[existingChartId]) {
      window.cardChartInstances[existingChartId].destroy();
      delete window.cardChartInstances[existingChartId];
    }
    if (!window.cardChartInstances) {
      window.cardChartInstances = {};
    }
    
    // Create canvas for Chart.js
    canvasEl.innerHTML = '<canvas id="' + existingChartId + '"></canvas>';
    const ctx = document.getElementById(existingChartId);
    if (!ctx) return;
    
    // Calculate date range (default to last 24 hours)
    const endDate = new Date();
    const startDate = new Date();
    startDate.setHours(startDate.getHours() - 24);
    
    // Query all histories
    const datasets = [];
    const colors = ['#4CAF50', '#2196F3', '#FF9800', '#f44336', '#9C27B0', '#00BCD4'];
    const historyMetadata = {};
    
    for (let i = 0; i < section.histories.length; i++) {
      const hist = section.histories[i];
      try {
        const result = await window.queryHistoryData(hist.historyId, startDate, endDate);
        if (result && result.data && result.data.length > 0) {
          // Store metadata for this point
          historyMetadata[hist.pointName] = {
            isBoolean: result.isBoolean || false,
            statusSummary: result.statusSummary || {},
            hasNonOkStatus: result.hasNonOkStatus || false
          };
          
          // Format data points (x is timestamp in milliseconds, y is value)
          const dataPoints = result.data.map(function(p) {
            return { x: p.x, y: p.y };
          });
          
          const isBoolean = result.isBoolean || false;
          const color = colors[i % colors.length];
          
          datasets.push({
            label: hist.pointName,
            data: dataPoints,
            borderColor: color,
            backgroundColor: color + '40',
            borderWidth: 2,
            fill: true,
            tension: 0.1,
            pointRadius: 0,
            stepped: isBoolean ? true : false,  // Use step chart for boolean values
            spanGaps: true
          });
        }
      } catch(e) {
      }
    }
    
    if (datasets.length > 0 && window.Chart) {
      // Check if we have any boolean datasets
      const hasBooleans = datasets.some(function(d) {
        const label = d.label;
        return historyMetadata[label] && historyMetadata[label].isBoolean;
      });
      
      const chartInstance = new Chart(ctx, {
        type: 'line',
        data: { datasets: datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: {
              type: 'linear',
              position: 'bottom',
              title: { display: true, text: 'Time', color: '#e0e0e0' },
              ticks: {
                color: '#888',
                maxTicksLimit: 10,
                callback: function(value) {
                  const d = new Date(value);
                  return d.toLocaleString([], { month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                }
              },
              grid: { display: true, color: '#333' }
            },
            y: {
              type: 'linear',
              position: 'left',
              title: { display: true, text: hasBooleans ? 'Value / State' : 'Value', color: '#e0e0e0' },
              grid: { display: true, color: '#333' },
              ticks: {
                color: '#888',
                precision: 1,
                callback: function(value) {
                  // Show ON/OFF labels for boolean values if this is a boolean dataset
                  if (hasBooleans) {
                    if (value === 0) return 'OFF';
                    if (value === 1) return 'ON';
                  }
                  return value;
                }
              },
              beginAtZero: hasBooleans ? true : false,
              min: hasBooleans ? -0.1 : undefined,
              max: hasBooleans ? 1.1 : undefined,
              grace: hasBooleans ? 0 : '10%'
            }
          },
          plugins: {
            legend: {
              labels: { color: '#e0e0e0' }
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                title: function(context) {
                  if (context.length > 0) {
                    const d = new Date(context[0].parsed.x);
                    return d.toLocaleString();
                  }
                  return '';
                },
                label: function(context) {
                  const label = context.dataset.label || '';
                  const value = context.parsed.y;
                  const pointName = label;
                  const isBoolean = historyMetadata[pointName] && historyMetadata[pointName].isBoolean;
                  const valueType = isBoolean ? (value === 1 ? ' (ON)' : ' (OFF)') : '';
                  return label + ': ' + value.toFixed(2) + valueType;
                }
              }
            }
          }
        }
      });
      
      // Store chart instance for cleanup
      window.cardChartInstances[existingChartId] = chartInstance;
    } else if (datasets.length === 0) {
      canvasEl.innerHTML = '<div style="color:#888; font-size:12px; padding:20px; text-align:center;">No history data available</div>';
    }
  };
  
  window.discoverHistoryForPoint = async function(pointName, pointOrd) {
    // Use existing history discovery logic similar to toggleInlineHistoryWithDiscovery
    try {
      // Extract equipment name from pointOrd or pointName
      // pointOrd format: station:|slot:/Drivers/BacnetNetwork/EquipmentName/points/PointName
      let equipmentName = '';
      if (pointOrd) {
        const ordStr = pointOrd.toString();
        // Extract equipment name from path
        const match = ordStr.match(/slot:\/.*?\/([^\/]+)\/points\//);
        if (match) {
          equipmentName = match[1];
        } else {
          // Try alternative path format
          const parts = ordStr.split('/');
          const pointsIdx = parts.indexOf('points');
          if (pointsIdx > 0) {
            equipmentName = parts[pointsIdx - 1];
          }
        }
      }
      
      if (!equipmentName) {
        return null;
      }
      
      // Extract point slot name from pointOrd
      let pointSlotName = '';
      if (pointOrd) {
        const ordStr = pointOrd.toString();
        const parts = ordStr.split('/');
        const pointsIdx = parts.indexOf('points');
        if (pointsIdx >= 0 && pointsIdx < parts.length - 1) {
          pointSlotName = parts[pointsIdx + 1];
        }
      }
      
      // Use BQL to discover histories for this equipment (same as toggleInlineHistoryWithDiscovery)
      const escapedEquipment = equipmentName.replace(/'/g, "''");
      const bqlOrd = "station:|slot:/Drivers|bql:select id, slotPath from history:HistoryConfig where slotPath like '%/" + escapedEquipment + "/%'";
      const table = await baja.Ord.make(bqlOrd).get();
      const historyRecords = [];
      
      return new Promise(function(resolve) {
        table.cursor({
          each: function(record) {
            try {
              const historyId = record.get('id').toString();
              const slotPathVal = record.get('slotPath') ? record.get('slotPath').toString() : '';
              
              // Parse the slot path to extract point name
              const pathMatch = slotPathVal.match(/^(.+)\/(Numeric|Boolean|String|Enum)Cov\/historyConfig$/);
              if (pathMatch) {
                const pointPath = pathMatch[1];
                const pathParts = pointPath.split('/');
                const foundPointSlotName = pathParts[pathParts.length - 1];
                
                historyRecords.push({
                  id: historyId,
                  slotPath: slotPathVal,
                  pointSlotName: foundPointSlotName
                });
              }
            } catch(e) {
            }
          },
          after: function() {
            if (historyRecords.length === 0) {
              resolve(null);
              return;
            }
            
            // Try to match the point
            let foundHistory = null;
            const pointSlotNameLower = pointSlotName.toLowerCase();
            const pointNameLower = (pointName || '').toLowerCase().replace(/\s+/g, '');
            
            // Priority 1: Exact match on slot name
            for (let i = 0; i < historyRecords.length; i++) {
              const rec = historyRecords[i];
              if (rec.pointSlotName && rec.pointSlotName.toLowerCase() === pointSlotNameLower) {
                foundHistory = rec.id;
                break;
              }
            }
            
            // Priority 2: Match based on normalized names
            if (!foundHistory) {
              for (let i = 0; i < historyRecords.length; i++) {
                const rec = historyRecords[i];
                const recSlotNameLower = (rec.pointSlotName || '').toLowerCase().replace(/^no_|^cfg_/g, '');
                const normalizedPointName = pointNameLower.replace(/^no_|^cfg_/g, '');
                
                if (recSlotNameLower === normalizedPointName || 
                    recSlotNameLower.includes(normalizedPointName) || 
                    normalizedPointName.includes(recSlotNameLower)) {
                  foundHistory = rec.id;
                  break;
                }
              }
            }
            
            // Priority 3: First available history (fallback)
            if (!foundHistory && historyRecords.length > 0) {
              foundHistory = historyRecords[0].id;
            }
            
            resolve(foundHistory);
          }
        });
      });
    } catch(e) {
      return null;
    }
  };
  
  window.handleSectionDragStart = function(event, cardIndex, sectionIndex) {
    event.dataTransfer.setData('text/plain', JSON.stringify({ type: 'section', cardIndex: cardIndex, sectionIndex: sectionIndex }));
    event.currentTarget.style.opacity = '0.5';
  };
  
  window.handleSectionDragEnd = function(event) {
    event.currentTarget.style.opacity = '1';
  };
  
  window.handleCardPointDragStart = function(event, cardIndex, sectionIndex) {
    const section = window.customCards[cardIndex].sections[sectionIndex];
    event.dataTransfer.setData('text/plain', JSON.stringify({ type: 'card-point', cardIndex: cardIndex, sectionIndex: sectionIndex, data: section.data }));
    event.currentTarget.style.opacity = '0.5';
  };
  
  window.handleCardPointDragEnd = function(event) {
    event.currentTarget.style.opacity = '1';
  };
  
  window.removeSectionFromCard = function(cardIndex, sectionIndex) {
    if (!window.customCards || !window.customCards[cardIndex]) return;
    if (window.customCards[cardIndex].sections) {
      window.customCards[cardIndex].sections.splice(sectionIndex, 1);
      window.saveCustomCards();
      updateDashboard();
    }
  };
  
  // Remove custom point from device type or zone card
  window.removeCustomPointFromCard = function(containerType, containerId, pointIndex) {
    // Initialize if needed
    if (!window.DashboardState.cardCustomizations) {
      window.DashboardState.cardCustomizations = {};
    }
    
    const cardKey = containerType + '_' + containerId;
    if (!window.DashboardState.cardCustomizations[cardKey]) {
      if (window.showToast) window.showToast('Card not found', 'error');
      return;
    }
    
    if (!window.DashboardState.cardCustomizations[cardKey].customPoints) {
      window.DashboardState.cardCustomizations[cardKey].customPoints = [];
    }
    
    const customPoints = window.DashboardState.cardCustomizations[cardKey].customPoints;
    if (pointIndex >= 0 && pointIndex < customPoints.length) {
      customPoints.splice(pointIndex, 1);
      window.DashboardState.save('cardCustomizations');
      updateDashboard();
      if (window.showToast) window.showToast('Point removed from card', 'success');
    } else {
      if (window.showToast) window.showToast('Invalid point index', 'error');
    }
  };
  
  // Update handleCardContentDrop to handle reordering
  window.handleCardContentDrop = function(event, cardIndex) {
    event.preventDefault();
    event.currentTarget.classList.remove('drag-over');
    
    // Try to get data from dragState or dataTransfer
    let pointData = null;
    let wasFromHelper = false;
    
    if (window.dragState && window.dragState.type === 'point') {
      pointData = window.dragState.data;
      wasFromHelper = window.dragState.sourceContainer === 'helper';
    } else {
      // Fallback: read from dataTransfer
      try {
        const transferData = JSON.parse(event.dataTransfer.getData('text/plain'));
        if ((transferData.type === 'point' || transferData.dragType === 'point') && transferData.data) {
          pointData = transferData.data;
          wasFromHelper = true;
        } else if (transferData.type === 'section') {
          // Reorder section within same card
          if (!window.customCards || !window.customCards[cardIndex]) return;
          if (!window.customCards[cardIndex].sections) {
            window.customCards[cardIndex].sections = [];
          }
          if (transferData.cardIndex === cardIndex) {
            const section = window.customCards[transferData.cardIndex].sections[transferData.sectionIndex];
            window.customCards[transferData.cardIndex].sections.splice(transferData.sectionIndex, 1);
            window.customCards[cardIndex].sections.push(section);
            window.saveCustomCards();
            updateDashboard();
          }
          return;
        } else if (transferData.type === 'history') {
          if (!window.customCards || !window.customCards[cardIndex]) return;
          if (!window.customCards[cardIndex].sections) {
            window.customCards[cardIndex].sections = [];
          }
          window.customCards[cardIndex].sections.push({ type: 'history', data: transferData.data });
          window.saveCustomCards();
          updateDashboard();
          return;
        }
      } catch(e) {
        return;
      }
    }
    
    if (!pointData) return;
    
    if (!window.customCards || !window.customCards[cardIndex]) return;
    if (!window.customCards[cardIndex].sections) {
      window.customCards[cardIndex].sections = [];
    }
    
    // Add point to card
    window.customCards[cardIndex].sections.push({ type: 'point', data: JSON.parse(JSON.stringify(pointData)) });
    window.saveCustomCards();
    updateDashboard();
    
    // Clear drag state
    window.dragState = { item: null, type: null, data: null, sourceContainer: null, sourceIndex: null };
    
    // Remove dragging-active class and close helper modal if item was dragged from it
    if (wasFromHelper) {
      const modal = document.querySelector('.point-helper-modal');
      if (modal) {
        modal.classList.remove('dragging-active');
        setTimeout(function() {
          const closeBtn = modal.querySelector('.point-helper-close');
          if (closeBtn) closeBtn.click();
        }, 100);
      }
    }
  };
  
  window.handleZoneCardDragStart = function(event, zone) {
    event.dataTransfer.setData('text/plain', JSON.stringify({ type: 'zone-card', zone: zone }));
    event.currentTarget.classList.add('dragging');
  };
  
  window.handleZoneCardDragEnd = function(event) {
    event.currentTarget.classList.remove('dragging');
  };
  
  window.showCardManager = function() {
    window.toggleFABMenu();
    
    // Load hidden cards
    if (!window.hiddenCards) {
      window.hiddenCards = {};
      try {
        const saved = localStorage.getItem('dashboard_hidden_cards');
        if (saved) window.hiddenCards = JSON.parse(saved);
      } catch(e) {}
    }
    
    const modal = document.createElement('div');
    modal.id = 'cardManagerModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10000; display:flex; align-items:center; justify-content:center;';
    
    let html = '<div style="background:#2d2d2d; padding:30px; border-radius:8px; max-width:700px; width:90%; max-height:80vh; overflow-y:auto;">';
    html += '<h2 style="color:#4CAF50; margin-top:0;">📋 Show/Hide Cards</h2>';
    html += '<p style="color:#888; font-size:12px;">Click to toggle visibility. Changes are saved automatically.</p>';
    
    // Device Type Cards
    html += '<h3 style="color:#888; font-size:14px; margin-top:20px; border-bottom:1px solid #444; padding-bottom:10px;">Device Type Cards</h3>';
    html += '<div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(180px, 1fr)); gap:10px;">';
    
    const global = dashboardConfig?.global || dashboardConfig || {};
    const groups = global.groups || {};
    Object.keys(groups).forEach(function(key) {
      const isHidden = window.hiddenCards['type_' + key] || false;
      const displayName = key.charAt(0).toUpperCase() + key.slice(1);
      html += '<button onclick="window.toggleHiddenCard(\'type_' + key + '\')" style="padding:10px; background:' + (isHidden ? '#1e1e1e' : '#3d5a3d') + '; border:1px solid ' + (isHidden ? '#444' : '#4CAF50') + '; color:' + (isHidden ? '#888' : '#fff') + '; border-radius:4px; cursor:pointer; text-align:left;">';
      html += (isHidden ? '👁️‍🗨️ ' : '✅ ') + displayName;
      html += '</button>';
    });
    html += '</div>';
    
    // Zone Cards
    const byZone = global.byZone || {};
    if (Object.keys(byZone).length > 0) {
      html += '<h3 style="color:#888; font-size:14px; margin-top:20px; border-bottom:1px solid #444; padding-bottom:10px;">Zone Cards</h3>';
      html += '<div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(180px, 1fr)); gap:10px;">';
      Object.keys(byZone).forEach(function(zone) {
        const isHidden = window.hiddenCards['zone_' + zone] || false;
        html += '<button onclick="window.toggleHiddenCard(\'zone_' + zone.replace(/'/g, "\\'") + '\')" style="padding:10px; background:' + (isHidden ? '#1e1e1e' : '#3d5a3d') + '; border:1px solid ' + (isHidden ? '#444' : '#4CAF50') + '; color:' + (isHidden ? '#888' : '#fff') + '; border-radius:4px; cursor:pointer; text-align:left;">';
        html += (isHidden ? '👁️‍🗨️ ' : '✅ ') + zone;
        html += '</button>';
      });
      html += '</div>';
    }
    
    // Custom Cards
    html += '<h3 style="color:#888; font-size:14px; margin-top:20px; border-bottom:1px solid #444; padding-bottom:10px;">Custom Cards</h3>';
    if (!window.customCards || window.customCards.length === 0) {
      html += '<div style="color:#888; padding:10px;">No custom cards yet. Create one from the menu!</div>';
    } else {
      html += '<div style="display:grid; grid-template-columns:repeat(auto-fill, minmax(180px, 1fr)); gap:10px;">';
      window.customCards.forEach(function(card, index) {
        const isHidden = card.hidden || false;
        html += '<button onclick="window.toggleCustomCardHidden(' + index + ')" style="padding:10px; background:' + (isHidden ? '#1e1e1e' : '#3d5a3d') + '; border:1px solid ' + (isHidden ? '#444' : '#4CAF50') + '; color:' + (isHidden ? '#888' : '#fff') + '; border-radius:4px; cursor:pointer; text-align:left;">';
        html += (isHidden ? '👁️‍🗨️ ' : '✅ ') + (card.title || 'Untitled');
        html += '</button>';
      });
      html += '</div>';
    }
    
    html += '<div style="margin-top:30px; display:flex; gap:10px; justify-content:flex-end;">';
    html += '<button onclick="window.showAllCards()" style="background:#4CAF50; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer;">Show All</button>';
    html += '<button onclick="document.getElementById(\'cardManagerModal\').remove()" style="background:#666; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer;">Close</button>';
    html += '</div>';
    html += '</div>';
    
    modal.innerHTML = html;
    document.body.appendChild(modal);
    
    modal.onclick = function(e) {
      if (e.target === modal) modal.remove();
    };
  };
  
  window.toggleHiddenCard = function(cardKey) {
    if (!window.hiddenCards) window.hiddenCards = {};
    window.hiddenCards[cardKey] = !window.hiddenCards[cardKey];
    try {
      localStorage.setItem('dashboard_hidden_cards', JSON.stringify(window.hiddenCards));
    } catch(e) {}
    updateDashboard();
    // Refresh modal
    document.getElementById('cardManagerModal').remove();
    window.showCardManager();
  };
  
  window.toggleCustomCardHidden = function(index) {
    if (!window.customCards || !window.customCards[index]) return;
    window.customCards[index].hidden = !window.customCards[index].hidden;
    window.saveCustomCards();
    updateDashboard();
    // Refresh modal
    document.getElementById('cardManagerModal').remove();
    window.showCardManager();
  };
  
  window.showAllCards = function() {
    window.hiddenCards = {};
    try {
      localStorage.setItem('dashboard_hidden_cards', JSON.stringify({}));
    } catch(e) {}
    if (window.customCards) {
      window.customCards.forEach(function(card) { card.hidden = false; });
      window.saveCustomCards();
    }
    updateDashboard();
    const modal = document.getElementById('cardManagerModal');
    if (modal) {
      modal.remove();
      window.showCardManager();
    }
  };
  
  window.quickHideCard = function(cardKey) {
    window.saveStateForUndo();
    if (!window.hiddenCards) window.hiddenCards = {};
    window.hiddenCards[cardKey] = true;
    window.DashboardState.hiddenCards = window.hiddenCards;
    window.DashboardState.save('hiddenCards');
    updateDashboard();
    window.showToast('Card hidden (use ⚙️ to restore)', 'info');
  };
  
  async function openManageDashboardsModal() {
    if (!currentUser.name) {
      alert('User not loaded. Please refresh the page.');
      return;
    }
    
    if (currentModal) {
      currentModal.remove();
    }
    
    const modal = document.createElement('div');
    modal.id = 'manageDashboardsModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10000; display:flex; align-items:center; justify-content:center;';
    currentModal = modal;
    
    // Determine user role
    const isSuperUser = currentUser.isSuperUser;
    const userRole = isSuperUser ? 'super' : (currentUser.permissions && currentUser.permissions.maintenance ? 'maintenance' : 'regular');
    
    // Get visible dashboards based on permissions
    const dashboards = await getVisibleDashboards(currentUser.name, userRole);
    const assignments = (dashboardConfig && dashboardConfig.dashboardAssignments) || {};
    const allUsers = await getAllUsers();
    
    let html = '<div style="background:#2d2d2d; padding:30px; border-radius:8px; max-width:900px; width:90%; max-height:80vh; overflow-y:auto;">';
    html += '<h2 style="color:#4CAF50; margin-top:0;">Manage Dashboards</h2>';
    
    if (dashboards.length === 0) {
      html += '<p style="color:#888; text-align:center; padding:40px;">No saved dashboards. Click "Save Current" to create one.</p>';
    } else {
      html += '<div style="margin-bottom:20px;">';
      dashboards.forEach(function(dashboard) {
        const isActive = currentUserConfig && currentUserConfig.activeDashboard === dashboard.id;
        const assignment = assignments[dashboard.id] || { owner: dashboard.owner || currentUser.name, assignedTo: [], isPublic: false };
        const canEdit = isSuperUser || (assignment.owner === currentUser.name);
        
        html += `<div style="background:#1e1e1e; padding:15px; border-radius:4px; margin-bottom:15px; border-left:3px solid ${canEdit ? '#4CAF50' : '#666'};">`;
        html += `<div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:10px;">`;
        html += `<div style="flex:1;">`;
        html += `<div style="color:#fff; font-weight:bold; margin-bottom:5px;">${dashboard.name} ${isActive ? '<span style="color:#4CAF50;">(Active)</span>' : ''}</div>`;
        html += `<div style="color:#888; font-size:11px; margin-bottom:5px;">Owner: ${assignment.owner || 'Unknown'}</div>`;
        html += `<div style="color:#888; font-size:11px;">Tabs: ${(dashboard.tabs || []).join(', ') || 'None'}</div>`;
        html += `</div>`;
        html += `<div style="display:flex; gap:5px; flex-wrap:wrap;">`;
        if (!isActive) {
          html += `<button onclick="window.switchToDashboard('${dashboard.id}'); document.getElementById('manageDashboardsModal').remove();" style="background:#2196F3; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; font-size:11px;">Load</button>`;
        }
        if (canEdit) {
          html += `<button onclick="window.openDashboardAssignmentModal('${dashboard.id}')" style="background:#FF9800; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; font-size:11px;">👥 Assign</button>`;
          html += `<button onclick="window.deleteDashboardConfirm('${dashboard.id}')" style="background:#f44336; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; font-size:11px;">Delete</button>`;
        }
        html += `</div>`;
        html += `</div>`;
        
        // Show assigned users
        if (assignment.assignedTo && assignment.assignedTo.length > 0) {
          html += `<div style="margin-top:10px; padding-top:10px; border-top:1px solid #333;">`;
          html += `<div style="color:#888; font-size:11px; margin-bottom:5px;">Assigned to: ${assignment.assignedTo.join(', ')}</div>`;
          if (assignment.isPublic) {
            html += `<div style="color:#4CAF50; font-size:11px;">🌐 Public (visible to all users)</div>`;
          }
          html += `</div>`;
        }
        
        html += `</div>`;
      });
      html += '</div>';
    }
    
    html += '<div style="display:flex; gap:10px;">';
    html += '<button id="closeManageDashboardsBtn" style="background:#666; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; flex:1;">Close</button>';
    html += '</div>';
    html += '</div>';
    
    modal.innerHTML = html;
    document.body.appendChild(modal);
    
    document.getElementById('closeManageDashboardsBtn').onclick = function() {
      modal.remove();
      currentModal = null;
    };
  }
  
  // Open modal to assign dashboard to users (admin only)
  window.openDashboardAssignmentModal = async function(dashboardId) {
    if (!currentUser.isSuperUser) {
      alert('Only administrators can assign dashboards to users.');
      return;
    }
    
    if (currentModal) {
      currentModal.remove();
    }
    
    const modal = document.createElement('div');
    modal.id = 'dashboardAssignmentModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10001; display:flex; align-items:center; justify-content:center;';
    currentModal = modal;
    
    const assignments = (dashboardConfig && dashboardConfig.dashboardAssignments) || {};
    const assignment = assignments[dashboardId] || { owner: currentUser.name, assignedTo: [], isPublic: false };
    const allUsers = await getAllUsers();
    
    // Find dashboard name
    let dashboardName = 'Dashboard';
    const allDashboards = await getAllDashboards();
    const dashboard = allDashboards.find(d => d.id === dashboardId);
    if (dashboard) {
      dashboardName = dashboard.name;
    }
    
    let html = '<div style="background:#2d2d2d; padding:30px; border-radius:8px; max-width:600px; width:90%; max-height:80vh; overflow-y:auto;">';
    html += '<h2 style="color:#FF9800; margin-top:0;">👥 Assign Dashboard: ' + dashboardName + '</h2>';
    html += '<p style="color:#888; font-size:12px; margin-bottom:20px;">Select which users can see this dashboard. Owners can always see their dashboards.</p>';
    
    // Public checkbox
    html += '<div style="background:#1e1e1e; padding:15px; border-radius:4px; margin-bottom:20px;">';
    html += '<label style="color:#fff; display:flex; align-items:center; cursor:pointer;">';
    html += '<input type="checkbox" id="isPublicCheckbox" ' + (assignment.isPublic ? 'checked' : '') + ' style="margin-right:10px; width:18px; height:18px;">';
    html += '<span>🌐 Make public (visible to all users)</span>';
    html += '</label>';
    html += '</div>';
    
    // User list
    html += '<div style="max-height:400px; overflow-y:auto;">';
    allUsers.forEach(function(user) {
      const isAssigned = assignment.assignedTo && assignment.assignedTo.includes(user.name);
      const isOwner = assignment.owner === user.name;
      html += '<div style="background:#1e1e1e; padding:12px; border-radius:4px; margin-bottom:8px; display:flex; align-items:center;">';
      html += '<input type="checkbox" id="user_' + user.name + '" ' + (isAssigned || isOwner ? 'checked' : '') + ' ' + (isOwner ? 'disabled' : '') + ' style="margin-right:12px; width:18px; height:18px;">';
      html += '<label for="user_' + user.name + '" style="color:#fff; cursor:pointer; flex:1;">' + user.name;
      if (isOwner) {
        html += ' <span style="color:#4CAF50; font-size:10px;">(Owner)</span>';
      }
      html += '</label>';
      html += '</div>';
    });
    html += '</div>';
    
    html += '<div style="display:flex; gap:10px; margin-top:20px;">';
    html += '<button id="saveAssignmentBtn" style="background:#4CAF50; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; flex:1;">Save</button>';
    html += '<button id="cancelAssignmentBtn" style="background:#666; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; flex:1;">Cancel</button>';
    html += '</div>';
    html += '</div>';
    
    modal.innerHTML = html;
    document.body.appendChild(modal);
    
    document.getElementById('saveAssignmentBtn').onclick = async function() {
      const isPublic = document.getElementById('isPublicCheckbox').checked;
      const assignedTo = [];
      
      allUsers.forEach(function(user) {
        const checkbox = document.getElementById('user_' + user.name);
        if (checkbox && checkbox.checked && assignment.owner !== user.name) {
          assignedTo.push(user.name);
        }
      });
      
      // Update assignment
      if (!dashboardConfig.dashboardAssignments) {
        dashboardConfig.dashboardAssignments = {};
      }
      dashboardConfig.dashboardAssignments[dashboardId] = {
        owner: assignment.owner,
        assignedTo: assignedTo,
        isPublic: isPublic,
        updatedAt: new Date().toISOString()
      };
      
      await saveConfig(dashboardConfig);
      modal.remove();
      currentModal = null;
      await openManageDashboardsModal();
      await renderDashboardSelector();
      
      if (window.showToast) {
        window.showToast('Dashboard assignments updated', 'success');
      }
    };
    
    document.getElementById('cancelAssignmentBtn').onclick = function() {
      modal.remove();
      currentModal = null;
      openManageDashboardsModal();
    };
  };
  
  window.openManageDashboardsModal = openManageDashboardsModal;
  window.deleteDashboardConfirm = async function(dashboardId) {
    if (confirm('Delete this dashboard?')) {
      await deleteDashboard(currentUser.name, dashboardId);
      await openManageDashboardsModal();
      await renderDashboardSelector();
    }
  };
  
  // --- SUPER USER MANAGEMENT ---
  async function openUserManagementModal() {
    if (!currentUser.isSuperUser) {
      alert('You do not have permission to access user management.');
      return;
    }
    
    if (currentModal) {
      currentModal.remove();
    }
    
    const modal = document.createElement('div');
    modal.id = 'userManagementModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10000; display:flex; align-items:center; justify-content:center;';
    currentModal = modal;
    
    const users = await getAllUsers();
    const presets = dashboardConfig.presets || {};
    
    let html = '<div style="background:#2d2d2d; padding:30px; border-radius:8px; max-width:800px; width:90%; max-height:80vh; overflow-y:auto;">';
    html += '<h2 style="color:#E91E63; margin-top:0;">👥 User Management</h2>';
    
    // Presets section
    html += '<div style="margin-bottom:30px;">';
    html += '<h3 style="color:#fff; margin-bottom:15px;">Presets</h3>';
    html += '<button onclick="window.createPresetModal()" style="background:#4CAF50; color:white; border:none; padding:8px 15px; border-radius:4px; cursor:pointer; margin-bottom:15px;">+ Create Preset</button>';
    html += '<div id="presetsList"></div>';
    html += '</div>';
    
    // Users section
    html += '<div>';
    html += '<h3 style="color:#fff; margin-bottom:15px;">Users</h3>';
    html += '<div id="usersList"></div>';
    html += '</div>';
    
    html += '<div style="margin-top:20px;">';
    html += '<button id="closeUserManagementBtn" style="background:#666; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer;">Close</button>';
    html += '</div>';
    html += '</div>';
    
    modal.innerHTML = html;
    document.body.appendChild(modal);
    
    // Render presets
    const presetsList = document.getElementById('presetsList');
    if (Object.keys(presets).length === 0) {
      presetsList.innerHTML = '<p style="color:#888;">No presets created yet.</p>';
    } else {
      let presetsHtml = '';
      Object.keys(presets).forEach(function(presetId) {
        const preset = presets[presetId];
        presetsHtml += `<div style="background:#1e1e1e; padding:15px; border-radius:4px; margin-bottom:10px;">`;
        presetsHtml += `<div style="color:#fff; font-weight:bold;">${preset.name}</div>`;
        presetsHtml += `<div style="color:#888; font-size:11px; margin-top:5px;">Tabs: ${(preset.tabs || []).join(', ')}</div>`;
        presetsHtml += `</div>`;
      });
      presetsList.innerHTML = presetsHtml;
    }
    
    // Render users
    const usersList = document.getElementById('usersList');
    if (users.length === 0) {
      usersList.innerHTML = '<p style="color:#888;">No users found.</p>';
    } else {
      let usersHtml = '';
      users.forEach(function(username) {
        const userConfig = dashboardConfig.users && dashboardConfig.users[username] || { restrictions: null };
        const assignedPreset = getUserPreset(username);
        usersHtml += `<div style="background:#1e1e1e; padding:15px; border-radius:4px; margin-bottom:10px;">`;
        usersHtml += `<div style="color:#fff; font-weight:bold; margin-bottom:10px;">${username}</div>`;
        usersHtml += `<div style="margin-bottom:10px;">`;
        usersHtml += `<label style="color:#fff; display:block; margin-bottom:5px;">Assign Preset:</label>`;
        usersHtml += `<select id="preset_${username}" style="width:100%; padding:8px; background:#2d2d2d; color:#fff; border:1px solid #444; border-radius:4px;">`;
        usersHtml += `<option value="">-- None --</option>`;
        Object.keys(presets).forEach(function(presetId) {
          const preset = presets[presetId];
          usersHtml += `<option value="${presetId}" ${assignedPreset && assignedPreset.id === presetId ? 'selected' : ''}>${preset.name}</option>`;
        });
        usersHtml += `</select>`;
        usersHtml += `</div>`;
        usersHtml += `<button onclick="window.assignPresetToUserAction('${username}')" style="background:#2196F3; color:white; border:none; padding:6px 12px; border-radius:4px; cursor:pointer; font-size:11px;">Assign Preset</button>`;
        usersHtml += `</div>`;
      });
      usersList.innerHTML = usersHtml;
    }
    
    document.getElementById('closeUserManagementBtn').onclick = function() {
      modal.remove();
      currentModal = null;
    };
  }
  
  window.openUserManagementModal = openUserManagementModal;
  window.assignPresetToUserAction = async function(username) {
    const select = document.getElementById('preset_' + username);
    const presetId = select.value;
    if (presetId) {
      await assignPresetToUser(username, presetId);
      alert('Preset assigned successfully!');
      openUserManagementModal();
    }
  };
  
  window.createPresetModal = function() {
    const name = prompt('Enter preset name:');
    if (!name) return;
    
    const tabsInput = prompt('Enter allowed tabs (comma-separated, e.g., universal,alarms):');
    if (!tabsInput) return;
    
    const tabs = tabsInput.split(',').map(t => t.trim()).filter(t => t);
    
    createPreset({
      name: name,
      tabs: tabs,
      restrictions: tabs
    }).then(function() {
      alert('Preset created!');
      openUserManagementModal();
    });
  };
  
  // Show super user panel if user is super user
  function updateSuperUserPanel() {
    const panel = document.getElementById('superUserPanel');
    if (panel) {
      panel.style.display = currentUser.isSuperUser ? '' : 'none';
    }
  }

  // --- SYNC OPTIONS PANEL ---
  function openSyncOptions() {
    // Close any existing modal
    if (currentModal) {
      currentModal.remove();
    }

    const modal = document.createElement('div');
    modal.id = 'syncOptionsModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10000; display:flex; align-items:center; justify-content:center;';
    currentModal = modal;
    
    const content = document.createElement('div');
    content.style.cssText = 'background:#2d2d2d; padding:30px; border-radius:8px; max-width:500px; width:90%;';
    
    if (!dashboardConfig) {
      dashboardConfig = getDefaultConfig();
    }
    const global = dashboardConfig?.global || dashboardConfig || {};
    const currentMode = global.syncMode || 'manual';
    
    let html = '<h2 style="color:#4CAF50; margin-top:0;">Sync Options</h2>';
    html += '<div style="margin-bottom:20px;">';
    html += '<label style="display:block; color:#888; margin-bottom:10px;">Auto-refresh Discovery:</label>';
    html += `<label style="display:block; padding:10px; background:#1e1e1e; margin-bottom:5px; border-radius:4px; cursor:pointer;">`;
    html += `<input type="radio" name="syncMode" value="manual" ${currentMode === 'manual' ? 'checked' : ''} style="margin-right:10px;"> Manual (default)`;
    html += '</label>';
    html += `<label style="display:block; padding:10px; background:#1e1e1e; margin-bottom:5px; border-radius:4px; cursor:pointer;">`;
    html += `<input type="radio" name="syncMode" value="hourly" ${currentMode === 'hourly' ? 'checked' : ''} style="margin-right:10px;"> Hourly`;
    html += '</label>';
    html += `<label style="display:block; padding:10px; background:#1e1e1e; margin-bottom:5px; border-radius:4px; cursor:pointer;">`;
    html += `<input type="radio" name="syncMode" value="30min" ${currentMode === '30min' ? 'checked' : ''} style="margin-right:10px;"> Every 30 minutes`;
    html += '</label>';
    html += `<label style="display:block; padding:10px; background:#1e1e1e; margin-bottom:5px; border-radius:4px; cursor:pointer;">`;
    html += `<input type="radio" name="syncMode" value="daily" ${currentMode === 'daily' ? 'checked' : ''} style="margin-right:10px;"> Daily at 05:00`;
    html += '</label>';
    html += `<label style="display:block; padding:10px; background:#1e1e1e; margin-bottom:5px; border-radius:4px; cursor:pointer;">`;
    html += `<input type="radio" name="syncMode" value="idle" ${currentMode === 'idle' ? 'checked' : ''} style="margin-right:10px;"> When station idle`;
    html += '</label>';
    html += '</div>';
    html += '<div style="display:flex; gap:10px;">';
    html += '<button id="saveSyncBtn" style="background:#4CAF50; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer; flex:1;">💾 Save</button>';
    html += '<button id="cancelSyncBtn" style="background:#666; color:white; border:none; padding:10px 20px; border-radius:4px; cursor:pointer;">Cancel</button>';
    html += '</div>';
    
    content.innerHTML = html;
    modal.appendChild(content);
    document.body.appendChild(modal);

    // Attach event listeners properly
    document.getElementById('cancelSyncBtn').onclick = function() {
      modal.remove();
      currentModal = null;
    };
    document.getElementById('saveSyncBtn').onclick = async function() {
      const selected = document.querySelector('input[name="syncMode"]:checked');
      if (selected) {
        if (!dashboardConfig.global) dashboardConfig.global = {};
        dashboardConfig.global.syncMode = selected.value;
        await saveConfig(dashboardConfig);
        setupSyncTimer();
        modal.remove();
        currentModal = null;
      }
    };
  }

  window.openSyncOptions = openSyncOptions;

  // Setup sync timer based on mode
  var syncTimer = null;
  function setupSyncTimer() {
    if (syncTimer) clearInterval(syncTimer);
    
    const global = dashboardConfig?.global || dashboardConfig || {};
    let mode = global.syncMode;
    
    // Default to 30 minutes if no mode is set
    if (!mode || mode === 'manual') {
      mode = '30min';
      if (!dashboardConfig.global) dashboardConfig.global = {};
      dashboardConfig.global.syncMode = '30min';
      saveConfig(dashboardConfig).catch(function(err) {
      });
    }
    
    if (mode === '30min') {
      syncTimer = setInterval(function() {
        runFullDiscovery();
      }, 1800000); // 30 minutes
    } else if (mode === 'hourly') {
      syncTimer = setInterval(function() {
        runFullDiscovery();
      }, 3600000); // 1 hour
    } else if (mode === 'daily') {
      // Check every minute if it's 05:00
      syncTimer = setInterval(function() {
        const now = new Date();
        if (now.getHours() === 5 && now.getMinutes() === 0) {
          runFullDiscovery();
        }
      }, 60000); // 1 minute
    } else if (mode === 'idle') {
      // TODO: Check station status/occupancy
    }
    // manual mode: no timer
  }

  // --- 1. INITIALIZATION ---

function init() {
    // Ensure body has correct styling even if init fails
    if (document.body) {
      document.body.style.backgroundColor = "#1a1a1a";
      document.body.style.color = "#e0e0e0";
    }
    
    var statusDiv = document.getElementById('status');
    if (!statusDiv) {
      // Don't return - continue anyway
    } else {
      statusDiv.textContent = 'Initializing Dashboard...';
    }
    
    // Get current user first
    getCurrentUser().then(function(user) {
      // Load dashboard config on init
      return loadConfig().then(function(config) {
        dashboardConfig = config;
        // Migrate old config structure if needed
        if (config.rules && !config.global) {
          dashboardConfig = {
            global: {
              rules: config.rules,
              zones: config.zones || [],
              groups: config.groups || {},
              snapshot: config.snapshot || null,
              lastSync: config.lastSync || null,
              syncMode: config.syncMode || 'manual',
              byType: config.byType || {},
              byZone: config.byZone || {}
            },
            users: {},
            presets: {}
          };
          saveConfig(dashboardConfig).then(function() {
          }).catch(function(err) {
          });
        }
        
        // Ensure global structure exists
        if (!dashboardConfig.global) {
          dashboardConfig.global = getDefaultConfig().global;
        }
        
        // Load user-specific config
        return loadUserConfig(user.name).then(function(userConfig) {
          if (!dashboardConfig.users) dashboardConfig.users = {};
          dashboardConfig.users[user.name] = userConfig;
          currentUserConfig = userConfig;
          
          // Apply user restrictions and render tabs
          try {
            renderTabs();
            updateSuperUserPanel();
            // renderDashboardSelector is async, but we don't need to wait for it
            renderDashboardSelector().catch(function(err) {
            });
          } catch (err) {
          }
          
          // Load active dashboard if set
          if (userConfig.activeDashboard) {
            loadDashboard(user.name, userConfig.activeDashboard).then(function(dashboard) {
              if (dashboard) {
                switchToDashboard(dashboard.id);
              } else {
                // Fallback to default view
                if (config.global?.snapshot && config.global.snapshot.length > 0) {
                  updateDashboard();
                }
                setupSyncTimer();
                loadPxGraphicsState();
                // Update status
                var statusDiv = document.getElementById('status');
                if (statusDiv) statusDiv.textContent = 'Ready';
              }
            }).catch(function(err) {
              // Fallback to default view
              if (config.global?.snapshot && config.global.snapshot.length > 0) {
                updateDashboard();
              }
              setupSyncTimer();
              loadPxGraphicsState();
              var statusDiv = document.getElementById('status');
              if (statusDiv) statusDiv.textContent = 'Ready';
            });
          } else {
            // No active dashboard, use default
            const hasSnapshot = config.global?.snapshot && Array.isArray(config.global.snapshot) && config.global.snapshot.length > 0;
            if (hasSnapshot) {
              updateDashboard();
              var statusDiv = document.getElementById('status');
              if (statusDiv) statusDiv.textContent = 'Ready';
            } else {
              // No snapshot exists - run discovery automatically on first load
              // Add a delay to ensure BajaScript is fully initialized
              console.log('🚀 [INIT] No snapshot found (or empty), scheduling auto-discovery...');
              var statusDiv = document.getElementById('status');
              if (statusDiv) statusDiv.textContent = 'Initializing...';
              
              setTimeout(function() {
                var statusDiv = document.getElementById('status');
                if (statusDiv) statusDiv.textContent = 'Running initial discovery...';
                runFullDiscovery().catch(function(err) {
                  var statusDiv = document.getElementById('status');
                  if (statusDiv) statusDiv.textContent = 'Discovery failed: ' + (err.message || 'Unknown error');
                });
              }, 2000); // Wait 2 seconds for BajaScript to be fully ready
            }
            setupSyncTimer();
            loadPxGraphicsState();
          }
        });
      });
    }).catch(function(err) {
      // Fallback initialization
      var statusDiv = document.getElementById('status');
      if (statusDiv) statusDiv.textContent = 'Initialization error - using fallback mode';
      
      loadConfig().then(function(config) {
        dashboardConfig = config;
        setupSyncTimer();
        loadPxGraphicsState();
        // Update status
        if (statusDiv) statusDiv.textContent = 'Ready (fallback mode)';
      }).catch(function(fallbackErr) {
        if (statusDiv) statusDiv.textContent = 'Initialization failed - please refresh';
      });
    });
    
    // Don't scan equipment yet!
    // Just load the dashboard tab immediately.
    // The dashboard logic will handle the scanning in the background.
    
    // Only populate selectors if we have equipment data
    // Otherwise wait for discovery to complete
    if (dashboardConfig && dashboardConfig.global && dashboardConfig.global.snapshot && dashboardConfig.global.snapshot.length > 0) {
      populateSelectors();
    } else {
      // Initialize with empty dropdowns
      var hDrop = document.getElementById('histUnitDropdown');
      if (hDrop) {
        hDrop.innerHTML = '<option value="">-- Select Unit --</option>';
      }
      var pointDropdown = document.getElementById('histPointDropdown');
      if (pointDropdown) {
        pointDropdown.innerHTML = '<option value="">-- Select Equipment First --</option>';
      }
    }
    
    window.switchTab('universal');
    
      // Get station name and update title/header
    try {
      baja.Ord.make("station:").get().then(function(station) {
        if (!station) {
          return;
        }
        
        // Try getDisplayName first (can be String or Promise)
        var stationNamePromise = null;
        try {
          if (station.getDisplayName) {
            var dn = station.getDisplayName();
            if (dn && typeof dn.then === 'function') {
              // It's a Promise
              stationNamePromise = dn;
            } else if (dn) {
              // It's a String
              stationNamePromise = Promise.resolve(dn.toString());
            }
          }
        } catch(e) {
        }
        
        // Fallback to getName if getDisplayName didn't work
        if (!stationNamePromise) {
          try {
            if (station.getName) {
              var name = station.getName();
              if (name) {
                stationNamePromise = Promise.resolve(name.toString());
              }
            } else if (station.get && station.get('name')) {
              var nameProp = station.get('name');
              if (nameProp) {
                stationNamePromise = Promise.resolve(nameProp.toString());
              }
            }
          } catch(e) {
          }
        }
        
        if (stationNamePromise) {
          stationNamePromise.then(function(name) {
            if (name && name.trim()) {
              const titleEl = document.getElementById('pageTitle');
              const headerEl = document.getElementById('pageHeader');
              if (titleEl) titleEl.textContent = name + ' - Universal Dashboard';
              if (headerEl) headerEl.textContent = name;
            } else {
            }
          }).catch(function(err) {
          });
        } else {
        }
      }).catch(function(err) {
        // Fallback if station name can't be retrieved
      });
    } catch(e) {
    }
    
    statusDiv.textContent = 'Ready.';
  }

  function populateSelectors() {
    var hDrop = document.getElementById('histUnitDropdown');
    var mArea = document.getElementById('multiSelectArea');

    hDrop.innerHTML = '<option value="">-- Select Unit --</option>';
    mArea.innerHTML = '';

    // Use dashboard snapshot if available (from Universal Dashboard discovery)
    // Otherwise fall back to foundEquipment (from legacy scanning)
    var equipmentList = [];
    var equipmentMap = {}; // Use map to deduplicate equipment
    
    if (dashboardConfig && dashboardConfig.global && dashboardConfig.global.snapshot && dashboardConfig.global.snapshot.length > 0) {
      // Use dashboard discovery results
      dashboardConfig.global.snapshot.forEach(function(comp) {
        // Skip system components
        if (comp.systemComponent) return;
        
        // Check if this is already an equipment-level component (has name, originalName, ord)
        if (comp.originalName && comp.ord && !comp.slotPath.includes('/points/')) {
          // This is equipment, not a point
          if (!equipmentMap[comp.originalName]) {
            equipmentMap[comp.originalName] = {
              name: comp.displayName || comp.name || comp.originalName,
              originalName: comp.originalName,
              ord: comp.ord
            };
          }
        } else {
          // This is a point - extract equipment from slotPath
          // Format: Drivers/BacnetNetwork/EquipmentName/points/... or Drivers/BacnetNetwork/EquipmentName/...
          var slotPath = comp.slotPath || '';
          if (!slotPath) return; // Skip if no slotPath
          
          var parts = slotPath.split('/').filter(function(p) { return p; }); // Remove empty parts
          
          // Find the equipment name (usually the 3rd part: Drivers/BacnetNetwork/EquipmentName)
          var equipmentName = null;
          var equipmentOrd = null;
          var equipmentDisplayName = null;
          
          if (parts.length >= 3 && parts[0].toLowerCase() === 'drivers' && parts[1].toLowerCase() === 'bacnetnetwork') {
            // Standard path: Drivers/BacnetNetwork/EquipmentName/...
            equipmentName = parts[2];
            equipmentOrd = 'station:|slot:/Drivers/BacnetNetwork/' + equipmentName;
            equipmentDisplayName = equipmentName; // Will try to get display name below
          } else if (parts.length >= 2) {
            // Fallback: find equipment by looking for 'points' folder
            var pointsIndex = -1;
            for (var i = 0; i < parts.length; i++) {
              if (parts[i].toLowerCase() === 'points') {
                pointsIndex = i;
                break;
              }
            }
            if (pointsIndex > 0) {
              equipmentName = parts[pointsIndex - 1];
              equipmentOrd = 'station:|slot:/' + parts.slice(0, pointsIndex).join('/');
            } else if (parts.length >= 2) {
              // No points folder, assume second-to-last is equipment
              equipmentName = parts[parts.length - 2];
              equipmentOrd = 'station:|slot:/' + parts.slice(0, parts.length - 1).join('/');
            } else {
              equipmentName = parts[parts.length - 1];
              equipmentOrd = 'station:|slot:/' + slotPath.substring(0, slotPath.lastIndexOf('/'));
            }
            equipmentDisplayName = equipmentName;
          }
          
          if (equipmentName && !equipmentMap[equipmentName]) {
            // Try to get display name by looking for other components with same equipment
            var equipmentComp = dashboardConfig.global.snapshot.find(function(c) {
              return (c.originalName === equipmentName) || 
                     (c.slotPath && c.slotPath.endsWith('/' + equipmentName) && !c.slotPath.includes('/points/'));
            });
            if (equipmentComp && equipmentComp.displayName) {
              equipmentDisplayName = equipmentComp.displayName;
            }
            
            equipmentMap[equipmentName] = {
              name: equipmentDisplayName || equipmentName,
              originalName: equipmentName,
              ord: equipmentOrd || 'station:|slot:/Drivers/BacnetNetwork/' + equipmentName
            };
          }
        }
      });
      
      // Convert map to array
      equipmentList = Object.values(equipmentMap);
    } else if (foundEquipment && foundEquipment.length > 0) {
      // Fall back to legacy foundEquipment
      equipmentList = foundEquipment;
    } else {
    }
    
    // Sort by display name
    equipmentList.sort(function(a, b) {
      return (a.name || '').localeCompare(b.name || '', undefined, {numeric: true, sensitivity: 'base'});
    });

    equipmentList.forEach(function(eq) {
      // History
      var optH = document.createElement('option');
      optH.value = eq.ord; 
      optH.textContent = eq.name; // Display name (with tstat location)
      optH.dataset.originalName = eq.originalName || eq.name; // Store original name for BQL queries
      hDrop.appendChild(optH);

      // Multi
      var item = document.createElement('div');
      item.className = 'multi-select-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.gap = '8px';
      var originalName = eq.originalName || eq.name;
      item.innerHTML = '<label style="flex:1; cursor:pointer;"><input type="checkbox" value="' + eq.ord + '" data-name="' + originalName + '"> ' + eq.name + '</label>' +
                       '<button onclick="window.openEquipmentPxView(\'' + originalName + '\')" style="padding:4px 8px; background:#2196F3; color:white; border:none; border-radius:3px; cursor:pointer; font-size:11px;">🖼️ View</button>';
      mArea.appendChild(item);
    });

    var multiFilter = document.getElementById('multiCategoryFilter');
    if (multiFilter) {
      multiFilter.addEventListener('change', function() {
        if(window.currentMultiResults) window.renderMultiTable(window.currentMultiResults);
      });
    }

    // Add event listener for history unit dropdown
    // In populateSelectors function...
    hDrop.addEventListener('change', function() {
      window.updateHistoryPxButton();
      if (!this.value) {
        // Clear point dropdown if no equipment selected
        var pointDropdown = document.getElementById('histPointDropdown');
        if (pointDropdown) {
          pointDropdown.innerHTML = '<option value="">-- Select Equipment First --</option>';
        }
        return;
      }
      
      // Use originalName (slot name) for BQL queries, not displayName
      // The displayName might have apostrophes (like "Collection's Office"), but slot names don't
      var selectedOption = this.selectedOptions[0];
      if (!selectedOption) return;
      
      var equipmentName = selectedOption.dataset.originalName;
      // Fallback: extract from ORD if data attribute not available
      if (!equipmentName && this.value && this.value.includes('/')) {
        var parts = this.value.split('/');
        equipmentName = parts[parts.length - 1];
      }
      // Last fallback: use text (but this might have apostrophes)
      if (!equipmentName) {
        equipmentName = selectedOption.text;
      }
      
      // Don't trigger discovery for placeholder text
      if (!equipmentName || equipmentName === '-- Select Unit --' || equipmentName === 'Loading...') {
        return;
      }
      
      console.log('🔍 [DEBUG] Using equipment name for history discovery:', equipmentName, '(originalName from data attribute)');
      discoverHistoriesForEquipment(equipmentName);
    });
  }
// NEW: Lazy load the equipment list only when needed
  function ensureEquipmentScanned() {
     if (isEquipmentScanned) return Promise.resolve(); // Already done

     var statusDiv = document.getElementById('status');
     statusDiv.textContent = 'Scanning equipment network... (One time)';
     
     return baja.Ord.make('station:|slot:/' + CONFIG.basePath).get()
       .then(function(folder) {
          var equipmentPromises = [];
          folder.getSlots().each(function(slot) {
             var name = slot.getName();
             if (name && name.toLowerCase().indexOf(CONFIG.searchPattern.toLowerCase()) !== -1) {
                var eqOrd = 'station:|slot:/' + CONFIG.basePath + '/' + name;
                // Get display name with tstat location
                var p = getEquipmentDisplayNameWithLocation(eqOrd, name).then(function(displayName) {
                   foundEquipment.push({
                      name: displayName,
                      originalName: name, // Keep original for Px view
                      ord: eqOrd
                   });
                });
                equipmentPromises.push(p);
             }
          });
          
          return Promise.all(equipmentPromises).then(function() {
             foundEquipment.sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'}));
             
             // Populate dropdowns now that we have data
             populateSelectors();
             refreshHistoryPointDropdown();
             
             isEquipmentScanned = true;
             statusDiv.textContent = 'Equipment scan complete. Found ' + foundEquipment.length + ' units.';
             return Promise.resolve();
          });
       })
       .catch(function(err) {
          statusDiv.textContent = "Error scanning equipment.";
          return Promise.reject(err);
       });
  }
  // --- DASHBOARD LOGIC ---
  
  var dashInterval = null;

  // Toggle the Site Graphic (Probe for Home.px -> Fallback to Directory)
  window.toggleSiteGraphic = function() {
     var area = document.getElementById('siteGraphicArea');
     var frame = document.getElementById('siteGraphicFrame');
     var btn = document.getElementById('siteGraphicBtn');
     var label = area.previousElementSibling.querySelector('label');
     var subtext = area.previousElementSibling.querySelector('.sub-text');
     
     if (area.style.display === 'none') {
        // --- EXPANDING ---
        area.style.display = 'block';
        btn.textContent = '🔼 HIDE GRAPHIC';
        label.textContent = '🗺️ SEARCHING...';
        
        // LIST OF CANDIDATES TO CHECK
        // We cannot BQL the file system, so we check likely paths directly.
        // Add your specific deep path example here too!
        var candidates = [
            "file:^px/Home.px",
            "file:^px/home.px",
            "file:^px/Nav.px",
            "file:^px/Start.px",
            "file:^px/Index.px",
            "file:^px/Site.px",
            "file:^px/deploy/ZoneMaps/Home.px", // The specific example you mentioned
            "file:^px/deploy/Home.px"
        ];

        // Helper: Check a list of paths recursively
        var findFirstExisting = function(index) {
            if (index >= candidates.length) {
                // FALLBACK: No specific file found, load the PX directory
                label.textContent = '🗺️ FILE DIRECTORY';
                subtext.textContent = 'Navigate to your home file below';
                frame.src = '/ord/file:^px/'; 
                return;
            }

            var path = candidates[index];
            // Try to resolve the file
            baja.Ord.make(path).get()
                .then(function() {
                    // SUCCESS! The file exists.
                    label.textContent = '🗺️ ' + path.split('/').pop();
                    subtext.textContent = 'Loaded: ' + path;
                    frame.src = '/ord/' + path;
                })
                .catch(function() {
                    // Fail: File not found, check the next one
                    findFirstExisting(index + 1);
                });
        };

        // Start the search
        findFirstExisting(0);

     } else {
        // --- COLLAPSING ---
        area.style.display = 'none';
        btn.textContent = '🔽 SHOW GRAPHIC';
        label.textContent = '🗺️ OVERALL SITE GRAPHIC';
        subtext.textContent = 'Click to load/unload heavy graphic';
        frame.src = 'about:blank'; 
     }
  };

  // Toggle Auto-Refresh Interval
  window.toggleDashAuto = function() {
     var box = document.getElementById('dashAutoRefresh');
     if (box.checked) {
        if (!dashInterval) {
            // 60 seconds interval (Heavy scan)
            dashInterval = setInterval(window.refreshSiteDashboard, 60000);
        }
     } else {
        if (dashInterval) {
            clearInterval(dashInterval);
            dashInterval = null;
        }
     }
  };
// Helper: Invokes standard Auto or Emergency Auto actions on a point
  window.invokeOverrideAction = function(ord, actionName) {
     var label = (actionName === 'emergencyAuto') ? 'Emergency Auto' : 'Auto';
     
     if (!confirm("Confirm Action:\n\nSend '" + label + "' command to this point?")) return;
     
     baja.Ord.make(ord).get()
       .then(function(point) {
           // Verify the point actually has this action slot
           // (WritablePoints usually have 'auto' and 'emergencyAuto')
           if (point.getType().is("control:ControlPoint")) { // Basic check
               // Invoke the action
               // Note: We use invoke() with the slot name
               return point.invoke({ slot: actionName });
           } else {
               throw new Error("Point does not support actions.");
           }
       })
       .then(function() {
           // Success feedback
           alert("✅ Command Sent: " + label);
           // Refresh dashboard after a brief delay to show the point disappearing from list
           setTimeout(window.refreshSiteDashboard, 1500);
       })
       .catch(function(err) {
           alert("❌ Failed to invoke action.\n" + err.message);
       });
  };

window.refreshSiteDashboard = function() {
     var status = document.getElementById('status');
     status.textContent = "Querying dashboard metrics...";
     
     // --- 1. ACTIVE ALARMS ---
     baja.Ord.make("alarm:|bql:select ackState, normalTime order by timestamp DESC").get()
       .then(function(table) {
          var activeCount = 0, unackedCount = 0;
          return table.cursor({
             limit: 5000, 
             each: function(row) {
                 var nTime = row.get('normalTime');
                 var isActive = !nTime || nTime.toString() === 'null';
                 var ack = row.get('ackState');
                 var isUnacked = ack && ack.toString().toLowerCase().indexOf('unacked') > -1;
                 if (isActive) activeCount++;
                 if (isUnacked) unackedCount++;
             },
             after: function() {
                  document.getElementById('dashAlarmCount').textContent = activeCount;
                  document.getElementById('dashTotalAlarms').textContent = activeCount;
                  document.getElementById('dashUnacked').textContent = unackedCount;
                  
                  var card = document.getElementById('dashAlarmCount').parentElement;
                  if(activeCount === 0) card.className = 'dash-card good';
                  else if(activeCount < 5) card.className = 'dash-card warn';
                  else card.className = 'dash-card bad';
                  updateHealthScore(); 
             }
          });
       }).catch(function(e){  });


     // --- 2. DEVICE HEALTH ---
     if (!isEquipmentScanned) {
         document.getElementById('dashScoreText').textContent = "Waiting for initial scan...";
         ensureEquipmentScanned().then(function() { window.refreshSiteDashboard(); });
         return; 
     }
     
     var totalDev = foundEquipment.length;
     document.getElementById('dashTotalEquip').textContent = totalDev;
     
     var devPromises = [];
     var devOffline = 0, devOnline = 0, devStale = 0;

     foundEquipment.forEach(function(eq) {
         var p = baja.Ord.make(eq.ord).get().then(function(comp) {
             var sts = comp.getStatus();
             if (sts.isDown()) devOffline++;
             else if (sts.isStale() || sts.isFault()) { devStale++; devOnline++; } 
             else devOnline++;
         }).catch(function() { devOffline++; });
         devPromises.push(p);
     });

     Promise.all(devPromises).then(function() {
         document.getElementById('dashOffline').textContent = devOffline;
         document.getElementById('dashOnline').textContent = devOnline;
         document.getElementById('dashStale').textContent = devStale;
         
         window.dashTotalDevices = totalDev;
         window.dashOfflineDevices = devOffline;
         updateHealthScore();
     });


     // --- 3. OVERRIDES (UPDATED BUTTONS) ---
     var overrideBql = "station:|slot:/Drivers|bql:select slotPath, displayName, out, status from control:ControlPoint where status.overridden = 'true'";
     
     baja.Ord.make(overrideBql).get()
       .then(function(table) {
           var overrides = [];
           return table.cursor({
               each: function(row) {
                   var path = row.get('slotPath');
                   var disp = row.get('displayName');
                   var val = row.get('out');
                   
                   if (!path) return;
                   var ord = 'station:|' + path;
                   
                   var parts = path.split('/');
                   var equipName = "Unknown";
                   var ptsIdx = parts.indexOf('points');
                   if (ptsIdx > 0) equipName = parts[ptsIdx - 1];
                   else if (parts.length > 2) equipName = parts[parts.length - 2]; 
                   
                   overrides.push({
                       equip: equipName,
                       point: disp,
                       val: val ? val.toString() : 'Null',
                       ord: ord
                   });
               },
               after: function() {
                   var ovTable = document.getElementById('overrideTable').querySelector('tbody');
                   document.getElementById('dashOverrideCount').textContent = overrides.length + " Found";
                   
                   if(overrides.length === 0) {
                       ovTable.innerHTML = '<tr><td colspan="4" style="text-align:center; padding:15px; color:#4CAF50;">✅ No manual overrides detected.</td></tr>';
                   } else {
                       var html = '';
                       overrides.forEach(function(o) {
                           html += '<tr>';
                           html += '<td style="color:#e0e0e0;">' + o.equip + '</td>';
                           html += '<td style="color:#e0e0e0;">' + o.point + '</td>';
                           html += '<td style="color:#AB47BC; font-weight:bold;">' + o.val + '</td>';
                           
                           // --- UPDATED ACTIONS COLUMN ---
                           html += '<td style="display:flex; gap:5px;">';
                           
                           // 1. AUTO Button (Standard Priority 8 Release)
                           html += '<button onclick="window.invokeOverrideAction(\'' + o.ord + '\', \'auto\')" ' + 
                                   'style="background:#4CAF50; color:white; border:none; border-radius:3px; cursor:pointer; padding:4px 8px; font-size:11px; font-weight:bold;" ' +
                                   'title="Release Manual Override (Auto)">AUTO</button>';
                                   
                           // 2. EMERG Button (Priority 1 Release)
                           html += '<button onclick="window.invokeOverrideAction(\'' + o.ord + '\', \'emergencyAuto\')" ' + 
                                   'style="background:#FF9800; color:white; border:none; border-radius:3px; cursor:pointer; padding:4px 8px; font-size:11px; font-weight:bold;" ' +
                                   'title="Release Emergency Override">EMG</button>';
                                   
                           html += '</td>';
                           html += '</tr>';
                       });
                       ovTable.innerHTML = html;
                   }
                   status.textContent = "Dashboard updated.";
               }
           });
       })
       .catch(function(err) {
           document.getElementById('dashOverrideCount').textContent = "BQL Error";
       });
  };

  // Helper: Calculates score
  function updateHealthScore() {
      var alarmCount = parseInt(document.getElementById('dashAlarmCount').textContent) || 0;
      var offline = window.dashOfflineDevices || 0;
      var total = window.dashTotalDevices || 1; 
      if (total === 0) total = 1;

      var score = 100 - ((offline/total)*50) - (alarmCount * 2);
      if(score < 0) score = 0;
      score = Math.round(score);

      var scoreEl = document.getElementById('dashScore');
      scoreEl.textContent = score + "%";

      var healthCard = document.getElementById('cardHealth');
      if(score > 90) { 
         healthCard.className = 'dash-card good'; 
         scoreEl.style.color = '#4CAF50';
         document.getElementById('dashScoreText').textContent = "System Healthy";
      } else if(score > 70) { 
         healthCard.className = 'dash-card warn'; 
         scoreEl.style.color = '#FF9800';
         document.getElementById('dashScoreText').textContent = "Needs Attention";
      } else { 
         healthCard.className = 'dash-card bad'; 
         scoreEl.style.color = '#f44336';
         document.getElementById('dashScoreText').textContent = "Critical Issues";
      }
  }

  // Helper: Calculates score
  function updateHealthScore() {
      var alarmCount = parseInt(document.getElementById('dashAlarmCount').textContent) || 0;
      var offline = window.dashOfflineDevices || 0;
      var total = window.dashTotalDevices || 1; 
      if (total === 0) total = 1;

      var score = 100 - ((offline/total)*50) - (alarmCount * 2);
      if(score < 0) score = 0;
      score = Math.round(score);

      var scoreEl = document.getElementById('dashScore');
      scoreEl.textContent = score + "%";

      var healthCard = document.getElementById('cardHealth');
      if(score > 90) { 
         healthCard.className = 'dash-card good'; 
         scoreEl.style.color = '#4CAF50';
         document.getElementById('dashScoreText').textContent = "System Healthy";
      } else if(score > 70) { 
         healthCard.className = 'dash-card warn'; 
         scoreEl.style.color = '#FF9800';
         document.getElementById('dashScoreText').textContent = "Needs Attention";
      } else { 
         healthCard.className = 'dash-card bad'; 
         scoreEl.style.color = '#f44336';
         document.getElementById('dashScoreText').textContent = "Critical Issues";
      }
  }

  // Helper: Calculates score
  function updateHealthScore() {
      var alarmCount = parseInt(document.getElementById('dashAlarmCount').textContent) || 0;
      var offline = window.dashOfflineDevices || 0;
      var total = window.dashTotalDevices || 1; 
      if (total === 0) total = 1;

      document.getElementById('dashOnline').textContent = total - offline;

      var score = 100 - ((offline/total)*50) - (alarmCount * 2);
      if(score < 0) score = 0;
      score = Math.round(score);

      var scoreEl = document.getElementById('dashScore');
      scoreEl.textContent = score + "%";

      var healthCard = document.getElementById('cardHealth');
      if(score > 90) { 
         healthCard.className = 'dash-card good'; 
         scoreEl.style.color = '#4CAF50';
         document.getElementById('dashScoreText').textContent = "System Healthy";
      } else if(score > 70) { 
         healthCard.className = 'dash-card warn'; 
         scoreEl.style.color = '#FF9800';
         document.getElementById('dashScoreText').textContent = "Needs Attention";
      } else { 
         healthCard.className = 'dash-card bad'; 
         scoreEl.style.color = '#f44336';
         document.getElementById('dashScoreText').textContent = "Critical Issues";
      }
  };

  // Helper: Calculates score whenever data comes in
  function updateHealthScore() {
      var alarmCount = parseInt(document.getElementById('dashAlarmCount').textContent) || 0;
      var offline = window.dashOfflineDevices || 0;
      var total = window.dashTotalDevices || 1; 
      if (total === 0) total = 1;

      // Update Online Count
      document.getElementById('dashOnline').textContent = total - offline;

      // Score Formula
      var score = 100 - ((offline/total)*50) - (alarmCount * 2);
      if(score < 0) score = 0;
      score = Math.round(score);

      var scoreEl = document.getElementById('dashScore');
      scoreEl.textContent = score + "%";

      var healthCard = document.getElementById('cardHealth');
      if(score > 90) { 
         healthCard.className = 'dash-card good'; 
         scoreEl.style.color = '#4CAF50';
         document.getElementById('dashScoreText').textContent = "System Healthy";
      } else if(score > 70) { 
         healthCard.className = 'dash-card warn'; 
         scoreEl.style.color = '#FF9800';
         document.getElementById('dashScoreText').textContent = "Needs Attention";
      } else { 
         healthCard.className = 'dash-card bad'; 
         scoreEl.style.color = '#f44336';
         document.getElementById('dashScoreText').textContent = "Critical Issues";
      }
  }

  // Helper: Calculates score whenever data comes in
  function updateHealthScore() {
      var alarmCount = parseInt(document.getElementById('dashAlarmCount').textContent) || 0;
      var offline = window.dashOfflineDevices || 0;
      var total = window.dashTotalDevices || 1; 
      if (total === 0) total = 1;

      // Update Online Count
      document.getElementById('dashOnline').textContent = total - offline;

      // Score Formula
      var score = 100 - ((offline/total)*50) - (alarmCount * 2);
      if(score < 0) score = 0;
      score = Math.round(score);

      var scoreEl = document.getElementById('dashScore');
      scoreEl.textContent = score + "%";

      var healthCard = document.getElementById('cardHealth');
      if(score > 90) { 
         healthCard.className = 'dash-card good'; 
         scoreEl.style.color = '#4CAF50';
         document.getElementById('dashScoreText').textContent = "System Healthy";
      } else if(score > 70) { 
         healthCard.className = 'dash-card warn'; 
         scoreEl.style.color = '#FF9800';
         document.getElementById('dashScoreText').textContent = "Needs Attention";
      } else { 
         healthCard.className = 'dash-card bad'; 
         scoreEl.style.color = '#f44336';
         document.getElementById('dashScoreText').textContent = "Critical Issues";
      }
  };
  // --- 2. CORE LOGIC ---

  function matchComponentToColumn(comp) {
    var name = comp.getName();
    var display = "";
    try { 
       if(comp.getDisplayName) {
          var dn = comp.getDisplayName();
          // Handle both String and Promise return types
          if (dn && typeof dn.then === 'function') {
             // It's a Promise - can't use synchronously, skip for now
             display = "";
          } else {
             display = dn || "";
          }
       }
    } catch(e){}
    for(var i=0; i<globalColumns.length; i++) {
       var col = globalColumns[i];
       for(var j=0; j<col.match.length; j++) {
          var m = col.match[j].toLowerCase();
          if (name.toLowerCase() === m || display.toLowerCase() === m || name.toLowerCase().indexOf(m) > -1) {
             return col;
          }
       }
    }
    return null;
  }

  // Helper function to get tstat location point value from equipment
  function getTstatLocationValue(eqOrd) {
     // Check if this is a system component that won't have Monitor folder
     const systemNames = ['ping', 'ackAlarm', 'upload', 'download', 'asyncPing', 'submitDeviceManagerJob', 
       'lookupDeviceById', 'lookupDeviceByAddress', 'lookupDeviceOrdById', 'lookupDeviceOrdByAddress',
       'displayNames', 'privateTransferResultBlockFlag', 'shouldSupportFaultForMultiState', 
       'uploadOnStart', 'writeOnFacetChange'];
     const eqName = eqOrd.split('/').pop() || '';
     const isSystemComponent = systemNames.some(sys => eqName.toLowerCase().includes(sys.toLowerCase()));
     
     if (isSystemComponent) {
       return Promise.resolve(null);
     }
     
     return baja.Ord.make(eqOrd + '/points/Monitor').get()
        .then(function(monitorFolder) {
           var tstatLocationOrd = null;
           monitorFolder.getSlots().each(function(slot) {
              var slotName = slot.getName().toLowerCase();
              if (slotName === 'tstatlocation' || slotName === 'tstat_location' || slotName === 'location') {
                 tstatLocationOrd = eqOrd + '/points/Monitor/' + slot.getName();
              }
           });
           if (!tstatLocationOrd) return Promise.resolve(null);
           return baja.Ord.make(tstatLocationOrd).get()
              .then(function(tstatPoint) {
                 try {
                    // First try: get the 'out' property and access its 'value' property if it exists
                    var outVal = tstatPoint.get('out');
                    if (outVal !== undefined && outVal !== null) {
                       // If it's a StatusValue or similar, try to get just the value property
                       if (outVal.get && outVal.get('value') !== undefined) {
                          var simpleValue = outVal.get('value');
                          if (simpleValue !== undefined && simpleValue !== null) {
                             // Simple values can be converted to string directly
                             return simpleValue.toString ? simpleValue.toString() : String(simpleValue);
                          }
                       }
                       // If it has a direct 'value' property (not a method)
                       if (outVal.value !== undefined && outVal.value !== null) {
                          return String(outVal.value);
                       }
                    }
                    
                    // Second try: Use getDisplay('out') to get just the value without status (per BajaScript docs)
                    if (tstatPoint.getDisplay) {
                       var displayVal = tstatPoint.getDisplay('out');
                       // getDisplay() can return a Promise or String
                       if (displayVal && typeof displayVal.then === 'function') {
                          return displayVal.then(function(str) {
                             return str || null;
                          });
                       } else {
                          return displayVal || null;
                       }
                    }
                    
                    // Third try: getOutDisplay() if available
                    if (tstatPoint.getOutDisplay) {
                       var displayVal = tstatPoint.getOutDisplay();
                       if (displayVal && typeof displayVal.then === 'function') {
                          return displayVal.then(function(str) {
                             return str || null;
                          });
                       } else {
                          return displayVal || null;
                       }
                    }
                    
                    // Last resort: get the value and strip status if present
                    if (outVal !== undefined && outVal !== null) {
                       var str = outVal.toString();
                       // Remove status like {ok}, {down}, etc.
                       str = str.replace(/\{[^}]*\}/g, '').trim();
                       return str || null;
                    }
                 } catch(e) {}
                 return null;
              })
              .catch(function(err) { 
                 // Silently ignore errors - point may not exist
                 return null; 
              });
        })
        .catch(function(err) { 
           // Silently ignore errors - Monitor folder may not exist (expected for many equipment types)
           return null; 
        });
  }

  // Helper function to get equipment display name with tstat location prefix
  function getEquipmentDisplayNameWithLocation(eqOrd, eqName) {
     return baja.Ord.make(eqOrd).get()
        .then(function(equipment) {
           var displayName = eqName;
           try {
              if (equipment.getDisplayName) {
                 var dn = equipment.getDisplayName();
                 // Handle both String and Promise return types
                 if (dn && typeof dn.then === 'function') {
                    // It's a Promise - need to wait for it
                    return dn.then(function(resolvedName) {
                       displayName = resolvedName || eqName;
                       return getTstatLocationValue(eqOrd).then(function(locationValue) {
                          if (locationValue && locationValue.trim() !== '') {
                             return locationValue + ' - ' + displayName;
                          }
                          return displayName;
                       });
                    });
                 } else {
                    displayName = dn || eqName;
                 }
              }
           } catch(e) {}
           
           // Get tstat location value
           return getTstatLocationValue(eqOrd).then(function(locationValue) {
              if (locationValue && locationValue.trim() !== '') {
                 return locationValue + ' - ' + displayName;
              }
              return displayName;
           });
        })
        .catch(function() {
           // Fallback: try to get location even if equipment fetch fails
           return getTstatLocationValue(eqOrd).then(function(locationValue) {
              if (locationValue && locationValue.trim() !== '') {
                 return locationValue + ' - ' + eqName;
              }
              return eqName;
           });
        });
  }

  function fetchEquipmentData(eqOrd, eqName) {
     var monitorOrd = eqOrd + '/points/Monitor';
     return baja.Ord.make(monitorOrd).get()
       .then(function(folder) {
          var foundData = [];
          var scanPromises = [];
          folder.getSlots().each(function(slot) {
             var slotOrd = monitorOrd + '/' + slot.getName();
             var p = baja.Ord.make(slotOrd).get().then(function(comp) {
                var hasVal = false;
                try { hasVal = (comp.get('out') !== undefined || comp.get('value') !== undefined); } catch(e){}
                if(!hasVal) return;
                knownAvailablePoints.add(slot.getName());
                var col = matchComponentToColumn(comp);
                if (col) {
                   var displayName = col.label;
                   try {
                      if(comp.getDisplayName) {
                         var dn = comp.getDisplayName();
                         // Handle both String and Promise return types
                         if (dn && typeof dn.then === 'function') {
                            // It's a Promise - resolve it
                            return dn.then(function(resolvedName) {
                               foundData.push({ 
                                  colLabel: (resolvedName && resolvedName !== comp.getName()) ? resolvedName : col.label, 
                                  slotName: slot.getName(), 
                                  ord: slotOrd, 
                                  component: comp 
                               });
                            }).catch(function() {
                               // Fallback to col.label if Promise fails
                               foundData.push({ colLabel: col.label, slotName: slot.getName(), ord: slotOrd, component: comp });
                            });
                         } else {
                            if(dn && dn !== comp.getName()) displayName = dn;
                            foundData.push({ colLabel: displayName, slotName: slot.getName(), ord: slotOrd, component: comp });
                         }
                      } else {
                         foundData.push({ colLabel: col.label, slotName: slot.getName(), ord: slotOrd, component: comp });
                      }
                   } catch(e){
                      foundData.push({ colLabel: col.label, slotName: slot.getName(), ord: slotOrd, component: comp });
                   }
                }
             }).catch(function(e){});
             scanPromises.push(p);
          });
          return Promise.all(scanPromises).then(function() {
             // Get equipment display name with tstat location
             return getEquipmentDisplayNameWithLocation(eqOrd, eqName).then(function(displayName) {
                return { name: displayName, originalName: eqName, ord: eqOrd, data: foundData };
             });
          });
       });
  }

  // Fetch ALL points from equipment (not filtered by globalColumns)
  function fetchAllEquipmentPoints(eqOrd, eqName) {
     var monitorOrd = eqOrd + '/points/Monitor';
     return baja.Ord.make(monitorOrd).get()
       .then(function(folder) {
          var foundData = [];
          var scanPromises = [];
          folder.getSlots().each(function(slot) {
             var slotOrd = monitorOrd + '/' + slot.getName();
             var p = baja.Ord.make(slotOrd).get().then(function(comp) {
                var hasVal = false;
                try { hasVal = (comp.get('out') !== undefined || comp.get('value') !== undefined); } catch(e){}
                if(!hasVal) return;

                var slotName = slot.getName();
                var displayName = '';
                var displayNamePromise = Promise.resolve(slotName);
                
                try { 
                   if(comp.getDisplayName) {
                      var dn = comp.getDisplayName();
                      // Handle both String and Promise return types
                      if (dn && typeof dn.then === 'function') {
                         // It's a Promise - resolve it
                         displayNamePromise = dn.then(function(resolvedName) {
                            return resolvedName || slotName;
                         }).catch(function() {
                            return slotName;
                         });
                      } else {
                         displayName = dn || slotName;
                         displayNamePromise = Promise.resolve(displayName);
                      }
                   }
                } catch(e){}

                // Auto-filter and check hidden points inside the promise
                displayNamePromise.then(function(resolvedDisplayName) {
                   // Auto-filter points matching patterns (Cfg_*, *Custom*, no_*) unless displayName changed
                   if (shouldAutoFilterPoint(slotName, resolvedDisplayName)) {
                      return; // Skip this point
                   }
                   
                   // Check if point is hidden
                   if (!window.hiddenPoints) {
                     window.hiddenPoints = {};
                     try {
                       const saved = localStorage.getItem('dashboard_hidden_points');
                       if (saved) {
                         window.hiddenPoints = JSON.parse(saved);
                       }
                     } catch(e) {}
                   }
                   const pointKey = slotName.toLowerCase();
                   if (window.hiddenPoints[pointKey]) {
                     return;
                   }
                   
                   // Add ALL points, not just ones matching globalColumns
                   foundData.push({
                      colLabel: resolvedDisplayName || slotName,
                      slotName: slotName,
                      ord: slotOrd,
                      component: comp
                   });
                }).catch(function() {
                   // If displayName resolution fails, still check auto-filter with slotName
                   if (!shouldAutoFilterPoint(slotName, slotName)) {
                      // Check hidden points
                      if (!window.hiddenPoints) {
                        window.hiddenPoints = {};
                        try {
                          const saved = localStorage.getItem('dashboard_hidden_points');
                          if (saved) {
                            window.hiddenPoints = JSON.parse(saved);
                          }
                        } catch(e) {}
                      }
                      const pointKey = slotName.toLowerCase();
                      if (!window.hiddenPoints[pointKey]) {
                        foundData.push({
                           colLabel: slotName,
                           slotName: slotName,
                           ord: slotOrd,
                           component: comp
                        });
                      }
                   }
                });
             }).catch(function(e){});
             scanPromises.push(p);
          });
          return Promise.all(scanPromises).then(function() {
             // Get equipment display name with tstat location
             return getEquipmentDisplayNameWithLocation(eqOrd, eqName).then(function(displayName) {
                return { name: displayName, originalName: eqName, ord: eqOrd, data: foundData };
             });
          });
       });
  }

  // --- 3. MULTI VIEW ---

  window.loadMultiMatrix = function() {
     var checks = document.querySelectorAll('#multiSelectArea input:checked');
     if(checks.length === 0) { alert("Select at least one unit."); return; }
     var status = document.getElementById('status');
     status.textContent = 'Fetching data...';
     unsubscribe();
     document.getElementById('addPointArea').style.display = 'none';
     var promises = [];
     checks.forEach(function(chk) { promises.push(fetchEquipmentData(chk.value, chk.dataset.name)); });
     Promise.all(promises).then(function(results) {
        window.currentMultiResults = results;
        renderMultiTable(results);
        populateAddDropdown();
        document.getElementById('addPointArea').style.display = 'flex';
        status.textContent = 'Matrix Loaded.';
     });
  };

  window.renderMultiTable = function(results) {
     var div = document.getElementById('multiTableArea');
     if(globalColumns.length === 0) { div.innerHTML = '<div class="status">No columns defined.</div>'; return; }

     unsubscribe();

     var categoryFilter = document.getElementById('multiCategoryFilter').value;

     var filteredColumns = [];
     globalColumns.forEach(function(col, idx) {
        if (categoryFilter !== 'all') {
           var classification = window.classifyPoint(col.label);
           if (classification.category !== categoryFilter &&
               !(categoryFilter === 'power' && classification.category === 'energy')) {
              return; 
           }
        }
        filteredColumns.push({ col: col, originalIdx: idx });
     });

     if (filteredColumns.length === 0) {
        div.innerHTML = '<div class="status">No points match the selected filter.</div>';
        return;
     }

     var html = '<div class="table-container"><table class="live-table"><thead><tr><th>Unit Name</th>';
     filteredColumns.forEach(function(item) {
        html += '<th>' + item.col.label + ' <button class="remove-header-btn" onclick="window.removeColumn('+item.originalIdx+')">×</button></th>';
     });
     html += '<th>Actions</th>';
     html += '</tr></thead><tbody>';
     
     // Load hidden points filter
     if (!window.hiddenPoints) {
       window.hiddenPoints = {};
       try {
         const saved = localStorage.getItem('dashboard_hidden_points');
         if (saved) {
           window.hiddenPoints = JSON.parse(saved);
         }
       } catch(e) {}
     }
     
     var subList = [];
     results.forEach(function(res, rowIdx) {
        // --- UPDATED NAME CELL WITH BUTTON ---
        html += '<tr>';
        html += '<td class="name-cell" style="white-space:nowrap;">';
        html += '<div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">';
        html += '<span>' + res.name + '</span>';
        var originalName = res.originalName || res.name;
        html += '<button onclick="window.openEquipmentPxView(\'' + originalName + '\')" title="View Graphic" style="padding:2px 6px; background:#2196F3; color:white; border:none; border-radius:3px; cursor:pointer; font-size:10px;">🖼️</button>';
        html += '</div></td>';
        // -------------------------------------
        
        filteredColumns.forEach(function(item, colIdx) {
           var ptData = res.data.find(d => d.colLabel === item.col.label);
           if(ptData) {
              // Check if point is hidden
              const pointKey = (ptData.slotName || ptData.colLabel || '').toLowerCase();
              if (window.hiddenPoints[pointKey]) {
                html += '<td class="val-cell missing">--</td>';
                return;
              }
              
              var cellId = 'm_' + rowIdx + '_' + colIdx;
              html += '<td class="val-cell" id="'+cellId+'">...</td>';
              subList.push({ id: cellId, ord: ptData.ord });
           } else { html += '<td class="val-cell missing">--</td>'; }
        });
        
        // Actions column with chart button
        html += '<td style="padding:4px;">';
        // Reuse originalName from above (line 5479)
        html += '<button onclick="window.addPointToChartFromMultiView(\'' + originalName.replace(/'/g, "\\'") + '\', \'' + rowIdx + '\')" style="padding:2px 6px; font-size:10px; background:#2196f3; color:white; border:none; border-radius:2px; cursor:pointer;" title="Add all points to chart">📊 Chart</button>';
        html += '</td>';
        html += '</tr>';
     });
     html += '</tbody></table></div>';
     div.innerHTML = html;
     setupSubscriptions(subList);
  }


  // --- 4. ENHANCED HISTORY LOGIC ---

  // Point patterns defined in chart-utils.js as window.customPointPatterns

  var historyCache = {}; // Cache discovered histories
  var selectedHistoryPoints = []; // Array of {equipment, pointName, historyId, displayName}
  var historyQueryResults = {}; // Store fetched history data
  var historyMetadata = {}; // Store metadata like isBoolean, currentStatus for each history
  var pointStatusCache = {}; // Cache current point status for visual indicators

  function refreshHistoryPointDropdown() {
      var sel = document.getElementById('histPointDropdown');
      var dropdown = document.getElementById('histUnitDropdown');
      if (!dropdown || !dropdown.selectedOptions || dropdown.selectedOptions.length === 0) {
          sel.innerHTML = '<option value="">-- Select Equipment First --</option>';
          return;
      }
      
      var selectedOption = dropdown.selectedOptions[0];
      var equipmentName = selectedOption.text;
      
      // Check if it's the placeholder option
      if (!equipmentName || equipmentName === '-- Select Unit --' || equipmentName === 'Loading...' || !dropdown.value) {
          sel.innerHTML = '<option value="">-- Select Equipment First --</option>';
          return;
      }

      sel.innerHTML = '<option value="">-- Select Point --</option>';

      // Get originalName from data attribute (for BQL queries)
      // The cache is keyed by originalName (slot name) because that's what discoverHistoriesForEquipment uses
      var originalName = selectedOption.dataset.originalName;
      if (!originalName && dropdown.value && dropdown.value.includes('/')) {
        // Fallback: extract from ORD
        var parts = dropdown.value.split('/');
        originalName = parts[parts.length - 1];
      }
      if (!originalName) {
        originalName = equipmentName; // Last fallback
      }
      
      // If equipment selected, show only points with history
      // Cache is keyed by originalName (slot name) - this is what discoverHistoriesForEquipment uses
      if (historyCache[originalName]) {
          var cachedHistories = historyCache[originalName];
          cachedHistories.forEach(function(hist) {
              var opt = document.createElement('option');
              opt.value = hist.historyId;
              opt.textContent = hist.pointName;
              sel.appendChild(opt);
          });
      } else if (originalName && originalName !== equipmentName) {
          // Equipment selected but no history cache - trigger discovery using originalName
          discoverHistoriesForEquipment(originalName);
      } else if (equipmentName) {
          // Fallback: try with equipmentName if originalName not available
          discoverHistoriesForEquipment(equipmentName);
      } else {
      }
  }

  function discoverHistoriesForEquipment(equipmentName) {
      var status = document.getElementById('status');
      status.textContent = "Discovering histories for " + equipmentName + "...";
      status.className = "status";

      // Query history configs for this equipment
      // Use path delimiters to match exact equipment name (HP6 not HP60-65)
      // Note: equipmentName should be the original slot name (not displayName with apostrophes)
      // If it still has apostrophes, escape them for BQL (SQL-style: ' becomes '')
      const escapedEquipmentName = equipmentName.replace(/'/g, "''");
      var bqlOrd = "station:|slot:/Drivers|bql:select id, slotPath from history:HistoryConfig where slotPath like '%/" + escapedEquipmentName + "/%'";
      baja.Ord.make(bqlOrd).get().then(function(table) {
          var historiesTemp = [];

          // First pass: collect all history configs
          var seenHistoryIds = {};
          // Don't return the cursor - call it directly like the old version
          table.cursor({
              each: function(record) {
                  try {
                      var historyId = record.get('id').toString();
                      var slotPath = record.get('slotPath').toString();

                      // Skip if we've already seen this historyId
                      if (seenHistoryIds[historyId]) {
                          return;
                      }
                      seenHistoryIds[historyId] = true;

                      // Extract point path (parent of historyConfig)
                      var pathMatch = slotPath.match(/^(.+)\/(Numeric|Boolean|String|Enum)Cov\/historyConfig$/);
                      if (pathMatch) {
                          var pointPath = pathMatch[1];
                          historiesTemp.push({
                              historyId: historyId,
                              slotPath: slotPath,
                              pointPath: pointPath
                          });
                      }
                  } catch (err) {
                  }
              },
              after: function() {
                  // Second pass: get displayNames from actual components
                  getDisplayNamesForHistories(historiesTemp, equipmentName);
              },
              limit: 10000
          });
      }).catch(function(err) {
          status.className = "status error";
          status.textContent = "Error discovering histories: " + err.message;
      });
  }

  function getDisplayNamesForHistories(historiesTemp, equipmentName) {
      var status = document.getElementById('status');
      var histories = [];
      var completed = 0;

      if (historiesTemp.length === 0) {
          historyCache[equipmentName] = [];
          refreshHistoryPointDropdown();
          status.textContent = "No histories found for " + equipmentName;
          return;
      }

      historiesTemp.forEach(function(hist) {
          // The pointPath already starts with "slot:/" so just add "station:|"
          var fullOrd = 'station:|' + hist.pointPath;

          baja.Ord.make(fullOrd).get()
              .then(function(component) {
                  var displayName = hist.pointPath.split('/').pop(); // Default to path name
                  
                  // Handle getDisplayName - can be String or Promise
                  var displayNamePromise = Promise.resolve(displayName);
                  
                  try {
                      // Try to get display name
                      if (component.getDisplayName) {
                          var dn = component.getDisplayName();
                          if (dn && typeof dn.then === 'function') {
                              // It's a Promise
                              displayNamePromise = dn;
                          } else if (dn) {
                              // It's a String
                              displayNamePromise = Promise.resolve(dn.toString());
                          }
                      } else if (component.get && component.get('displayName')) {
                          displayName = component.get('displayName').toString();
                          displayNamePromise = Promise.resolve(displayName);
                      }
                  } catch (e) {
                  }

                  return displayNamePromise.then(function(resolvedDisplayName) {
                      // Auto-filter points matching patterns (Cfg_*, *Custom*, no_*) unless displayName changed
                      var slotName = hist.pointPath.split('/').pop();
                      if (shouldAutoFilterPoint(slotName, resolvedDisplayName || displayName)) {
                          console.log('🔍 [DEBUG] Auto-filtering history point:', slotName, '(matches filter pattern)');
                          return; // Skip this history
                      }
                      
                      histories.push({
                          pointName: resolvedDisplayName || displayName,
                          historyId: hist.historyId,
                          slotPath: hist.slotPath,
                          pointPath: hist.pointPath
                      });
                  });
              })
              .catch(function(err) {
                  console.log('Skipping point (could not resolve):', hist.pointPath);
                  // Don't show error - some points may not be accessible
              })
              .finally(function() {
                  completed++;
                  if (completed === historiesTemp.length) {
                      // Remove duplicates based on historyId
                      var seen = {};
                      var uniqueHistories = [];
                      histories.forEach(function(hist) {
                          if (!seen[hist.historyId]) {
                              seen[hist.historyId] = true;
                              uniqueHistories.push(hist);
                          } else {
                          }
                      });

                      // Sort by display name
                      uniqueHistories.sort(function(a, b) {
                          return a.pointName.localeCompare(b.pointName);
                      });
                      historyCache[equipmentName] = uniqueHistories;
                      refreshHistoryPointDropdown();
                      status.textContent = "Found " + uniqueHistories.length + " histories for " + equipmentName;
                      status.className = "status";
                  }
              });
      });
  }

  window.loadHistoryChart = function() {
      var uSelect = document.getElementById('histUnitDropdown');
      var pSelect = document.getElementById('histPointDropdown');
      var period = document.getElementById('histPeriod').value;

      if(!uSelect.value || !pSelect.value) {
          alert("Please select a Unit and a Point.");
          return;
      }

      var status = document.getElementById('status');
      var historyId = pSelect.value; // The value is now the historyId
      var pointName = pSelect.selectedOptions[0].text;

      status.textContent = "Querying history: " + pointName + "...";

      // Calculate date range from period
      var endDate = new Date();
      var startDate = new Date();

      if (period === 'last24h') {
          startDate.setHours(startDate.getHours() - 24);
      } else if (period === 'last48h') {
          startDate.setHours(startDate.getHours() - 48);
      } else if (period === 'lastWeek') {
          startDate.setDate(startDate.getDate() - 7);
      }

      // Query history using the historyId
      queryHistoryData(historyId, startDate, endDate)
          .then(function(result) {
              var dataPoints = result.data || result; // Handle both old and new format
              updateChart(dataPoints, pointName);
              status.textContent = "Chart Loaded. " + dataPoints.length + " records.";
              status.className = "status";
          })
          .catch(function(err) {
              status.className = "status error";
              status.textContent = "History Error: " + err.message;
          });
  };

  function queryHistoryData(historyId, startDate, endDate) {
      // The historyId from BQL is the ID field from history:HistoryConfig
      // This ID is the history reference path like "/MJHOptimizer1/Shainberg$20North$20HP11$20Space$20Temp"
      // We need to use it with the history: scheme to query the actual history data
      var historyOrd;
      
      // Ensure historyId is a string
      if (historyId && typeof historyId !== 'string') {
        if (historyId.toString && historyId.toString() !== '[object Object]') {
          historyId = historyId.toString();
        } else if (historyId.encodeToString) {
          historyId = historyId.encodeToString();
        } else {
          return Promise.resolve({ data: [], isBoolean: false, statusSummary: {}, hasNonOkStatus: false });
        }
      }
      
      if (!historyId || historyId.length < 3) {
        return Promise.resolve({ data: [], isBoolean: false, statusSummary: {}, hasNonOkStatus: false });
      }
      
      if (historyId.startsWith('/')) {
        // It's a history ID path - use history: scheme
        // The history: scheme requires the ID without the leading slash
        historyOrd = "history:" + historyId.substring(1);
      } else if (historyId.includes('/')) {
        // Already formatted history ID
        historyOrd = "history:" + historyId;
      } else {
        // Assume it's already a properly formatted history ID
        historyOrd = "history:" + (historyId || '').replace(/ /g, '$20');
      }
      return baja.Ord.make(historyOrd).get().then(function(history) {
          if (!history) {
            return Promise.resolve({ data: [], isBoolean: false, statusSummary: {}, hasNonOkStatus: false });
          }
          return new Promise(function(resolve, reject) {
              var rawDataPoints = [];
              var startMillis = startDate.getTime();
              var endMillis = endDate.getTime();

              console.log('Filtering data between:', new Date(startMillis).toISOString(), 'and', new Date(endMillis).toISOString());

              var totalRecords = 0;
              var recordsInRange = 0;
              var lastKnownValue = null;
              var lastKnownTimestamp = null;
              var isBoolean = false;
              var valueTypes = {}; // Track what value types we encounter

              var statusFlags = {}; // Track status occurrences in history
              var hasNonOkStatus = false;

              history.cursor({
                  each: function(record) {
                      var ts = record.get('timestamp');
                      var tsMillis = ts.getMillis();
                      totalRecords++;

                      // Debug: Log first few records regardless of date
                      if (totalRecords <= 5) {
                          console.log('DEBUG - Record #' + totalRecords + ' timestamp:', new Date(tsMillis).toISOString(), 'in range:', (tsMillis >= startMillis && tsMillis <= endMillis));
                      }

                      // Get status from history record
                      var recordStatus = null;
                      try {
                          recordStatus = record.get('status');
                          if (recordStatus) {
                              var statusText = recordStatus.flagsToString();
                              if (!statusFlags[statusText]) {
                                  statusFlags[statusText] = 0;
                              }
                              statusFlags[statusText]++;
                              if (!recordStatus.isOk()) {
                                  hasNonOkStatus = true;
                              }
                          }
                      } catch (e) {
                          // Status field may not exist
                      }

                      var val = record.get('value');
                      var valueStr = val.encodeToString();
                      var valueTag = val.getTag ? val.getTag() : 'unknown';
                      var numericValue = null;

                      // Track value types for debugging
                      if (!valueTypes[valueTag]) {
                          valueTypes[valueTag] = 0;
                      }
                      valueTypes[valueTag]++;

                      // Try to parse as number first
                      var parsedNum = parseFloat(valueStr);
                      if (!isNaN(parsedNum)) {
                          numericValue = parsedNum;
                          if (totalRecords <= 5) {
                              console.log('  ✓ Numeric value:', valueStr, '(tag:', valueTag + ')');
                          }
                      }
                      // Handle boolean values (true=1, false=0)
                      else if (valueStr === 'true' || valueStr === 'false') {
                          numericValue = (valueStr === 'true') ? 1 : 0;
                          isBoolean = true;
                          if (totalRecords <= 5) {
                              console.log('  ✓ Boolean value converted:', valueStr, '→', numericValue, '(tag:', valueTag + ')');
                          }
                      }
                      // Handle enum values (try to extract numeric part or use index)
                      else if (val.getTag && val.getTag() === 'baja:Enum') {
                          try {
                              numericValue = val.getOrdinal ? val.getOrdinal() : 0;
                              if (totalRecords <= 5) {
                                  console.log('  ✓ Enum value converted:', valueStr, '→', numericValue, '(tag:', valueTag + ')');
                              }
                          } catch (e) {
                          }
                      }
                      // Skip non-numeric, non-boolean, non-enum values
                      else {
                          if (totalRecords <= 5) {
                          }
                      }

                      // Track last known value before start date for showing state when no data in range
                      if (numericValue !== null && tsMillis < startMillis) {
                          if (lastKnownTimestamp === null || tsMillis > lastKnownTimestamp) {
                              lastKnownValue = numericValue;
                              lastKnownTimestamp = tsMillis;
                          }
                      }

                      // Client-side filtering: only include records in date range
                      if (tsMillis >= startMillis && tsMillis <= endMillis) {
                          recordsInRange++;

                          // Debug: Log the value object for first few records
                          if (rawDataPoints.length < 3) {
                              console.log('DEBUG - Value object:', {
                                  valueStr: valueStr,
                                  type: typeof val,
                                  tag: val.getTag ? val.getTag() : 'no getTag()',
                                  hasGetOrdinal: typeof val.getOrdinal,
                                  valObject: val
                              });
                          }

                          if (numericValue !== null) {
                              rawDataPoints.push({
                                  x: tsMillis,
                                  y: numericValue
                              });
                          }
                      }
                  },
                  after: function() {
                      console.log('  Value types encountered:', JSON.stringify(valueTypes, null, 2));
                      console.log('  Status flags encountered:', JSON.stringify(statusFlags, null, 2));
                      if (lastKnownValue !== null) {
                          console.log('  Last known value before range:', lastKnownValue, 'at', new Date(lastKnownTimestamp).toISOString());
                      }

                      // If no data in range but history exists, use the last known value before start date
                      if (rawDataPoints.length === 0 && totalRecords > 0 && lastKnownValue !== null) {
                          // Create two points: one at start, one at end, both with the last known value
                          rawDataPoints.push({ x: startMillis, y: lastKnownValue });
                          rawDataPoints.push({ x: endMillis, y: lastKnownValue });
                      } else if (rawDataPoints.length === 0 && totalRecords > 0) {
                      }

                      // Filter outliers (communication errors like 65535, -999, etc.) - but not for booleans
                      var filtered = isBoolean ? rawDataPoints : window.filterOutliers(rawDataPoints);
                      // Downsample if too many points (user-configurable) - but preserve all points for booleans to show transitions
                      var maxPoints = parseInt(document.getElementById('histMaxPoints').value) || 200;
                      var downsampled = (isBoolean || filtered.length <= maxPoints) ? filtered : window.downsampleData(filtered, maxPoints);
                      // Determine significant status - ignore isolated incidents
                      // Only flag as having non-OK status if:
                      // 1. Critical statuses (alarm, fault) exist at all, OR
                      // 2. Non-critical statuses (down, stale, disabled) are >5% of records
                      var significantStatus = false;
                      var totalStatusRecords = 0;
                      for (var flag in statusFlags) {
                          totalStatusRecords += statusFlags[flag];
                      }

                      for (var flag in statusFlags) {
                          var flagLower = flag.toLowerCase();
                          var percentage = (statusFlags[flag] / totalStatusRecords) * 100;

                          // Critical statuses - always show if they exist
                          if (flagLower.includes('alarm') || flagLower.includes('fault')) {
                              significantStatus = true;
                              console.log('  ⚠️ Critical status detected:', flag, '(' + statusFlags[flag] + ' records)');
                              break;
                          }

                          // Non-critical statuses - only show if >5% of records
                          if ((flagLower.includes('down') || flagLower.includes('stale') ||
                               flagLower.includes('disabled') || flagLower.includes('overridden')) &&
                              percentage > 5) {
                              significantStatus = true;
                              console.log('  ⚠️ Significant status detected:', flag, '(' + percentage.toFixed(1) + '% of records)');
                          }
                      }

                      // Tag the dataset as boolean so we can use step chart
                      resolve({
                          data: downsampled,
                          isBoolean: isBoolean,
                          statusSummary: statusFlags,
                          hasNonOkStatus: significantStatus
                      });
                  },
                  limit: 10000
              }).catch(function(cursorErr) {
                  reject(cursorErr);
              });
          });
      }).catch(function(histErr) {
          return { data: [], isBoolean: false, statusSummary: {}, hasNonOkStatus: false };
      });
  }

  // filterOutliers and downsampleData - uses window.filterOutliers and window.downsampleData from chart-utils.js

  function updateChart(data, label) {
      var ctx = document.getElementById('myChart').getContext('2d');
      
      // Destroy old
      if(chartInstance) chartInstance.destroy();
      
      // Simple downsample if too many points (over 500) for performance
      // (Optional optimization)

      chartInstance = new Chart(ctx, {
          type: 'line',
          data: {
              datasets: [{
                  label: label,
                  data: data,
                  borderColor: '#4CAF50',
                  backgroundColor: 'rgba(76, 175, 80, 0.1)',
                  borderWidth: 2,
                  pointRadius: 2,
                  fill: true,
                  tension: 0.1
              }]
          },
          options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                  x: {
                      type: 'linear',
                      position: 'bottom',
                      title: { display: true, text: 'Time', color: '#e0e0e0' },
                      ticks: {
                          color: '#888',
                          maxTicksLimit: 10,
                          callback: function(value) {
                              const d = new Date(value);
                              return d.toLocaleString([], {
                                  month: 'numeric', day: 'numeric',
                                  hour: '2-digit', minute: '2-digit'
                              });
                          }
                      },
                      grid: { color: '#333' }
                  },
                  y: {
                      grid: { color: '#333' },
                      ticks: { color: '#888' },
                      beginAtZero: false,
                      grace: '5%'
                  }
              },
              plugins: {
                  legend: { labels: { color: '#e0e0e0' } },
                  tooltip: {
                      mode: 'index',
                      intersect: false,
                      callbacks: {
                          title: function(context) {
                              if (context.length > 0) {
                                  const d = new Date(context[0].parsed.x);
                                  return d.toLocaleString();
                              }
                              return '';
                          }
                      }
                  }
              }
          }
      });
  }

  // --- 5. SHARED HELPERS ---
  // (Subscription & View Logic preserved)
  function unsubscribe() { if(currentSubscriber){currentSubscriber.unsubscribeAll();currentSubscriber.detach();} currentSubscriber = new baja.Subscriber(); }
  function setupSubscriptions(list) {
     if(list.length === 0) return;
     list.forEach(function(item) {
        baja.Ord.make(item.ord).get({ subscriber: currentSubscriber }).then(function(comp) {
           var update = function() {
              var el = document.getElementById(item.id); if(!el) return;
              var val = "Err";
              try {
                if(this.getOutDisplay) val = this.getOutDisplay();
                else {
                   var v = this.get('out'); if(v===undefined) v = this.get('value');
                   if(v!==undefined && v!==null) val = v.toString();
                }
              } catch(e){}
              el.textContent = val;
              if(['true','on','active','occupied'].indexOf(String(val).toLowerCase()) > -1) el.className = 'val-cell active';
              else if(['false','off','inactive','unoccupied'].indexOf(String(val).toLowerCase()) > -1) el.className = 'val-cell inactive';
              else el.className = 'val-cell';
           };
           comp.attach('changed', update); update.call(comp);
        }).catch(function(e){});
     });
  }
  function populateAddDropdown() {
     var sel = document.getElementById('availablePointsDropdown');
     sel.innerHTML = '<option value="">-- Select Point --</option>';
     var arr = Array.from(knownAvailablePoints).sort();
     arr.forEach(function(ptName) {
        var exists = globalColumns.some(c => c.label === ptName || c.match.includes(ptName));
        if(!exists) { var opt = document.createElement('option'); opt.value = ptName; opt.textContent = ptName; sel.appendChild(opt); }
     });
  }
  // Check if user can access a tab
  function checkTabAccess(tabId) {
    // Super users can access all tabs
    if (currentUser.isSuperUser) {
      return true;
    }
    
    // Check user restrictions - try currentUserConfig first, then dashboardConfig.users
    let userConfig = currentUserConfig;
    if (!userConfig && dashboardConfig && dashboardConfig.users && currentUser.name) {
      userConfig = dashboardConfig.users[currentUser.name];
    }
    
    // No restrictions if user config not loaded yet or no restrictions set
    if (!userConfig || !userConfig.restrictions) {
      return true; // No restrictions
    }
    
    // Check if tab is in allowed list
    return userConfig.restrictions.includes(tabId);
  }
  
  // Render tabs based on user permissions
  function renderTabs() {
    const tabButtons = document.querySelectorAll('.tab-btn');
    const allTabs = ['universal', 'multi', 'buildingSearch', 'alarmDashboard', 'history'];
    
    tabButtons.forEach(function(btn) {
      const tabId = btn.getAttribute('onclick')?.match(/switchTab\('([^']+)'\)/)?.[1];
      if (tabId && !checkTabAccess(tabId)) {
        btn.style.display = 'none';
      } else if (tabId) {
        btn.style.display = '';
      }
    });
  }
  
 // Replace the stub with the full implementation
 window.switchTab = function(tab) {
    // Set current tab for FAB menu
    window.currentTab = tab;
    
    // Check permissions before switching
    if (!checkTabAccess(tab)) {
      alert('You do not have permission to access this tab.');
      return;
    }
    
    // Update FAB menu when tab changes
    setTimeout(function() {
      if (window.updateFABMenu) {
        window.updateFABMenu();
      }
    }, 100);
    
    // Ensure equipment is scanned before loading these views
     if (tab === 'multi' || tab === 'buildingSearch') {
         if (!isEquipmentScanned) {
             ensureEquipmentScanned();
         }
     }
     
     // For history tab, ensure selectors are populated
     if (tab === 'history') {
         // Check if we have equipment data
         var hasEquipment = (dashboardConfig && dashboardConfig.global && dashboardConfig.global.snapshot && dashboardConfig.global.snapshot.length > 0) ||
                            (foundEquipment && foundEquipment.length > 0);
         
         if (!hasEquipment) {
             // No equipment data - trigger discovery if not already running
             if (!window.discoveryInProgress) {
                 runFullDiscovery();
             }
         } else {
             // We have equipment data - populate selectors
             populateSelectors();
             updateDateInputs(); // Ensure date inputs are set
         }
     }
     
     // Hide all views
     ['multi','buildingSearch','alarmDashboard','history','universal'].forEach(t => {
         var el = document.getElementById(t+'View');
         if(el) el.className = 'view-panel';
     });
     
     // Activate the clicked view
     var activeEl = document.getElementById(tab+'View');
     if(activeEl) activeEl.className = 'view-panel active';
     
     // Update Tab Buttons
     document.querySelectorAll('.tab-btn').forEach(b => b.className='tab-btn');
     if (event && event.target && event.target.className) {
        event.target.className = 'tab-btn active';
     }
     
     document.getElementById('addPointArea').style.display = 'none';

     // Always unsubscribe when switching tabs (cleans up subscriptions)
     unsubscribe();

     // --- 1. DASHBOARD LOGIC ---
     if(tab === 'dashboard') {
         window.refreshSiteDashboard();
         // Enable auto-refresh if checkbox is checked
         var dashBox = document.getElementById('dashAutoRefresh');
         if(dashBox && dashBox.checked && !dashInterval) {
             window.toggleDashAuto();
         }
     } else {
         // Stop Dashboard Refresh when leaving tab
         if(dashInterval) {
             clearInterval(dashInterval);
             dashInterval = null;
             console.log('Dashboard refresh stopped (left tab)');
         }
     }

     document.getElementById('status').textContent = 'Select options.';
     
     // --- NEW DASHBOARD LOGIC ---
     if(tab === 'dashboard') {
         // Auto-refresh the site health data
         window.refreshSiteDashboard();
     }
     // ----------------------------

     if(tab === 'history') {
      // Ensure selectors are populated when switching to history tab
      populateSelectors();
      refreshHistoryPointDropdown();
      // Initialize date inputs when switching to history tab
      setTimeout(function() {
        if (window.updateDateInputs) {
          window.updateDateInputs();
        }
      }, 100);
    }

     // Universal Dashboard tab
     if(tab === 'universal') {
       // Always update dashboard when switching to this tab
       const global = dashboardConfig?.global || dashboardConfig || {};
       if (global.snapshot && global.snapshot.length > 0) {
         updateDashboard(); // Refresh if data exists
       } else {
         // Show empty state
         const contentArea = document.getElementById('universalDashboardContent');
         if (contentArea) {
           contentArea.innerHTML = '<div style="text-align:center; padding:40px; color:#888;"><p style="font-size:18px; margin-bottom:20px;">🌐 Universal Dashboard</p><p>Click "🔄 Refresh Discovery" above to scan the entire station and discover all devices.</p><p style="margin-top:20px; font-size:12px; color:#666;">This will discover all components in the station and automatically categorize them by type and zone.</p></div>';
         }
       }
     }

     // Auto-resubscribe to Building-Wide Search results if they exist
     if(tab === 'buildingSearch' && buildingSearchResults.length > 0) {
        renderBuildingSearchResults(buildingSearchResults);
        document.getElementById('status').textContent = 'Resubscribed to ' + buildingSearchResults.length + ' search results';
     }

     // Auto-load alarms and enable auto-refresh when switching to alarm dashboard
     if(tab === 'alarmDashboard') {
        window.refreshAlarmDashboard();
        // Auto-enable refresh if checkbox is checked
        if (document.getElementById('alarmAutoRefresh').checked && !alarmAutoRefreshInterval) {
           window.toggleAlarmAutoRefresh();
        }
     } else {
        // Stop auto-refresh when leaving alarm dashboard
        if (alarmAutoRefreshInterval) {
           clearInterval(alarmAutoRefreshInterval);
           alarmAutoRefreshInterval = null;
           console.log('Auto-refresh stopped (left alarm dashboard)');
        }
     }
  };
  window.toggleAllMulti = function(val) { document.querySelectorAll('#multiSelectArea input').forEach(i => i.checked = val); };

  // --- BUILDING-WIDE SEARCH FUNCTIONS ---
  var buildingSearchResults = [];

  window.searchBuildingWide = function() {
     var pattern = document.getElementById('buildingSearchPattern').value.trim().toLowerCase();
     var typeFilter = document.getElementById('buildingSearchTypeFilter').value;

     if (!pattern) {
        alert("Please enter a search pattern!");
        return;
     }

     var status = document.getElementById('status');
     status.textContent = 'Searching all equipment for "' + pattern + '"...';

     unsubscribe();
     buildingSearchResults = [];

     // Query all equipment - use fetchAllEquipmentPoints to get ALL points
     var promises = [];
     foundEquipment.forEach(function(eq) {
        promises.push(fetchAllEquipmentPoints(eq.ord, eq.name));
     });

     Promise.all(promises).then(function(results) {
        var matchedPoints = [];

        results.forEach(function(result) {
           result.data.forEach(function(pt) {
              var pointName = pt.colLabel.toLowerCase();

              // Check if point name matches the pattern
              if (pointName.indexOf(pattern) !== -1) {
                 var classification = window.classifyPoint(pt.colLabel);

                 // Apply type filter if selected
                 if (typeFilter === 'all' ||
                     classification.category === typeFilter ||
                     (typeFilter === 'power' && classification.category === 'energy')) {

                    console.log('Matched: ' + result.name + ' - ' + pt.colLabel + ' (ord: ' + pt.ord + ')');
                    matchedPoints.push({
                       equipment: result.name,
                       equipmentOriginalName: result.originalName || result.name,
                       equipmentOrd: result.ord,
                       pointName: pt.colLabel,
                       slotName: pt.slotName,
                       ord: pt.ord,
                       classification: classification
                    });
                 }
              }
           });
        });
        buildingSearchResults = matchedPoints;
        renderBuildingSearchResults(matchedPoints);

        var statsDiv = document.getElementById('buildingSearchStats');
        statsDiv.innerHTML = '✅ Found <strong>' + matchedPoints.length + '</strong> points matching "' + pattern + '" across <strong>' +
                             new Set(matchedPoints.map(p => p.equipment)).size + '</strong> equipment units';
        status.textContent = 'Search complete - ' + matchedPoints.length + ' matches found';
     });
  };

  function renderBuildingSearchResults(results) {
     var div = document.getElementById('buildingSearchArea');

     if (results.length === 0) {
        div.innerHTML = '<div class="status">No matches found. Try a different search pattern.</div>';
        return;
     }

     // Load hidden points filter
     if (!window.hiddenPoints) {
       window.hiddenPoints = {};
       try {
         const saved = localStorage.getItem('dashboard_hidden_points');
         if (saved) {
           window.hiddenPoints = JSON.parse(saved);
         }
       } catch(e) {}
     }
     
     // Filter out hidden points
     const filteredResults = results.filter(function(pt) {
       const pointKey = (pt.slotName || pt.pointName || '').toLowerCase();
       return !window.hiddenPoints[pointKey];
     });

     if (filteredResults.length === 0) {
        div.innerHTML = '<div class="status">No matches found (all points are hidden). Try a different search pattern or unhide some points.</div>';
        return;
     }

     var html = '<div class="table-container"><table class="live-table">';
     html += '<thead><tr><th>Equipment</th><th>Point Name</th><th>Value</th><th>Type</th><th>Visual</th><th>Actions</th></tr></thead><tbody>';

     var subList = [];
     filteredResults.forEach(function(pt, idx) {
        var cellId = 'bw_val_' + idx;
        html += '<tr>';
        html += '<td class="name-cell">' + pt.equipment + '</td>';
        html += '<td>' + pt.pointName + '</td>';
        html += '<td class="val-cell" id="' + cellId + '">...</td>';
        html += '<td style="font-size:11px; color:#888;">' + pt.classification.icon + ' ' + pt.classification.displayGroup + '</td>';
        html += '<td id="visual_' + idx + '" style="text-align:center; padding:5px;"></td>';
        var originalName = pt.equipmentOriginalName || pt.equipment;
        html += '<td style="display:flex; gap:5px;">' +
                '<button onclick="window.openEquipmentPxView(\'' + originalName + '\')" ' +
                'style="padding:5px 10px; background:#2196F3; color:white; border:none; border-radius:3px; cursor:pointer; font-size:11px;">🖼️ View</button>' +
                '<button onclick="window.addPointToChartWithOrd(\'' + originalName + '\',\'' + pt.pointName.replace(/'/g, "\\'") + '\',\'' + pt.slotName.replace(/'/g, "\\'") + '\')" ' +
                'style="padding:5px 10px; background:#2196F3; color:white; border:none; border-radius:3px; cursor:pointer; font-size:11px;">📊 Chart</button>' +
                '</td>';
        html += '</tr>';

        subList.push({ id: cellId, ord: pt.ord, visualId: 'visual_' + idx, classification: pt.classification });
     });

     html += '</tbody></table></div>';
     div.innerHTML = html;
     setupSubscriptionsWithVisuals(subList);
  }

  window.addAllSearchResultsToChart = function() {
     if (buildingSearchResults.length === 0) {
        alert("No search results to add!");
        return;
     }

     var addedCount = 0;
     buildingSearchResults.forEach(function(pt) {
        var uniqueLabel = pt.equipment + ' - ' + pt.pointName;
        var exists = globalColumns.some(c => c.label === uniqueLabel);
        if (!exists) {
           globalColumns.push({ label: uniqueLabel, match: [pt.pointName] });
           addedCount++;
        }
     });

     refreshHistoryPointDropdown();
     alert('Added ' + addedCount + ' new points to chart!\n\n' +
           (buildingSearchResults.length - addedCount) + ' were already in the list.\n\n' +
           'Go to History Chart tab to view them.');
  };

  window.clearBuildingSearch = function() {
     // Clear the results
     buildingSearchResults = [];
     document.getElementById('buildingSearchArea').innerHTML = '';
     document.getElementById('buildingSearchStats').innerHTML = '';
     document.getElementById('buildingSearchPattern').value = '';
     document.getElementById('buildingSearchTypeFilter').value = 'all';

     // Unsubscribe from all points
     unsubscribe();

     document.getElementById('status').textContent = 'Building-Wide Search cleared.';
  };

  // --- ALARM DASHBOARD FUNCTIONS ---
  var alarmData = [];
  var alarmAutoRefreshInterval = null;
  var alarmSpace = null; // Cache the AlarmSpace object

// Process a single alarm record - Fetches BOTH Extension (for msg) and Point (for name)
  function processAlarmRecord(record) {
     return new Promise(function(resolve, reject) {
        try {
           // 1. Setup Basic Info
           var sourceOrd = record.get('source');
           var sourcePath = sourceOrd ? sourceOrd.toString() : '';
           
           // Calculate Point ORD (Parent of the Alarm Extension)
           var pointOrdStr = sourcePath;
           if (pointOrdStr.indexOf('/') > -1) {
               pointOrdStr = pointOrdStr.substring(0, pointOrdStr.lastIndexOf('/'));
           }

           // Default Names
           var equipmentDisplayName = 'Unknown';
           var pointDisplayName = 'Unknown';
           
           // Parse Equipment from path (Fallback)
           var match = sourcePath.match(/\/([^\/]+)\/points\//);
           if (match) equipmentDisplayName = match[1];
           
           // Parse Point Name from path (Fallback)
           var pointMatch = sourcePath.match(/\/([^\/]+)\/[^\/]*AlarmExt$/);
           if (pointMatch) pointDisplayName = pointMatch[1];
           else {
               var parts = sourcePath.split('/');
               if(parts.length > 1) pointDisplayName = parts[parts.length-2];
           }

           // 2. FETCH ALARM EXTENSION (To get Message Templates & MetaData)
           if (!sourceOrd) {
              return resolve(createAlarmRecordWithoutMetadata(record, equipmentDisplayName, pointDisplayName, sourcePath));
           }

           baja.Ord.make(sourceOrd.toString()).get().then(function(alarmExt) {
              
              // --- A. Extract Message Data from Extension (Original Logic) ---
              var alarmDataFields = {};

              // Get templates
              try { if(alarmExt.get('toOffnormalText')) alarmDataFields.toOffnormalText = alarmExt.get('toOffnormalText').toString(); } catch(e){}
              try { if(alarmExt.get('toNormalText')) alarmDataFields.toNormalText = alarmExt.get('toNormalText').toString(); } catch(e){}
              try { if(alarmExt.get('sourceName')) alarmDataFields.sourceNameTemplate = alarmExt.get('sourceName').toString(); } catch(e){}

              // Get MetaData (Crucial for %alarmData.X% placeholders)
              try {
                 var metaData = alarmExt.get('metaData');
                 if (metaData) {
                    var metaDataStr = metaData.toString();
                    if (metaDataStr.trim()) {
                       metaDataStr.split(',').forEach(function(pair) {
                          var parts = pair.split('=');
                          if (parts.length === 2) alarmDataFields[parts[0].trim()] = parts[1].trim();
                       });
                    }
                 }
              } catch(e) {}

              try {
                 var offnormalValue = alarmExt.get('offnormalValue');
                 if (offnormalValue && offnormalValue.toString() !== 'null') alarmDataFields.offnormalValue = offnormalValue.toString();
              } catch(e) {}

              // 3. FETCH PARENT POINT (To get correct Display Name)
              baja.Ord.make(pointOrdStr).get().then(function(pointComp) {
                  
                  // --- B. Resolve Display Name (The Fix) ---
                  // Method 1: Standard Baja getDisplayName()
                  var displayNamePromise = Promise.resolve(null);
                  if (pointComp.getDisplayName) {
                     var dn = pointComp.getDisplayName();
                     // Handle both String and Promise return types
                     if (dn && typeof dn.then === 'function') {
                        // It's a Promise - need to wait for it
                        displayNamePromise = dn.then(function(resolvedName) {
                           if (resolvedName && resolvedName !== pointComp.getName()) {
                              pointDisplayName = resolvedName;
                           }
                           return pointDisplayName;
                        });
                     } else {
                        if (dn && dn !== pointComp.getName()) pointDisplayName = dn;
                        displayNamePromise = Promise.resolve(pointDisplayName);
                     }
                  }
                  
                  return displayNamePromise.then(function() {
                      // Method 2: 'n:displayName' Tag Fallback
                      if (pointDisplayName === pointComp.getName() || pointDisplayName === 'Unknown') {
                          try {
                              var tagsSlot = pointComp.get("tags");
                              if (tagsSlot && tagsSlot.get && tagsSlot.get("n:displayName")) {
                                  pointDisplayName = tagsSlot.get("n:displayName");
                              }
                          } catch(e) {}
                      }
                      
                      // Also update equipment name if possible
                      var equipmentOrd = null;
                      var equipmentDisplayNamePromise = Promise.resolve(equipmentDisplayName);
                      try {
                          var parentFolder = pointComp.getParent(); // Monitor
                          var pointsFolder = parentFolder.getParent(); // points
                          var equipment = pointsFolder.getParent(); // HPxx
                          if (equipment) {
                              if (equipment.getDisplayName) {
                                  var eqDn = equipment.getDisplayName();
                                  if (eqDn && typeof eqDn.then === 'function') {
                                      equipmentDisplayNamePromise = eqDn;
                                  } else {
                                      equipmentDisplayNamePromise = Promise.resolve(eqDn || equipmentDisplayName);
                                  }
                              }
                              // Get equipment ORD for tstat location lookup
                              try {
                                  var eqSlotPath = equipment.getSlotPath();
                                  if (eqSlotPath) {
                                      equipmentOrd = 'station:|' + eqSlotPath;
                                  }
                              } catch(e) {}
                          }
                      } catch(e) {}

                      // Get tstat location and prepend to equipment name
                      var locationPromise = equipmentOrd ? getTstatLocationValue(equipmentOrd) : Promise.resolve(null);
                      return Promise.all([equipmentDisplayNamePromise, locationPromise]).then(function(results) {
                          var resolvedEquipmentDisplayName = results[0];
                          var locationValue = results[1];
                          var finalEquipmentName = resolvedEquipmentDisplayName;
                          if (locationValue && locationValue.trim() !== '') {
                              finalEquipmentName = locationValue + ' - ' + resolvedEquipmentDisplayName;
                          }

                          // --- C. Construct Final Message (Original Logic Restored) ---
                          
                          // Update fields with the correct names we just found
                          alarmDataFields.displayName = pointDisplayName;
                          alarmDataFields.parentDisplayName = finalEquipmentName;

                          // Resolve sourceName template
                          if (alarmDataFields.sourceNameTemplate) {
                             alarmDataFields.sourceName = replacePlaceholders(alarmDataFields.sourceNameTemplate, alarmDataFields, alarmExt, finalEquipmentName, pointDisplayName);
                          }

                          // Determine template to use
                          var isNormal = record.get('normalTime') && record.get('normalTime').toString() !== 'null';
                          var msgTemplate = isNormal ? alarmDataFields.toNormalText : alarmDataFields.toOffnormalText;
                          if (!msgTemplate) msgTemplate = 'Alarm';

                          // Generate Final Message
                          var msgText = replacePlaceholders(msgTemplate, alarmDataFields, alarmExt, finalEquipmentName, pointDisplayName);

                          // Resolve
                          var alarmRec = {
                             uuid: record.get('uuid') ? record.get('uuid').toString() : '',
                             sourceName: finalEquipmentName + ' - ' + pointDisplayName,
                             sourcePath: sourcePath,
                             msgText: msgText,
                             sourceState: record.get('sourceState') ? record.get('sourceState').toString() : '',
                             toState: isNormal ? 'normal' : 'offnormal',
                             timestamp: record.get('timestamp') ? new Date(record.get('timestamp').getMillis()) : new Date(),
                             ackState: record.get('ackState') ? record.get('ackState').toString() : 'unacked',
                             normalTime: record.get('normalTime'),
                             alarmClass: record.get('alarmClass') ? record.get('alarmClass').toString() : 'alarm'
                          };
                          resolve(alarmRec);
                      }); // Close Promise.all().then()
                  }); // Close displayNamePromise.then() - returns the Promise.all() chain

              }).catch(function(ptErr) {
                  // Point fetch failed, but we still have Alarm Ext data. Proceed with technical names.
                  var msgText = replacePlaceholders(msgTemplate || 'Alarm', alarmDataFields, alarmExt, equipmentDisplayName, pointDisplayName);
                  
                  resolve({
                     uuid: record.get('uuid') ? record.get('uuid').toString() : '',
                     sourceName: equipmentDisplayName + ' - ' + pointDisplayName,
                     sourcePath: sourcePath,
                     msgText: msgText,
                     // ... fill rest ...
                     timestamp: record.get('timestamp') ? new Date(record.get('timestamp').getMillis()) : new Date(),
                     ackState: record.get('ackState') ? record.get('ackState').toString() : 'unacked', 
                     normalTime: record.get('normalTime'),
                     alarmClass: record.get('alarmClass') ? record.get('alarmClass').toString() : 'alarm'
                  });
              });

           }).catch(function(err) {
              // Alarm Ext fetch failed (Source deleted?)
              resolve(createAlarmRecordWithoutMetadata(record, equipmentDisplayName, pointDisplayName, sourcePath));
           });

        } catch(e) {
           reject(e);
        }
     });
  }

  // Helper to replace placeholders in message template
  function replacePlaceholders(template, alarmDataFields, sourceComp, equipmentName, pointSlotName) {
     if (!template) return 'No message';

     // Replace %alarmData.fieldName% placeholders
     var result = template.replace(/%alarmData\.(\w+)%/g, function(match, fieldName) {
        if (alarmDataFields[fieldName]) {
           return alarmDataFields[fieldName];
        }
        return 'N/A';
     });

     // Replace %parent.parent...% placeholders (VykonPro uses these to navigate component tree)
     // Since we can't do async lookups in a regex replace, parse the slot path directly
     result = result.replace(/%parent((?:\.parent)*)\.(\w+)%/g, function(match, parentChain, fieldName) {
        try {
           // Count how many .parent we have
           var parentCount = parentChain ? (parentChain.match(/\.parent/g) || []).length : 0;

           // Get the slot path from sourceComp as a string
           var slotPath = '';
           if (sourceComp.getSlotPath) {
              slotPath = sourceComp.getSlotPath();
           } else if (sourceComp.toString) {
              slotPath = sourceComp.toString();
           }

           // Ensure it's a string
           if (typeof slotPath !== 'string') {
              slotPath = String(slotPath);
           }

           // Navigate up the path by removing path segments
           // Example: /Drivers/BacnetNetwork/HP44/points/Monitor/AlarmActive1/BooleanChangeOfStateAlarmExt
           // parent (1 level up): AlarmActive1
           // parent.parent (2 levels): Monitor
           // parent.parent.parent (3 levels): points
           // parent.parent.parent.parent (4 levels): HP44
           var pathParts = slotPath.split('/').filter(function(p) { return p; });

           // Navigate up by removing (parentCount + 1) segments from end
           // (+1 because we start from the component itself)
           if (pathParts.length > parentCount + 1) {
              // Get the name at the target level
              var targetIndex = pathParts.length - (parentCount + 2);
              var targetName = pathParts[targetIndex];

              // For displayName, just return the component name
              if (fieldName === 'displayName') {
                 return targetName;
              }
           }

           // For other fields, we can't resolve without fetching the component
           return 'N/A';
        } catch(e) {
        }
        return 'N/A';
     });

     return result;
  }

  // Fallback when we can't fetch metadata
  function createAlarmRecordWithoutMetadata(record, equipmentName, pointSlotName, sourcePath) {
     return {
        uuid: record.get('uuid') ? record.get('uuid').toString() : '',
        sourceName: equipmentName + ' - ' + pointSlotName,
        sourcePath: sourcePath,
        msgText: 'Alarm (metadata unavailable)',
        sourceState: record.get('sourceState') ? record.get('sourceState').toString() : '',
        toState: '',
        timestamp: record.get('timestamp') ? new Date(record.get('timestamp').getMillis()) : new Date(),
        ackState: record.get('ackState') ? record.get('ackState').toString() : 'unacked',
        normalTime: record.get('normalTime'),
        alarmClass: record.get('alarmClass') ? record.get('alarmClass').toString() : 'alarm'
     };
  }

  window.refreshAlarmDashboard = function() {
     var status = document.getElementById('status');
     status.textContent = 'Querying alarm database...';
     // Query using the alarm: scheme
     // NO HARDCODED FIELDS - we'll get metadata dynamically from the alarm source component
     var bqlOrd = "alarm:|bql:select timestamp, source, sourceState, ackState, ackRequired, " +
                  "alarmClass, normalTime, uuid " +
                  "order by timestamp DESC";
     baja.Ord.make(bqlOrd).get()
        .then(function(table) {
           alarmData = [];
           var totalCount = 0;
           var unackedCount = 0;
           var activeCount = 0;

           // Collect all records first, then process them async to fetch metadata
           var records = [];
           return table.cursor({
              each: function(record) {
                 records.push(record);
              },
              after: function() {
                 // Process each record - fetch source component to get metadata
                 var promises = records.map(function(record) {
                    return processAlarmRecord(record).catch(function(err) {
                       return null; // Continue with other records
                    });
                 });

                 Promise.all(promises).then(function(results) {
                    // Filter out nulls and add to alarmData
                    results.forEach(function(alarmRec) {
                       if (alarmRec) {
                          totalCount++;
                          if (alarmRec.ackState.toLowerCase().includes('unacked')) unackedCount++;
                          if (!alarmRec.normalTime || alarmRec.normalTime.toString() === 'null') activeCount++;
                          alarmData.push(alarmRec);
                       }
                    });
                    updateAlarmStats(totalCount, unackedCount, activeCount);
                    renderAlarmDashboard();
                    status.textContent = 'Found ' + totalCount + ' alarms (' + unackedCount + ' unacked, ' + activeCount + ' active)';
                 });
              },
              limit: 1000  // Request up to 10000 alarm records
           });
        })
        .catch(function(err) {
           status.textContent = 'Error querying alarms: ' + err.message;
           document.getElementById('alarmDashboardArea').innerHTML =
              '<div class="status error">❌ Error querying alarm database: ' + err.message +
              '<br><br>Make sure the AlarmService is running at: /Services/AlarmService' +
              '<br><br>Check console for details.</div>';
        });
  }

  function updateAlarmStats(total, unacked, active) {
     document.getElementById('alarmCountTotal').textContent = total;
     document.getElementById('alarmCountUnacked').textContent = unacked;
     document.getElementById('alarmCountActive').textContent = active;
  }

  function renderAlarmDashboard() {
     var div = document.getElementById('alarmDashboardArea');
     var filterType = document.getElementById('alarmFilterType').value;
     var searchText = document.getElementById('alarmSearchText').value.toLowerCase();

     // Filter alarms
     var filteredAlarms = alarmData.filter(function(alarm) {
        // Apply filter type
        if (filterType === 'unacked' && !alarm.ackState.toLowerCase().includes('unacked')) {
           return false;
        }
        if (filterType === 'active' && alarm.normalTime && alarm.normalTime.toString() !== 'null') {
           return false;
        }

        // Apply search text
        if (searchText) {
           var searchable = (alarm.sourceName + ' ' + alarm.msgText).toLowerCase();
           if (searchable.indexOf(searchText) === -1) {
              return false;
           }
        }

        return true;
     });

     if (filteredAlarms.length === 0) {
        div.innerHTML = '<div class="status">✅ No alarms match the current filter.</div>';
        return;
     }

     // Sort by timestamp (newest first)
     filteredAlarms.sort(function(a, b) {
        return b.timestamp - a.timestamp;
     });

     var html = '<div class="table-container"><table class="live-table">';
     html += '<thead><tr><th>Time</th><th>Source</th><th>Message</th><th>Status</th><th>Actions</th></tr></thead><tbody>';

     filteredAlarms.forEach(function(alarm, idx) {
        var isUnacked = alarm.ackState.toLowerCase().includes('unacked');
        var isActive = !alarm.normalTime || alarm.normalTime.toString() === 'null';
        var timeSince = window.getTimeSince(alarm.timestamp);

        // Extract equipment name from sourcePath
        var equipment = window.extractEquipmentName(alarm.sourcePath || alarm.sourceName);
        var pointName = window.extractPointName(alarm.sourcePath || alarm.sourceName);

        html += '<tr style="background:' + (isUnacked ? 'rgba(255,152,0,0.1)' : 'rgba(76,175,80,0.05)') + ';">';
        html += '<td style="font-size:11px; white-space:nowrap;">' + timeSince + '</td>';
        html += '<td class="name-cell">' + alarm.sourceName + '</td>';
        html += '<td style="word-wrap:break-word; white-space:normal; max-width:500px;">' + alarm.msgText + '</td>';
        html += '<td style="font-size:11px;">';
        if (isUnacked) html += '<span style="color:#ff9800;">⚠️ UNACKED</span><br>';
        if (isActive) html += '<span style="color:#f44336;">🔴 ACTIVE</span>';
        else html += '<span style="color:#4caf50;">✅ RTN</span>';
        html += '</td>';
        html += '<td>';
        html += '<button onclick="window.openEquipmentPxView(\'' + equipment + '\')" ' +
                'style="padding:4px 8px; background:#2196F3; color:white; border:none; border-radius:3px; cursor:pointer; font-size:11px; margin:2px;">🖼️ View</button>';
        html += '<button onclick="window.addAlarmPointToChart(\'' + equipment + '\',\'' + pointName.replace(/'/g, "\\'") + '\')" ' +
                'style="padding:4px 8px; background:#4CAF50; color:white; border:none; border-radius:3px; cursor:pointer; font-size:11px; margin:2px;">📊 Chart</button>';
        html += '</td>';
        html += '</tr>';
     });

     html += '</tbody></table></div>';
     div.innerHTML = html;
  }

  // Alarm utility functions - uses window.extractEquipmentName, window.extractPointName, window.getTimeSince from alarm-utils.js

  window.toggleAlarmAutoRefresh = function() {
     var checkbox = document.getElementById('alarmAutoRefresh');
     if (checkbox.checked) {
        alarmAutoRefreshInterval = setInterval(window.refreshAlarmDashboard, 30000);
        console.log('Auto-refresh enabled (30s interval)');
     } else {
        if (alarmAutoRefreshInterval) {
           clearInterval(alarmAutoRefreshInterval);
           alarmAutoRefreshInterval = null;
        }
     }
  };

  // --- MULTI-PX GRAPHIC VIEWER SYSTEM ---
  // Initialize PX graphics container
  function ensurePxGraphicsContainer() {
     if (document.getElementById('pxGraphicsContainer')) return;

     // 1. Inject CSS
     var style = document.createElement('style');
     style.textContent = `
       #pxGraphicsContainer {
         position: fixed;
         bottom: 0;
         left: 0;
         right: 0;
         max-height: 60vh;
         overflow-y: auto;
         background: #1e1e1e;
         border-top: 2px solid #4CAF50;
         z-index: 1000;
         display: none;
       }
       #pxGraphicsContainer.has-graphics {
         display: block;
       }
       .px-graphic-item {
         background: #2d2d2d;
         margin: 10px;
         border-radius: 8px;
         border: 1px solid #444;
         overflow: hidden;
         box-shadow: 0 2px 8px rgba(0,0,0,0.3);
       }
       .px-graphic-header {
         background: #1e1e1e;
         padding: 10px 15px;
         border-bottom: 1px solid #444;
         display: flex;
         justify-content: space-between;
         align-items: center;
       }
       .px-graphic-title {
         font-weight: bold;
         color: #4CAF50;
         font-size: 14px;
       }
       .px-graphic-close {
         background: #d32f2f;
         color: white;
         border: none;
         padding: 4px 12px;
         border-radius: 4px;
         cursor: pointer;
         font-size: 12px;
       }
       .px-graphic-close:hover {
         background: #b71c1c;
       }
       .px-graphic-frame {
         width: 100%;
         height: 400px;
         border: none;
         background: #fff;
         display: block;
       }
     `;
     document.head.appendChild(style);

     // 2. Inject HTML container
     var container = document.createElement('div');
     container.id = 'pxGraphicsContainer';
     document.body.appendChild(container);
  }
  
  // Track open PX graphics
  window.openPxGraphics = window.openPxGraphics || {};
  
  // Open a PX graphic
  window.openPxGraphic = async function(equipmentOrd, equipmentName) {
    ensurePxGraphicsContainer();
    
    const container = document.getElementById('pxGraphicsContainer');
    if (!container) return;
    
    // Check limit (max 5)
    const currentCount = Object.keys(window.openPxGraphics).length;
    if (currentCount >= 5) {
      alert('Maximum 5 PX graphics allowed. Close one to open another.');
      return;
    }
    
    // Check if already open
    const graphicId = 'px_' + Date.now();
    if (window.openPxGraphics[graphicId]) {
      // Already open, scroll to it
      const existingDiv = document.getElementById(graphicId);
      if (existingDiv) {
        existingDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      return;
    }
    
    // Create PX graphic item
    const graphicDiv = document.createElement('div');
    graphicDiv.id = graphicId;
    graphicDiv.className = 'px-graphic-item';
    
    // Extract slot path from ORD
    let slotPath = equipmentOrd.replace('station:|slot:', '');
    if (!slotPath && equipmentOrd.includes('|slot:')) {
      slotPath = equipmentOrd.split('|slot:')[1];
    }
    
    // Determine view name based on device type
    let viewName = null;
    
    // Check if it's a heat pump by checking the device type or name
    const isHeatPump = equipmentName && (
      /^HP\d+/i.test(equipmentName) || 
      /heat.?pump/i.test(equipmentName) ||
      /hp/i.test(equipmentName)
    );
    
    // Also check from dashboard config if available
    if (!isHeatPump) {
      const global = dashboardConfig?.global || dashboardConfig || {};
      const snapshot = global.snapshot || [];
      const device = snapshot.find(function(comp) {
        return (comp.ord || comp.slotPath) === equipmentOrd;
      });
      if (device && device.inferredType) {
        const deviceType = device.inferredType.toLowerCase();
        if (deviceType.includes('heatpump') || deviceType.includes('hp')) {
          isHeatPump = true;
        }
      }
    }
    
    if (isHeatPump) {
      // Heat pumps use TC_300_Graphic view
      viewName = 'TC_300_Graphic';
    } else {
      // For other devices, try to get the default view or first available view
      try {
        const deviceComp = await baja.Ord.make(equipmentOrd).get();
        if (deviceComp && deviceComp.getViews) {
          const views = deviceComp.getViews();
          if (views && views.length > 0) {
            // Use the first view (usually the default)
            viewName = views[0].getName ? views[0].getName() : views[0].toString();
          }
        }
      } catch(e) {
      }
      
      // If no view found, use empty string for default view
      if (!viewName) {
        viewName = ''; // Empty string means default view
      }
    }
    
    // Build PX view URL - correct format: /ord/station:|slot:/path|view:ViewName
    // The format should be: /ord/station:%7Cslot:/path%7Cview:ViewName
    // where %7C is the URL encoding for |
    let ordString = 'station:|slot:' + slotPath;
    if (viewName) {
      ordString += '|view:' + viewName;
    }
    
    // URL encode the entire ORD string (| becomes %7C)
    const encodedOrd = encodeURIComponent(ordString);
    const pxUrl = '/ord/' + encodedOrd + '?fullScreen=true';
    
    console.log('🔍 [DEBUG] Building PX URL:', {
      equipmentOrd: equipmentOrd,
      slotPath: slotPath,
      viewName: viewName || '(default)',
      ordString: ordString,
      encodedOrd: encodedOrd,
      finalUrl: pxUrl
    });
    
    // Home page URL fallback (for 400 errors or missing views)
    const homePagePxUrl = '/ord/file:%5Epx/deploy/ZoneMaps/Home.px%7Cview:hx:HxPxView';
    
    graphicDiv.innerHTML = `
      <div class="px-graphic-header">
        <span class="px-graphic-title">${equipmentName || 'PX Graphic'}</span>
        <div style="display:flex; gap:8px; align-items:center;">
          <button class="px-graphic-home" onclick="window.loadHomePx('${graphicId}')" style="background:#4CAF50; color:white; border:none; padding:4px 10px; border-radius:4px; cursor:pointer; font-size:11px;">🏠 Home</button>
          <button class="px-graphic-close" onclick="window.closePxGraphic('${graphicId}')">✕ Close</button>
        </div>
      </div>
      <iframe class="px-graphic-frame" id="frame_${graphicId}" src="${pxUrl}"></iframe>
    `;
    
    container.appendChild(graphicDiv);
    container.classList.add('has-graphics');
    
    // Add error handling for iframe - only check ONCE
    const iframe = document.getElementById('frame_' + graphicId);
    if (iframe) {
      let hasRedirected = false;
      
      iframe.onerror = function() {
        if (!hasRedirected) {
          hasRedirected = true;
          iframe.src = homePagePxUrl;
          // Update title
          const titleSpan = graphicDiv.querySelector('.px-graphic-title');
          if (titleSpan) {
            titleSpan.textContent = '🏠 Home - ' + (equipmentName || 'Dashboard');
          }
        }
      };
      
      // Check for 400 errors ONCE before loading
      fetch(pxUrl, { method: 'HEAD' }).then(function(response) {
        if (!hasRedirected && !response.ok && (response.status === 400 || response.status === 404)) {
          hasRedirected = true;
          iframe.src = homePagePxUrl;
          // Update the title to show it's the home page
          const titleSpan = graphicDiv.querySelector('.px-graphic-title');
          if (titleSpan) {
            titleSpan.textContent = '🏠 Home - ' + (equipmentName || 'Dashboard');
          }
        }
      }).catch(function() {
        // Fetch failed - don't redirect, just let it try to load
      });
    }
    
    // Track this graphic
    window.openPxGraphics[graphicId] = {
      ord: equipmentOrd,
      name: equipmentName,
      timestamp: new Date().toISOString(),
      id: graphicId,
      viewName: viewName
    };
    
    // Save state
    savePxGraphicsState();
    
    // Scroll to new graphic
    graphicDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  };
  
  // Load home page PX in a specific graphic
  window.loadHomePx = function(graphicId) {
    const iframe = document.getElementById('frame_' + graphicId);
    if (iframe) {
      const homePagePxUrl = '/ord/file:%5Epx/deploy/ZoneMaps/Home.px%7Cview:hx:HxPxView';
      iframe.src = homePagePxUrl;
      
      // Update the title
      const graphicDiv = document.getElementById(graphicId);
      if (graphicDiv) {
        const titleSpan = graphicDiv.querySelector('.px-graphic-title');
        if (titleSpan) {
          titleSpan.textContent = '🏠 Home Dashboard';
        }
      }
    }
  };
  
  // Close a PX graphic
  window.closePxGraphic = function(graphicId) {
    const graphicDiv = document.getElementById(graphicId);
    if (graphicDiv) {
      graphicDiv.remove();
    }
    
    delete window.openPxGraphics[graphicId];
    
    // Update container visibility
    const container = document.getElementById('pxGraphicsContainer');
    if (container && Object.keys(window.openPxGraphics).length === 0) {
      container.classList.remove('has-graphics');
    }
    
    // Save state
    savePxGraphicsState();
  };
  
  // Clean up device points subscriptions when device is collapsed
  window.cleanupDevicePointsSubscriptions = function(deviceId) {
    if (window.devicePointsSubscribers && window.devicePointsSubscribers[deviceId]) {
      const subscriber = window.devicePointsSubscribers[deviceId];
      try {
        subscriber.unsubscribeAll();
        subscriber.detach();
        delete window.devicePointsSubscribers[deviceId];
      } catch(e) {
      }
    }
  };
  
  // Save PX graphics state to user config
  function savePxGraphicsState() {
    if (!dashboardConfig || !currentUser.name) return;
    
    // Save to user-specific config
    if (!dashboardConfig.users) dashboardConfig.users = {};
    if (!dashboardConfig.users[currentUser.name]) {
      dashboardConfig.users[currentUser.name] = { dashboards: [], activeDashboard: null, restrictions: null };
    }
    
    // Store PX graphics in user config (for quick access)
    dashboardConfig.users[currentUser.name].pxGraphics = Object.values(window.openPxGraphics || {});
    
    saveUserConfig(currentUser.name, dashboardConfig.users[currentUser.name]).catch(function(err) {
    });
  }
  
  // Load PX graphics state from user config
  function loadPxGraphicsState() {
    if (!dashboardConfig || !currentUser.name) return;
    
    ensurePxGraphicsContainer();
    
    const userConfig = dashboardConfig.users && dashboardConfig.users[currentUser.name];
    const graphics = (userConfig && userConfig.pxGraphics) || [];
    graphics.forEach(function(graphic) {
      if (graphic.ord && graphic.name) {
        // Reopen the graphic
        window.openPxGraphics[graphic.id] = graphic;
        
        const container = document.getElementById('pxGraphicsContainer');
        if (container) {
          const graphicDiv = document.createElement('div');
          graphicDiv.id = graphic.id;
          graphicDiv.className = 'px-graphic-item';
          
          // Reconstruct PX URL properly
          let slotPath = graphic.ord.replace('station:|slot:', '');
          if (!slotPath && graphic.ord.includes('|slot:')) {
            slotPath = graphic.ord.split('|slot:')[1];
          }
          
          // Use the same logic as openPxGraphic to build URL
          let pxUrl = '';
          if (graphic.viewName) {
            // Use saved view name
            const ordString = 'station:|slot:' + slotPath;
            const encodedOrd = encodeURIComponent(ordString);
            pxUrl = '/ord/' + encodedOrd + '%7Cview:' + graphic.viewName + '?fullScreen=true';
          } else {
            // Try to detect view (same logic as openPxGraphic)
            const nameLower = (graphic.name || '').toLowerCase();
            if (nameLower.includes('hp') || nameLower.includes('heat') || nameLower.includes('pump')) {
              pxUrl = '/ord/' + encodeURIComponent('station:|slot:' + slotPath) + '%7Cview:TC_300_Graphic?fullScreen=true';
            } else {
              // Default view
              pxUrl = '/ord/' + encodeURIComponent('station:|slot:' + slotPath) + '%7Cview:?fullScreen=true';
            }
          }
          
          graphicDiv.innerHTML = `
            <div class="px-graphic-header">
              <span class="px-graphic-title">${graphic.name}</span>
              <button class="px-graphic-close" onclick="window.closePxGraphic('${graphic.id}')">✕ Close</button>
            </div>
            <iframe class="px-graphic-frame" src="${pxUrl}"></iframe>
          `;
          
          container.appendChild(graphicDiv);
          container.classList.add('has-graphics');
        }
      }
    });
  }
  
  // Legacy function for backward compatibility
  function ensureInlinePxViewer() {
     // Redirect to new multi-PX system
     ensurePxGraphicsContainer();
  }

  // Legacy function - redirects to new multi-PX system
  window.openEquipmentPxView = function(input) {
     // Detect Name vs ORD
     var equipOrd = '';
     var equipName = '';

     // Check if input is already a full ORD (starts with "station:")
     if (input.indexOf('station:') === 0) {
         equipOrd = input;
         // Extract simple name for the title (everything after the last '/')
         try {
            var parts = input.split('/');
            equipName = parts[parts.length - 1];
         } catch(e) { equipName = input; }
     } else {
         // It is just a Name (e.g., "HP7"), so we must add the path
         equipName = input;
         equipOrd = 'station:|slot:/Drivers/BacnetNetwork/' + input;
     }
     
     // Use new multi-PX system
     window.openPxGraphic(equipOrd, equipName);
  };

  window.addAlarmPointToChart = function(equipment, pointName) {
     // This will use the same function as Building-Wide Search
     // But we need to find the slot name first
     // For now, just add with the point name
     // TODO: Discover the actual slot name for better matching
     window.addPointToChartWithOrd(equipment, pointName, pointName);
  };

  // Updates the visibility of the History tab Px button
  window.updateHistoryPxButton = function() {
     var dropdown = document.getElementById('histUnitDropdown');
     var btn = document.getElementById('histPxBtn');
     
     // Logic: Show button only if a valid unit is selected
     if (dropdown.value && dropdown.value !== 'Loading...' && dropdown.value.indexOf('station:') > -1) {
         btn.style.display = 'block';
     } else {
         btn.style.display = 'none';
     }
  };

  // Triggered when clicking the Px button on History tab
  window.openHistoryPx = function() {
     var dropdown = document.getElementById('histUnitDropdown');
     if (dropdown.value) {
         // dropdown.value is the Full ORD (station:|slot:/...)
         // Our smart function handles ORDs perfectly now!
         window.openEquipmentPxView(dropdown.value);
     }
  };


  // Add filter change listeners
  document.addEventListener('DOMContentLoaded', function() {
     var filterSelect = document.getElementById('alarmFilterType');
     var searchInput = document.getElementById('alarmSearchText');

     if (filterSelect) {
        filterSelect.addEventListener('change', function() {
           if (alarmData.length > 0) renderAlarmDashboard();
        });
     }

     if (searchInput) {
        searchInput.addEventListener('input', function() {
           if (alarmData.length > 0) renderAlarmDashboard();
        });
     }
  });

  window.addPointToChartWithOrd = function(equipment, pointName, slotName) {
     var uniqueLabel = equipment + ' - ' + pointName;

     // Check if already in selectedHistoryPoints
     var exists = selectedHistoryPoints.some(function(p) {
        return p.equipment === equipment && p.pointName === pointName;
     });

     if (exists) {
        alert('Point "' + uniqueLabel + '" is already in chart!\n\nGo to History Chart tab to plot it.');
        return;
     }

     // Discover history ID using the actual slot name
     var status = document.getElementById('status');
     status.textContent = 'Finding history for ' + uniqueLabel + '...';

     // Search for history using the slotName (more precise than displayName)
     // Escape special characters in equipment name (like apostrophes)
     const escapedEquipment = equipment.replace(/'/g, "''"); // SQL escape: ' becomes ''
     const escapedSlotName = slotName.replace(/'/g, "''");
     var bqlOrd = "station:|slot:/Drivers|bql:select id, slotPath from history:HistoryConfig where slotPath like '%/" + escapedEquipment + "/%' and slotPath like '%" + escapedSlotName + "%'";
     baja.Ord.make(bqlOrd).get().then(function(table) {
        var foundHistory = null;

        return table.cursor({
           each: function(record) {
              if (!foundHistory) {
                 try {
                    var historyId = record.get('id').toString();
                    var slotPath = record.get('slotPath').toString();
                    foundHistory = { historyId: historyId, slotPath: slotPath };
                 } catch(e) {
                 }
              }
           },
           after: function() {
              if (foundHistory) {
                 selectedHistoryPoints.push({
                    equipment: equipment,
                    pointName: pointName,
                    historyId: foundHistory.historyId,
                    displayName: uniqueLabel
                 });
                 updateSelectedPointsList();
                 status.textContent = 'Added ' + uniqueLabel + ' to chart!';
                 alert('✅ Added "' + uniqueLabel + '" to chart!\n\nGo to History Chart tab and click "Plot Chart" to view it.');
              } else {
                 status.textContent = 'No history found for ' + uniqueLabel;
                 alert('⚠️ No history found for "' + uniqueLabel + '".\n\nThis point may not have history enabled in Niagara.');
              }
           }
        });
     }).catch(function(err) {
        status.textContent = 'Error finding history';
        alert('❌ Error finding history: ' + err.message);
     });
  };

  // --- SVG GRAPHICS LIBRARY ---

  // CUSTOM SVG CONFIGURATION - Easy to customize!
  // Set useCustomSVGs to true and specify your SVG file paths
  var customSVGConfig = {
     useCustomSVGs: false,  // Set to true to use custom SVG files instead of generated graphics
     paths: {
        thermometer: '/file/thermometer.svg',
        fan: '/file/fan.svg',
        damper: '/file/damper.svg',
        valve: '/file/valve.svg',
        gauge: '/file/gauge.svg',
        statusIndicator: '/file/status.svg'
     },
     // If using custom SVGs, specify default width/height
     sizes: {
        thermometer: { width: 40, height: 60 },
        fan: { width: 40, height: 40 },
        damper: { width: 50, height: 30 },
        valve: { width: 40, height: 40 },
        gauge: { width: 60, height: 40 },
        statusIndicator: { width: 60, height: 30 }
     }
  };

  var SvgGraphics = {
     thermometer: function(value, min, max, unit) {
        // Use custom SVG if configured
        if (customSVGConfig.useCustomSVGs && customSVGConfig.paths.thermometer) {
           var size = customSVGConfig.sizes.thermometer;
           return '<img src="' + customSVGConfig.paths.thermometer + '" width="' + size.width + '" height="' + size.height + '" title="' + Math.round(value) + (unit || '°F') + '">';
        }

        // Otherwise generate SVG
        min = min || 0;
        max = max || 100;
        unit = unit || '°F';
        var percent = Math.max(0, Math.min(100, ((value - min) / (max - min)) * 100));
        var color = value < 60 ? '#2196F3' : value < 75 ? '#4CAF50' : '#FF5722';

        return '<svg width="40" height="60" viewBox="0 0 40 60">' +
               '<rect x="14" y="5" width="12" height="35" rx="6" fill="#333" stroke="#666" stroke-width="1"/>' +
               '<rect x="14" y="' + (40 - (percent * 0.35)) + '" width="12" height="' + (percent * 0.35) + '" fill="' + color + '"/>' +
               '<circle cx="20" cy="47" r="8" fill="' + color + '" stroke="#666" stroke-width="1"/>' +
               '<text x="20" y="58" text-anchor="middle" font-size="8" fill="#fff">' + Math.round(value) + unit + '</text>' +
               '</svg>';
     },

     fan: function(speed, isRunning) {
        // Use custom SVG if configured
        if (customSVGConfig.useCustomSVGs && customSVGConfig.paths.fan) {
           var size = customSVGConfig.sizes.fan;
           return '<img src="' + customSVGConfig.paths.fan + '" width="' + size.width + '" height="' + size.height + '" title="' + Math.round(speed) + '%">';
        }

        // Otherwise generate SVG
        speed = speed || 0;
        var color = isRunning ? '#4CAF50' : '#666';
        var rotation = isRunning ? 'transform-origin: 20px 20px; animation: spin ' + (2 - (speed/100)) + 's linear infinite;' : '';

        return '<style>@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>' +
               '<svg width="40" height="40" viewBox="0 0 40 40">' +
               '<circle cx="20" cy="20" r="18" fill="none" stroke="' + color + '" stroke-width="2"/>' +
               '<g style="' + rotation + '">' +
               '<path d="M20,10 L22,18 L20,20 L18,18 Z" fill="' + color + '"/>' +
               '<path d="M30,20 L22,22 L20,20 L22,18 Z" fill="' + color + '"/>' +
               '<path d="M20,30 L18,22 L20,20 L22,22 Z" fill="' + color + '"/>' +
               '<path d="M10,20 L18,18 L20,20 L18,22 Z" fill="' + color + '"/>' +
               '</g>' +
               '<circle cx="20" cy="20" r="3" fill="' + color + '"/>' +
               '<text x="20" y="45" text-anchor="middle" font-size="8" fill="#fff">' + Math.round(speed) + '%</text>' +
               '</svg>';
     },

     damper: function(position) {
        // Use custom SVG if configured
        if (customSVGConfig.useCustomSVGs && customSVGConfig.paths.damper) {
           var size = customSVGConfig.sizes.damper;
           return '<img src="' + customSVGConfig.paths.damper + '" width="' + size.width + '" height="' + size.height + '" title="' + Math.round(position) + '%">';
        }

        // Otherwise generate SVG
        position = position || 0;
        var angle = (position / 100) * 80 - 40; // -40 to +40 degrees
        var color = position > 90 ? '#4CAF50' : position > 10 ? '#FFC107' : '#666';

        return '<svg width="50" height="30" viewBox="0 0 50 30">' +
               '<rect x="5" y="5" width="40" height="20" fill="#333" stroke="#666" stroke-width="1"/>' +
               '<line x1="10" y1="15" x2="40" y2="15" stroke="' + color + '" stroke-width="3" ' +
               'transform="rotate(' + angle + ' 25 15)"/>' +
               '<text x="25" y="27" text-anchor="middle" font-size="8" fill="#fff">' + Math.round(position) + '%</text>' +
               '</svg>';
     },

     valve: function(position) {
        // Use custom SVG if configured
        if (customSVGConfig.useCustomSVGs && customSVGConfig.paths.valve) {
           var size = customSVGConfig.sizes.valve;
           return '<img src="' + customSVGConfig.paths.valve + '" width="' + size.width + '" height="' + size.height + '" title="' + Math.round(position) + '%">';
        }

        // Otherwise generate SVG
        position = position || 0;
        var color = position > 90 ? '#4CAF50' : position > 10 ? '#FFC107' : '#666';

        return '<svg width="40" height="40" viewBox="0 0 40 40">' +
               '<circle cx="20" cy="20" r="15" fill="#333" stroke="#666" stroke-width="2"/>' +
               '<path d="M20,8 L28,20 L20,32 L12,20 Z" fill="' + color + '" opacity="' + (position / 100) + '"/>' +
               '<text x="20" y="38" text-anchor="middle" font-size="8" fill="#fff">' + Math.round(position) + '%</text>' +
               '</svg>';
     },

     statusIndicator: function(status, label) {
        var colors = {
           ok: '#4CAF50',
           alarm: '#F44336',
           fault: '#FF9800',
           down: '#9E9E9E',
           disabled: '#607D8B'
        };
        var color = colors[status] || '#666';
        var pulse = (status === 'alarm' || status === 'fault') ? 'animation: pulse 1s infinite;' : '';

        return '<style>@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }</style>' +
               '<svg width="60" height="30" viewBox="0 0 60 30">' +
               '<circle cx="15" cy="15" r="8" fill="' + color + '" style="' + pulse + '"/>' +
               '<text x="30" y="18" font-size="10" fill="#fff">' + (label || status) + '</text>' +
               '</svg>';
     },

     gauge: function(value, min, max, label) {
        min = min || 0;
        max = max || 100;
        label = label || '';
        var percent = Math.max(0, Math.min(100, ((value - min) / (max - min)) * 100));
        var angle = (percent / 100) * 180 - 90; // -90 to +90 degrees
        var color = percent < 33 ? '#4CAF50' : percent < 66 ? '#FFC107' : '#FF5722';

        return '<svg width="60" height="40" viewBox="0 0 60 40">' +
               '<path d="M10,35 A20,20 0 0,1 50,35" fill="none" stroke="#333" stroke-width="4"/>' +
               '<path d="M10,35 A20,20 0 0,1 ' + (30 + 20*Math.cos(angle*Math.PI/180)) + ',' + (35 + 20*Math.sin(angle*Math.PI/180)) + '" ' +
               'fill="none" stroke="' + color + '" stroke-width="4"/>' +
               '<circle cx="30" cy="35" r="3" fill="' + color + '"/>' +
               '<text x="30" y="15" text-anchor="middle" font-size="10" fill="#fff">' + Math.round(value) + '</text>' +
               '</svg>';
     }
  };

  // Setup subscriptions with visual updates
  function setupSubscriptionsWithVisuals(subList) {
     if(subList.length === 0) return;
     subList.forEach(function(item) {
        baja.Ord.make(item.ord).get({ subscriber: currentSubscriber }).then(function(comp) {
           var update = function() {
              var el = document.getElementById(item.id); if(!el) return;
              var val = "Err";
              try {
                if(this.getOutDisplay) val = this.getOutDisplay();
                else {
                   var v = this.get('out'); if(v===undefined) v = this.get('value');
                   if(v!==undefined && v!==null) val = v.toString();
                }
              } catch(e){
              }
              el.textContent = val;
              if(['true','on','active','occupied'].indexOf(String(val).toLowerCase()) > -1) el.className = 'val-cell active';
              else if(['false','off','inactive','unoccupied'].indexOf(String(val).toLowerCase()) > -1) el.className = 'val-cell inactive';
              else el.className = 'val-cell';

              // Update visual if element exists
              if (item.visualId && item.classification) {
                 var visualCell = document.getElementById(item.visualId);
                 if (visualCell) {
                    var numVal = parseFloat(val);
                    if (!isNaN(numVal)) {
                       visualCell.innerHTML = getVisualForPoint(item.classification, numVal, val);
                    }
                 }
              }
           };
           comp.attach('changed', update);
           update.call(comp); // Initial update
        }).catch(function(err) {
        });
     });
  }

  function getVisualForPoint(classification, numValue, rawValue) {
     var category = classification.category;

     if (category === 'temperature') {
        return SvgGraphics.thermometer(numValue, 0, 100, '°F');
     } else if (category === 'speed') {
        var isRunning = numValue > 5;
        return SvgGraphics.fan(numValue, isRunning);
     } else if (category === 'position') {
        if (classification.subcategory === 'damper') {
           return SvgGraphics.damper(numValue);
        } else if (classification.subcategory === 'valve') {
           return SvgGraphics.valve(numValue);
        } else {
           return SvgGraphics.gauge(numValue, 0, 100, '%');
        }
     } else if (category === 'call' || category === 'status') {
        var status = numValue > 50 ? 'ok' : 'off';
        return SvgGraphics.statusIndicator(status, Math.round(numValue) + '%');
     } else if (category === 'pressure' || category === 'flow') {
        return SvgGraphics.gauge(numValue, 0, 100, '');
     }

     return '<span style="font-size:11px; color:#888;">-</span>';
  }

  window.addGlobalColumn = function() {
     var val = document.getElementById('availablePointsDropdown').value; if(!val) return;
     globalColumns.push({ label: val, match: [val] }); refreshCurrentView(); refreshHistoryPointDropdown();
  };
  window.removeColumn = function(idx) { if(confirm("Remove?")) { globalColumns.splice(idx, 1); refreshCurrentView(); refreshHistoryPointDropdown(); } };
  function refreshCurrentView() {
     if(document.getElementById('multiView').classList.contains('active')) loadMultiMatrix();
  }

  // --- NEW ENHANCED HISTORY FUNCTIONS ---

  // Add selected points to the list for multi-point comparison
  window.addSelectedPoints = function() {
      var dropdown = document.getElementById('histUnitDropdown');
      var pointDropdown = document.getElementById('histPointDropdown');
      var equipmentName = dropdown && dropdown.selectedOptions[0] ? dropdown.selectedOptions[0].text : null;

      if (!equipmentName || !pointDropdown.selectedOptions.length) {
          alert("Please select equipment and at least one point!");
          return;
      }

      // Add each selected point
      for (var i = 0; i < pointDropdown.selectedOptions.length; i++) {
          var option = pointDropdown.selectedOptions[i];
          var historyId = option.value;
          var pointName = option.text;

          // Check if already added
          var exists = selectedHistoryPoints.some(function(p) {
              return p.historyId === historyId;
          });

          if (!exists) {
              selectedHistoryPoints.push({
                  equipment: equipmentName,
                  pointName: pointName,
                  historyId: historyId,
                  displayName: equipmentName + " - " + pointName
              });
          }
      }

      updateSelectedPointsList();
  };

  function updateSelectedPointsList() {
      var content = document.getElementById('selectedPointsContent');

      if (selectedHistoryPoints.length === 0) {
          content.innerHTML = '<span style="color:#888;">None selected</span>';
          return;
      }

      var html = '';
      selectedHistoryPoints.forEach(function(point, idx) {
          html += '<div style="display:inline-block; background:#2d2d2d; padding:4px 8px; margin:2px; border-radius:4px;">';
          html += '<span>' + point.displayName + '</span>';
          html += ' <button onclick="window.removeHistoryPoint(' + idx + ')" style="background:none; border:none; color:#f44336; cursor:pointer; font-weight:bold; margin-left:5px;">×</button>';
          html += '</div>';
      });

      content.innerHTML = html;
  }

  window.removeHistoryPoint = function(index) {
      selectedHistoryPoints.splice(index, 1);
      updateSelectedPointsList();
  };

  window.clearAllHistoryPoints = function() {
      selectedHistoryPoints = [];
      historyQueryResults = {};
      updateSelectedPointsList();
      if (chartInstance) {
          chartInstance.destroy();
          chartInstance = null;
      }
      document.getElementById('historyDataTable').style.display = 'none';
  };

  window.updateDateInputs = function() {
      var period = document.getElementById('histPeriod').value;
      var endDate = new Date();
      var startDate = new Date();

      if (period === 'last24h') {
          startDate.setHours(startDate.getHours() - 24);
      } else if (period === 'last48h') {
          startDate.setHours(startDate.getHours() - 48);
      } else if (period === 'lastWeek') {
          startDate.setDate(startDate.getDate() - 7);
      } else if (period === 'lastMonth') {
          startDate.setMonth(startDate.getMonth() - 1);
      } else {
          return;
      }

      document.getElementById('histStartDate').value = window.formatDatetimeLocal(startDate);
      document.getElementById('histEndDate').value = window.formatDatetimeLocal(endDate);
  };

  // formatDatetimeLocal - uses window.formatDatetimeLocal from chart-utils.js

  // Get current status for a point (used for status indicators)
  function fetchPointStatus(pointPath) {
      return new Promise(function(resolve) {
          if (!pointPath) {
              resolve(null);
              return;
          }

          try {
              baja.Ord.make('station:|' + pointPath).get()
                  .then(function(component) {
                      try {
                          var status = component.getStatus ? component.getStatus() : null;
                          if (status) {
                              var statusInfo = {
                                  isOk: status.isOk(),
                                  isAlarm: status.isAlarm(),
                                  isDown: status.isDown(),
                                  isStale: status.isStale(),
                                  isFault: status.isFault(),
                                  isDisabled: status.isDisabled(),
                                  isOverridden: status.isOverridden(),
                                  isUnackedAlarm: status.isUnackedAlarm(),
                                  statusText: status.flagsToString(),
                                  rawStatus: status
                              };
                              resolve(statusInfo);
                          } else {
                              resolve(null);
                          }
                      } catch (e) {
                          resolve(null);
                      }
                  })
                  .catch(function(err) {
                      resolve(null);
                  });
          } catch (e) {
              resolve(null);
          }
      });
  }

  // getStatusEmoji - uses window.getStatusEmoji from chart-utils.js

  window.plotHistoryChart = function() {
      if (selectedHistoryPoints.length === 0) {
          alert("Please add at least one point to plot!");
          return;
      }

      var status = document.getElementById('status');
      status.textContent = "Querying " + selectedHistoryPoints.length + " histories...";
      status.className = "status";

      var startDateStr = document.getElementById('histStartDate').value;
      var endDateStr = document.getElementById('histEndDate').value;

      if (!startDateStr || !endDateStr) {
          updateDateInputs();
          startDateStr = document.getElementById('histStartDate').value;
          endDateStr = document.getElementById('histEndDate').value;
      }

      var startDate = new Date(startDateStr);
      var endDate = new Date(endDateStr);

      historyQueryResults = {};
      historyMetadata = {}; // Track metadata like isBoolean (using global variable)
      var promises = [];

      selectedHistoryPoints.forEach(function(point) {
          var promise = queryHistoryData(point.historyId, startDate, endDate)
              .then(function(result) {
                  var dataPoints = result.data || result; // Handle both old and new format
                  var isBoolean = result.isBoolean || false;
                  var statusSummary = result.statusSummary || {};
                  var hasNonOkStatus = result.hasNonOkStatus || false;
                  historyQueryResults[point.displayName] = dataPoints;
                  historyMetadata[point.displayName] = {
                      isBoolean: isBoolean,
                      statusSummary: statusSummary,
                      hasNonOkStatus: hasNonOkStatus
                  };
              })
              .catch(function(err) {
                  historyQueryResults[point.displayName] = [];
                  historyMetadata[point.displayName] = { isBoolean: false };
              });
          promises.push(promise);
      });

      Promise.all(promises).then(function() {
          // Status is now included in history query results, no need to fetch separately
          // Check time range overlap
          var allTimestamps = [];
          for (var label in historyQueryResults) {
              if (historyQueryResults[label].length > 0) {
                  allTimestamps.push({
                      label: label,
                      first: historyQueryResults[label][0].x,
                      last: historyQueryResults[label][historyQueryResults[label].length - 1].x
                  });
              }
          }

          renderHistoryChart();
          renderDataTable();

          // Warn if datasets don't overlap well
          if (allTimestamps.length >= 2) {
              var overallMin = Math.min.apply(null, allTimestamps.map(function(t) { return t.first; }));
              var overallMax = Math.max.apply(null, allTimestamps.map(function(t) { return t.last; }));
              var overallRange = overallMax - overallMin;

              var poorOverlap = allTimestamps.some(function(ts) {
                  var dataRange = ts.last - ts.first;
                  return dataRange < (overallRange * 0.5); // Data only covers half the total range
              });

              if (poorOverlap) {
                  status.textContent = "⚠️ Chart loaded - Note: Some datasets have different time ranges (sparse data)";
                  status.className = "status";
              } else {
                  status.textContent = "Chart loaded with " + selectedHistoryPoints.length + " points";
                  status.className = "status";
              }
          } else {
              status.textContent = "Chart loaded with " + selectedHistoryPoints.length + " points";
              status.className = "status";
          }
      });
  };

  // Point classification - uses window.classifyPoint from chart-utils.js
  // Smart color assignment - uses window.getSmartColorForPoint from chart-utils.js

  function renderHistoryChart() {
      var ctx = document.getElementById('myChart').getContext('2d');
      if (chartInstance) chartInstance.destroy();

      var chartType = document.getElementById('histChartType').value;
      var yAxisMode = document.getElementById('histYAxisMode').value;
      var showGrid = document.getElementById('histShowGrid').checked;
      var statusFilter = document.getElementById('histStatusFilter').value;
      var categoryFilter = document.getElementById('histCategoryFilter').value;

      var datasets = [];
      var colorIdx = 0;
      // Keep fallback colors array for edge cases
      var fallbackColors = ['#3498db', '#e74c3c', '#f39c12', '#2ecc71', '#9b59b6', '#1abc9c', '#34495e', '#e67e22'];

      // Apply filters to determine which points to show
      var filteredResults = {};
      for (var label in historyQueryResults) {
          var metadata = historyMetadata[label];
          var hasNonOkStatus = metadata && metadata.hasNonOkStatus;
          var statusSummary = metadata && metadata.statusSummary;
          var includePoint = false;

          // First check category filter
          var categoryMatch = true;
          if (categoryFilter !== 'all') {
              var classification = window.classifyPoint(label);
              categoryMatch = (classification.category === categoryFilter ||
                              (categoryFilter === 'power' && classification.category === 'energy'));
          }

          // Skip if category doesn't match
          if (!categoryMatch) continue;

          if (statusFilter === 'all') {
              includePoint = true;
          } else if (statusFilter === 'alarmsOnly') {
              // Only include points with alarm status
              if (hasNonOkStatus && statusSummary) {
                  for (var flag in statusSummary) {
                      if (flag.toLowerCase().includes('alarm')) {
                          includePoint = true;
                          break;
                      }
                  }
              }
          } else if (statusFilter === 'faultsOnly') {
              // Only include points with fault status
              if (hasNonOkStatus && statusSummary) {
                  for (var flag in statusSummary) {
                      if (flag.toLowerCase().includes('fault')) {
                          includePoint = true;
                          break;
                      }
                  }
              }
          } else if (statusFilter === 'anyIssue') {
              // Include any point with non-OK status
              includePoint = hasNonOkStatus;
          } else if (statusFilter === 'okOnly') {
              // Only include points with OK status
              includePoint = !hasNonOkStatus;
          }

          if (includePoint) {
              filteredResults[label] = historyQueryResults[label];
          }
      }

      // Determine value ranges for smart Y-axis assignment (using filtered results)
      var allValues = [];
      for (var label in filteredResults) {
          var values = filteredResults[label].map(function(p) { return p.y; });
          allValues = allValues.concat(values);
      }

      var minVal = Math.min.apply(null, allValues);
      var maxVal = Math.max.apply(null, allValues);
      var range = maxVal - minVal;

      // Build datasets with smart Y-axis assignment (using filtered results)
      for (var label in filteredResults) {
          var datasetValues = filteredResults[label].map(function(p) { return p.y; });
          var datasetMin = Math.min.apply(null, datasetValues);
          var datasetMax = Math.max.apply(null, datasetValues);
          var datasetRange = datasetMax - datasetMin;

          // Check if this dataset is boolean
          var isBoolean = historyMetadata[label] && historyMetadata[label].isBoolean;

          // Check if this is a flat line (no variation, like last-known-state)
          var isFlatLine = (datasetRange === 0 && historyQueryResults[label].length === 2);

          // Add indicator to label for special states and point status
          var displayLabel = label;
          var hasNonOkStatus = historyMetadata[label] && historyMetadata[label].hasNonOkStatus;
          var statusSummary = historyMetadata[label] && historyMetadata[label].statusSummary;

          if (isFlatLine) {
              var stateText = datasetMin === 0 ? 'OFF' : (datasetMin === 1 ? 'ON' : datasetMin.toFixed(1));
              displayLabel = label + ' [Last: ' + stateText + ']';
          }

          // Add status indicator if point had non-OK status during history period
          if (hasNonOkStatus && statusSummary) {
              // Find the most severe non-OK status from the summary
              // Check all status flag keys (case-insensitive)
              var statusEmoji = '';
              var statusText = '';

              // Check for each status type by looking at all keys in statusSummary
              for (var statusFlag in statusSummary) {
                  var flagLower = statusFlag.toLowerCase();

                  if (flagLower.includes('alarm')) {
                      statusEmoji = '🔴';
                      statusText = 'alarm';
                      break; // Alarm is highest priority
                  } else if (flagLower.includes('fault')) {
                      if (!statusEmoji) {
                          statusEmoji = '❌';
                          statusText = 'fault';
                      }
                  } else if (flagLower.includes('down')) {
                      if (!statusEmoji) {
                          statusEmoji = '⚫';
                          statusText = 'down';
                      }
                  } else if (flagLower.includes('stale')) {
                      if (!statusEmoji) {
                          statusEmoji = '⚠️';
                          statusText = 'stale';
                      }
                  } else if (flagLower.includes('disabled')) {
                      if (!statusEmoji) {
                          statusEmoji = '🚫';
                          statusText = 'disabled';
                      }
                  } else if (flagLower.includes('overridden') || flagLower.includes('override')) {
                      if (!statusEmoji) {
                          statusEmoji = '🔧';
                          statusText = 'overridden';
                      }
                  }
              }

              if (statusEmoji) {
                  displayLabel = statusEmoji + ' ' + displayLabel + ' [' + statusText + ']';
              }
          }

          // Determine Y-axis assignment
          var useY2 = false;

          // Check if ANY dataset is boolean - if so, reserve Y2 exclusively for booleans
          var anyBooleans = false;
          for (var checkLabel in filteredResults) {
              if (historyMetadata[checkLabel] && historyMetadata[checkLabel].isBoolean) {
                  anyBooleans = true;
                  break;
              }
          }

          if (anyBooleans) {
              // Boolean-priority mode: ONLY booleans go to Y2, all others to Y
              useY2 = isBoolean;
          } else {
              // Normal mode: use Y2 based on mode settings when no booleans present
              if (yAxisMode === 'separate') {
                  useY2 = colorIdx >= Math.floor(Object.keys(filteredResults).length / 2);
              } else if (yAxisMode === 'auto' && datasets.length >= 1) {
                  // Use Y2 if dataset's midpoint is more than 30% away from overall midpoint
                  var overallMid = (minVal + maxVal) / 2;
                  var datasetMid = (datasetMin + datasetMax) / 2;
                  var midpointDiff = Math.abs(datasetMid - overallMid);
                  useY2 = (midpointDiff > (range * 0.3));
              }
          }

          // Get intelligent color based on point name
          var smartColor = window.getSmartColorForPoint(label);

          datasets.push({
              label: displayLabel,
              data: filteredResults[label],
              borderColor: smartColor,
              backgroundColor: smartColor + (isFlatLine ? '60' : '40'), // More opaque for flat lines
              borderWidth: isFlatLine ? 3 : 2, // Thicker lines for flat/unchanged states
              fill: chartType === 'line' && !isFlatLine, // Don't fill flat lines
              tension: 0.1,
              pointRadius: chartType === 'scatter' ? 4 : (isFlatLine ? 2 : 0), // Show points on flat lines
              yAxisID: useY2 ? 'y2' : 'y',
              spanGaps: true,
              stepped: isBoolean ? true : false,  // Use step chart for boolean values
              borderDash: isFlatLine ? [5, 5] : [] // Dashed line for unchanged states
          });
          colorIdx++;
      }

      var useDualAxes = yAxisMode === 'separate' || (yAxisMode === 'auto' && datasets.some(function(d) { return d.yAxisID === 'y2'; }));

      // Check if we have any boolean datasets (they will be on Y2)
      var hasBooleans = datasets.some(function(d) {
          var label = d.label.replace(/\s*\[Last:.*\]/, ''); // Remove state label
          return historyMetadata[label] && historyMetadata[label].isBoolean;
      });

      chartInstance = new Chart(ctx, {
          type: chartType,
          data: { datasets: datasets },
          options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: 'index', intersect: false },
              scales: (function() {
                  var scales = {
                      x: {
                          type: 'linear',
                          position: 'bottom',
                          title: { display: true, text: 'Time', color: '#e0e0e0' },
                          ticks: {
                              color: '#888',
                              maxTicksLimit: 10,
                              callback: function(value) {
                                  var d = new Date(value);
                                  return d.toLocaleString([], { month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                              }
                          },
                          grid: { display: showGrid, color: '#333' }
                      },
                      y: {
                          type: 'linear',
                          position: 'left',
                          title: { display: true, text: 'Value', color: '#e0e0e0' },
                          grid: { display: showGrid, color: '#333' },
                          ticks: { color: '#888', precision: 1 },
                          beginAtZero: false,
                          grace: '10%'
                      }
                  };

                  if (useDualAxes) {
                      scales.y2 = {
                          type: 'linear',
                          position: 'right',
                          title: { display: true, text: hasBooleans ? 'Boolean State (ON/OFF)' : 'Value (Alt)', color: '#e0e0e0' },
                          grid: { display: false },
                          ticks: {
                              color: '#888',
                              precision: 0,
                              callback: function(value) {
                                  // Show ON/OFF labels for boolean axis
                                  if (hasBooleans) {
                                      if (value === 0) return 'OFF';
                                      if (value === 1) return 'ON';
                                      return value;
                                  }
                                  return value;
                              }
                          },
                          beginAtZero: hasBooleans ? true : false,
                          min: hasBooleans ? -0.1 : undefined,  // Add padding below 0 for visibility
                          max: hasBooleans ? 1.1 : undefined,   // Add padding above 1 for visibility
                          grace: hasBooleans ? 0 : '10%'
                      };
                  }

                  return scales;
              })(),
              plugins: {
                  legend: {
                      labels: {
                          color: '#e0e0e0',
                          generateLabels: function(chart) {
                              var datasets = chart.data.datasets;
                              return datasets.map(function(dataset, i) {
                                  var meta = chart.getDatasetMeta(i);
                                  var label = dataset.label || '';
                                  return {
                                      text: label + ' ✕',  // Add X to end of label
                                      fillStyle: dataset.backgroundColor,
                                      strokeStyle: dataset.borderColor,
                                      lineWidth: 2,
                                      hidden: meta.hidden,
                                      datasetIndex: i
                                  };
                              });
                          }
                      },
                      onClick: function(e, legendItem, legend) {
                          var index = legendItem.datasetIndex;
                          var chart = legend.chart;

                          // Get the legend item's bounding box to detect what was clicked
                          var legendElement = legend.legendHitBoxes[index];
                          var clickX = e.native.offsetX || e.x;

                          // Calculate position relative to legend item
                          var relativeX = clickX - legendElement.left;
                          var boxWidth = 40; // Approximate width of the color box

                          // If clicked on the color box (left side), open color picker
                          if (relativeX <= boxWidth) {
                              // Create color picker
                              var currentColor = chart.data.datasets[index].borderColor;
                              var input = document.createElement('input');
                              input.type = 'color';
                              input.value = currentColor;
                              input.style.position = 'absolute';
                              input.style.left = e.native.pageX + 'px';
                              input.style.top = e.native.pageY + 'px';
                              input.style.opacity = '0';
                              document.body.appendChild(input);

                              input.addEventListener('change', function() {
                                  var newColor = input.value;
                                  chart.data.datasets[index].borderColor = newColor;
                                  chart.data.datasets[index].backgroundColor = newColor + '40'; // Add transparency
                                  chart.update();
                                  document.body.removeChild(input);
                              });

                              input.addEventListener('blur', function() {
                                  document.body.removeChild(input);
                              });

                              input.click();
                          } else {
                              // Clicked on text/X - toggle visibility
                              var meta = chart.getDatasetMeta(index);
                              meta.hidden = !meta.hidden;
                              chart.update();
                          }
                      }
                  },
                  tooltip: {
                      mode: 'index',
                      intersect: false,
                      callbacks: {
                          title: function(context) {
                              if (context.length > 0) {
                                  var d = new Date(context[0].parsed.x);
                                  return d.toLocaleString();
                              }
                              return '';
                          },
                          afterBody: function(context) {
                              if (context.length === 0) return [];

                              // Get the timestamp being hovered
                              var hoverTimestamp = context[0].parsed.x;

                              // Track which datasets were already shown in context
                              var shownDatasetIndices = {};
                              context.forEach(function(item) {
                                  shownDatasetIndices[item.datasetIndex] = true;
                              });

                              // Build list of additional points (those not shown in default tooltip)
                              var additionalLines = [];

                              // Iterate through all datasets to find missing ones
                              var chart = context[0].chart;
                              chart.data.datasets.forEach(function(dataset, datasetIndex) {
                                  var meta = chart.getDatasetMeta(datasetIndex);
                                  if (meta.hidden) return; // Skip hidden datasets
                                  if (shownDatasetIndices[datasetIndex]) return; // Already shown

                                  var label = dataset.label;
                                  var pointName = label.replace(/^[🔴⚫❌⚠️🚫🔧]\s*/, '').replace(/\s*\[.*\]/, ''); // Remove emojis and status tags

                                  // Find the last known value at or before hover timestamp
                                  var value = null;
                                  var valueType = '';

                                  // Get raw data for this point
                                  var rawData = historyQueryResults[pointName];
                                  if (rawData && rawData.length > 0) {
                                      // Find last known value at or before hover timestamp
                                      for (var i = rawData.length - 1; i >= 0; i--) {
                                          if (rawData[i].x <= hoverTimestamp) {
                                              value = rawData[i].y;

                                              // Check if boolean for special formatting
                                              if (historyMetadata[pointName] && historyMetadata[pointName].isBoolean) {
                                                  valueType = value === 1 ? ' (ON)' : ' (OFF)';
                                              }
                                              break;
                                          }
                                      }
                                  }

                                  // Only show if we found a last known value
                                  if (value !== null) {
                                      var valueDisplay = value.toFixed(2) + valueType + ' [last known]';
                                      additionalLines.push(label + ': ' + valueDisplay);
                                  }
                              });

                              return additionalLines;
                          },
                          label: function(context) {
                              var label = context.dataset.label || '';
                              var pointName = label.replace(/^[🔴⚫❌⚠️🚫🔧]\s*/, '').replace(/\s*\[.*\]/, ''); // Remove emojis and status tags

                              // Get the hover timestamp
                              var hoverTimestamp = context.parsed.x;

                              // Find the actual value at or before this timestamp
                              var rawData = historyQueryResults[pointName];
                              var value = null;
                              var valueType = '';
                              var isLastKnown = false;

                              if (rawData && rawData.length > 0) {
                                  // Find last known value at or before hover timestamp
                                  for (var i = rawData.length - 1; i >= 0; i--) {
                                      if (rawData[i].x <= hoverTimestamp) {
                                          value = rawData[i].y;
                                          isLastKnown = (rawData[i].x < hoverTimestamp); // Not exact match

                                          // Check if boolean for special formatting
                                          if (historyMetadata[pointName] && historyMetadata[pointName].isBoolean) {
                                              valueType = value === 1 ? ' (ON)' : ' (OFF)';
                                          }
                                          break;
                                      }
                                  }
                              }

                              // Format the value display
                              var valueDisplay = value !== null ? value.toFixed(2) + valueType : '(no data)';
                              if (isLastKnown) {
                                  valueDisplay += ' [last known]';
                              }

                              return label + ': ' + valueDisplay;
                          }
                      }
                  },
                  zoom: {
                      zoom: {
                          wheel: {
                              enabled: true,
                              speed: 0.1
                          },
                          pinch: {
                              enabled: true
                          },
                          drag: {
                              enabled: true,
                              backgroundColor: 'rgba(52, 152, 219, 0.3)',
                              borderColor: 'rgba(52, 152, 219, 0.8)',
                              borderWidth: 1
                          },
                          mode: 'x'
                      },
                      pan: {
                          enabled: true,
                          mode: 'x',
                          modifierKey: 'ctrl'
                      },
                      limits: {
                          x: { min: 'original', max: 'original' }
                      }
                  }
              }
          }
      });
  }

  function renderDataTable() {
      var table = document.getElementById('histDataTableContent');
      var html = '<thead><tr><th>Timestamp</th><th>Point</th><th>Value</th><th>Status</th></tr></thead><tbody>';

      var allRecords = [];
      for (var label in historyQueryResults) {
          // Get status summary for this point
          var statusSummary = historyMetadata[label] && historyMetadata[label].statusSummary ? historyMetadata[label].statusSummary : null;
          var hasNonOkStatus = historyMetadata[label] && historyMetadata[label].hasNonOkStatus;

          // Determine status display text
          var statusDisplay = '✅ OK';
          if (hasNonOkStatus && statusSummary) {
              // Check all status flag keys (case-insensitive)
              for (var statusFlag in statusSummary) {
                  var flagLower = statusFlag.toLowerCase();

                  if (flagLower.includes('alarm')) {
                      statusDisplay = '🔴 Alarm';
                      break; // Alarm is highest priority
                  } else if (flagLower.includes('fault')) {
                      if (statusDisplay === '✅ OK') {
                          statusDisplay = '❌ Fault';
                      }
                  } else if (flagLower.includes('down')) {
                      if (statusDisplay === '✅ OK') {
                          statusDisplay = '⚫ Down';
                      }
                  } else if (flagLower.includes('stale')) {
                      if (statusDisplay === '✅ OK') {
                          statusDisplay = '⚠️ Stale';
                      }
                  } else if (flagLower.includes('disabled')) {
                      if (statusDisplay === '✅ OK') {
                          statusDisplay = '🚫 Disabled';
                      }
                  } else if (flagLower.includes('overridden') || flagLower.includes('override')) {
                      if (statusDisplay === '✅ OK') {
                          statusDisplay = '🔧 Overridden';
                      }
                  }
              }
          }

          historyQueryResults[label].forEach(function(record) {
              allRecords.push({
                  timestamp: record.x,
                  point: label,
                  value: record.y,
                  status: statusDisplay
              });
          });
      }

      allRecords.sort(function(a, b) { return a.timestamp - b.timestamp; });

      allRecords.slice(0, 500).forEach(function(record) {
          var d = new Date(record.timestamp);
          html += '<tr><td>' + d.toLocaleString() + '</td><td>' + record.point + '</td><td>' + record.value.toFixed(3) + '</td><td>' + record.status + '</td></tr>';
      });

      if (allRecords.length === 0) {
          html += '<tr><td colspan="4" style="text-align:center; color:#888;">No data to display</td></tr>';
      } else if (allRecords.length > 500) {
          html += '<tr><td colspan="4" style="text-align:center; color:#f39c12;">Showing first 500 of ' + allRecords.length + ' records</td></tr>';
      }

      html += '</tbody>';
      table.innerHTML = html;
  }

  window.toggleDataTable = function() {
      var table = document.getElementById('historyDataTable');
      table.style.display = table.style.display === 'none' ? 'block' : 'none';
  };

  window.resetChartZoom = function() {
      if (chartInstance) {
          if (chartInstance.resetZoom) {
              chartInstance.resetZoom();
          } else {
              // Fallback: re-render the chart
              plotHistoryChart();
          }
      }
  };

  window.resetChartColors = function() {
      if (chartInstance) {
          // Re-apply smart colors to all datasets
          chartInstance.data.datasets.forEach(function(dataset) {
              var label = dataset.label;
              // Remove status emoji and tags to get point name
              var pointName = label.replace(/^[🔴⚫❌⚠️🚫🔧]\s*/, '').replace(/\s*\[.*\]/, '');
              var smartColor = window.getSmartColorForPoint(pointName);
              dataset.borderColor = smartColor;
              dataset.backgroundColor = smartColor + '40'; // Add transparency
          });
          chartInstance.update();
      }
  };

  window.exportHistoryCSV = function() {
      var csv = 'Timestamp,Point,Value,Status\n';
      for (var label in historyQueryResults) {
          // Get status summary for this point
          var statusSummary = historyMetadata[label] && historyMetadata[label].statusSummary ? historyMetadata[label].statusSummary : null;
          var hasNonOkStatus = historyMetadata[label] && historyMetadata[label].hasNonOkStatus;

          // Determine status display text
          var statusDisplay = 'OK';
          if (hasNonOkStatus && statusSummary) {
              // Check all status flag keys (case-insensitive)
              for (var statusFlag in statusSummary) {
                  var flagLower = statusFlag.toLowerCase();

                  if (flagLower.includes('alarm')) {
                      statusDisplay = 'Alarm';
                      break; // Alarm is highest priority
                  } else if (flagLower.includes('fault')) {
                      if (statusDisplay === 'OK') {
                          statusDisplay = 'Fault';
                      }
                  } else if (flagLower.includes('down')) {
                      if (statusDisplay === 'OK') {
                          statusDisplay = 'Down';
                      }
                  } else if (flagLower.includes('stale')) {
                      if (statusDisplay === 'OK') {
                          statusDisplay = 'Stale';
                      }
                  } else if (flagLower.includes('disabled')) {
                      if (statusDisplay === 'OK') {
                          statusDisplay = 'Disabled';
                      }
                  } else if (flagLower.includes('overridden') || flagLower.includes('override')) {
                      if (statusDisplay === 'OK') {
                          statusDisplay = 'Overridden';
                      }
                  }
              }
          }

          historyQueryResults[label].forEach(function(record) {
              var d = new Date(record.x);
              csv += d.toISOString() + ',' + label + ',' + record.y + ',' + statusDisplay + '\n';
          });
      }
      var blob = new Blob([csv], { type: 'text/csv' });
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = 'history_data.csv';
      a.click();
      URL.revokeObjectURL(url);
  };


  // Initialize date inputs on load
  setTimeout(function() {
      updateDateInputs();
  }, 1000);

    // Wrap init in try-catch to prevent silent failures
    try {
      init();
    } catch (err) {
      console.error('❌ Fatal error in init():', err);
      var statusDiv = document.getElementById('status');
      if (statusDiv) {
        statusDiv.textContent = 'Initialization failed: ' + err.message;
        statusDiv.style.color = '#ff4444';
      }
      // At least show the page
      document.body.style.backgroundColor = "#1a1a1a";
      document.body.style.color = "#e0e0e0";
    }
  }
  
  // Try to load with RequireJS
  if (typeof require !== 'undefined') {
    require(["baja!", "Promise"], function (baja, Promise) {
      initializeDashboard(baja, Promise);
    }, function(err) {
      showError('Module Loading Error: Unable to load required components.<br>Please check your connection and refresh the page.');
      // Try to access baja directly after a delay
      setTimeout(function() {
        if (typeof baja !== 'undefined') {
          initializeDashboard(baja, typeof Promise !== 'undefined' ? Promise : null);
        } else {
          // Keep trying
          var attempts = 0;
          var checkBaja = setInterval(function() {
            attempts++;
            if (typeof baja !== 'undefined') {
              clearInterval(checkBaja);
              initializeDashboard(baja, typeof Promise !== 'undefined' ? Promise : null);
            } else if (attempts > 20) {
              clearInterval(checkBaja);
            }
          }, 500);
        }
      }, 2000);
    });
  } else {
    // RequireJS not available - wait a bit and try to access baja directly
    var attempts = 0;
    var checkBaja = setInterval(function() {
      attempts++;
      if (typeof baja !== 'undefined') {
        clearInterval(checkBaja);
        initializeDashboard(baja, typeof Promise !== 'undefined' ? Promise : null);
      } else if (attempts > 20) {
        clearInterval(checkBaja);
        showError('Connection Error: Unable to load required components.<br>Please check your connection and refresh the page.');
      }
    }, 500);
  }
})();

  // Initialize FAB on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFAB);
  } else {
    initFAB();
  }
</script>

<!-- Floating Action Button -->
<div class="fab-container" id="fabContainer">
  <!-- Hidden Points Panel -->
  <div class="hidden-points-panel" id="hiddenPointsPanel">
    <div class="hidden-points-header">
      <h3>Hidden Points</h3>
      <button class="hidden-points-close" onclick="window.closeHiddenPointsPanel()">×</button>
    </div>
    <div class="hidden-points-list" id="hiddenPointsList">
      <div class="hidden-points-empty">No hidden points</div>
    </div>
  </div>
  
  <!-- Context Menu -->
  <div class="fab-menu" id="fabMenu"></div>
  
  <!-- Main FAB Button -->
  <button class="fab-main" id="fabMain" onclick="window.toggleFABMenu()" title="Quick Actions">
    ⚙️
  </button>
</div>
</body>
</html>
</html>