<!-- @noSnoop -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Find Devices by Tag (n:device)</title>
  <style>
    body { font-family: Arial; background: #1e1e1e; color: #fff; padding: 20px; }
    button { background: #4CAF50; color: white; border: none; padding: 10px 20px; cursor: pointer; margin: 5px; }
    #result { background: #2d2d2d; padding: 15px; border-radius: 4px; margin-top: 10px; font-family: monospace; min-height: 100px; }
    .device-item { margin: 10px 0; padding: 10px; background: #3d3d3d; border-radius: 4px; }
    .tag-info { color: #4CAF50; margin-left: 20px; }
  </style>
</head>
<body>
  <h1>Find Devices by Tag (n:device)</h1>
  <p>This example focuses solely on finding and displaying components with the n:device tag.</p>
  
  <h2>What This Does</h2>
  <ul>
    <li>Uses BQL to query devices directly (fastest method - ~2.6s vs ~23.5s for NEQL)</li>
    <li>Batch resolves all devices efficiently</li>
    <li>Checks tags using component.tags() to find n:device tag</li>
    <li>Displays all devices with n:device tag</li>
    <li>Falls back to tree traversal if BQL fails</li>
  </ul>

  <button onclick="findDevices()">Find Devices with n:device Tag</button>
  <div id="result">Click button to find devices</div>

  <script type='text/javascript' src='/requirejs/config.js'></script>
  <script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js'></script>

  <script>
    /**
     * Focused Pattern: Find Devices by n:device Tag
     * 
     * Goal: Find and display all components that have the n:device tag
     * 
     * Approach (OPTIMIZED - BQL is 9x faster than NEQL):
     * 1. Use BQL to query devices directly: 'bql:select slotPath from bacnet:BacnetDevice'
     * 2. Clean paths (remove slot: prefix to avoid duplication)
     * 3. Batch resolve all device ORDs efficiently
     * 4. Check tags using component.tags() (async) to verify n:device tag
     * 5. Display devices that have n:device tag
     * 6. Fallback: Tree traversal if BQL fails
     * 
     * Performance (tested):
     * - BQL Method: ~2.6 seconds (1.7s query + 0.6s tag check)
     * - NEQL Method: ~23.5 seconds (21.3s query + 0.6s tag check) - NOT USED
     */
    
    window.findDevices = function() {
      const resultDiv = document.getElementById('result');
      resultDiv.innerHTML = 'Loading Baja...';
      
      if (typeof require !== 'undefined') {
        require(["baja!", "Promise"], function (baja, Promise) {
          runFindDevices(baja);
        }, function(err) {
          resultDiv.innerHTML = 'Error loading Baja: ' + (err.message || err);
        });
      } else {
        var attempts = 0;
        var checkBaja = setInterval(function() {
          attempts++;
          if (typeof baja !== 'undefined') {
            clearInterval(checkBaja);
            runFindDevices(baja);
          } else if (attempts > 20) {
            clearInterval(checkBaja);
            resultDiv.innerHTML = 'Error: Baja not available';
          }
        }, 500);
      }
    };
    
    function runFindDevices(baja) {
      const resultDiv = document.getElementById('result');
      resultDiv.innerHTML = 'üîç Querying for devices AND points using BQL (to find all components with n:device tag)...';
      
      // Strategy: BQL queries by component TYPE, not by tags
      // So we need to query BOTH devices AND points, then check tags on all of them
      // This ensures we find:
      // 1. Devices with n:device tag (from device query)
      // 2. Points with n:device tag (from points query - e.g., points inside points folders)
      // Performance: BQL ~2.6s vs NEQL ~23.5s (9x faster!)
      // Fallback to tree traversal if BQL doesn't work
      
      const deviceBql = "station:|slot:/Drivers/BacnetNetwork|bql:select slotPath from bacnet:BacnetDevice";
      const pointsBql = "station:|slot:/Drivers/BacnetNetwork|bql:select slotPath from control:ControlPoint";
      
      // Query both devices and points in parallel
      Promise.all([
        new Promise(function(resolve, reject) {
          const timeout = setTimeout(function() { reject(new Error('Device query timeout')); }, 60000);
          baja.Ord.make(deviceBql).get().then(function(table) {
            clearTimeout(timeout);
            if (!table) {
              resolve([]);
              return;
            }
            const slotPaths = [];
            table.cursor({
              limit: 10000,
              each: function(record) {
                try {
                  let slotPath = record.get('slotPath')?.toString() || '';
                  if (slotPath) {
                    slotPath = slotPath.replace(/^slot:/, '').trim();
                    if (slotPath) {
                      slotPaths.push(slotPath);
                    }
                  }
                } catch(e) {}
              },
              after: function() {
                resolve(slotPaths);
              }
            });
          }).catch(function(err) {
            clearTimeout(timeout);
            resolve([]); // Return empty array on error, don't fail completely
          });
        }),
        new Promise(function(resolve, reject) {
          const timeout = setTimeout(function() { reject(new Error('Points query timeout')); }, 60000);
          baja.Ord.make(pointsBql).get().then(function(table) {
            clearTimeout(timeout);
            if (!table) {
              resolve([]);
              return;
            }
            const slotPaths = [];
            table.cursor({
              limit: 10000,
              each: function(record) {
                try {
                  let slotPath = record.get('slotPath')?.toString() || '';
                  if (slotPath) {
                    slotPath = slotPath.replace(/^slot:/, '').trim();
                    if (slotPath) {
                      slotPaths.push(slotPath);
                    }
                  }
                } catch(e) {}
              },
              after: function() {
                resolve(slotPaths);
              }
            });
          }).catch(function(err) {
            clearTimeout(timeout);
            resolve([]); // Return empty array on error, don't fail completely
          });
        })
      ]).then(function(results) {
        const devicePaths = results[0];
        const pointPaths = results[1];
        
        // Combine all paths - we'll check tags on all of them
        const allPaths = new Set();
        
        // Add device paths
        devicePaths.forEach(function(path) {
          let cleanPath = path.toString().replace(/^slot:/, '').trim();
          cleanPath = cleanPath.startsWith('/') ? cleanPath : '/' + cleanPath;
          allPaths.add(cleanPath);
        });
        
        // Add point paths (these might be points with n:device tag)
        pointPaths.forEach(function(path) {
          let cleanPath = path.toString().replace(/^slot:/, '').trim();
          cleanPath = cleanPath.startsWith('/') ? cleanPath : '/' + cleanPath;
          allPaths.add(cleanPath);
        });
        
        resultDiv.innerHTML = '‚úÖ BQL queries successful!<br>' +
          'Found ' + devicePaths.length + ' device(s) and ' + pointPaths.length + ' point(s)<br>' +
          'Total components to check: ' + allPaths.size + '<br>' +
          'Checking tags on all components...';
        
        // Convert to ORDs
        const componentOrds = Array.from(allPaths).map(function(path) {
          let cleanPath = path.toString().replace(/^slot:/, '').trim();
          cleanPath = cleanPath.startsWith('/') ? cleanPath : '/' + cleanPath;
          return 'station:|slot:' + cleanPath;
        }).filter(function(ord) {
          return ord && !ord.includes('slot:slot:');
        });
        
        processDeviceOrds(baja, componentOrds, resultDiv);
      }).catch(function(err) {
        // BQL failed - try fallback: tree traversal
        console.log('BQL query failed, trying tree traversal:', err);
        resultDiv.innerHTML = 'BQL query failed, trying tree traversal...';
        
        // Fallback: Tree traversal
        const networkPath = '/Drivers/BacnetNetwork';
        const networkOrd = 'station:|slot:' + networkPath;
        
        // Add timeout for tree traversal
        new Promise(function(resolve, reject) {
          const timeout = setTimeout(function() { 
            reject(new Error('Traversal timeout (60s)')); 
          }, 60000);
          
          baja.Ord.make(networkOrd).get().then(function(networkFolder) {
            clearTimeout(timeout);
            resolve(networkFolder);
          }).catch(function(err) {
            clearTimeout(timeout);
            reject(err);
          });
        }).then(function(networkFolder) {
          traverseTreeForDevices(baja, networkFolder, networkPath, resultDiv);
        }).catch(function(err) {
          resultDiv.innerHTML = '‚ùå Error: ' + (err.message || err);
          console.error('‚ùå Error:', err);
        });
      });
    }
    
    function processDeviceOrds(baja, ords, resultDiv) {
      const devicesWithTag = [];
      const tagCheckPromises = [];
      
      resultDiv.innerHTML = 'Batch resolving ' + ords.length + ' components...<br>' +
        'Checking tags...';
      
      // Use BatchResolve to efficiently resolve all components at once
      const batchResolve = new baja.BatchResolve(ords);
      
      batchResolve.resolve({
        each: function(component, index) {
          const ord = ords[index];
          if (!ord) return;
          
          const deviceName = component.getDisplayName ? component.getDisplayName() : 
                           (component.getName ? component.getName() : 'Unknown');
          const path = ord.replace('station:|slot:', '');
          
          // Collect tag check promise - we'll wait for all of them
          const tagCheckPromise = component.tags().then(function(tags) {
            try {
              const allTags = tags.getAll ? tags.getAll() : [];
              const deviceTag = allTags.find(function(tag) {
                if (!tag.getId) return false;
                const tagId = tag.getId();
                if (typeof tagId === 'object' && tagId.$qname) {
                  return tagId.$qname === 'n:device';
                } else if (typeof tagId === 'string') {
                  return tagId === 'n:device';
                }
                if (tagId.$dict === 'n' && tagId.$name === 'device') {
                  return true;
                }
                return false;
              });
              
              // Only add to results if it has the n:device tag
              if (deviceTag) {
                const tagValue = deviceTag.getValue ? deviceTag.getValue().toString() : '';
                const tagId = deviceTag.getId();
                const tagIdStr = tagId && tagId.$qname ? tagId.$qname : 
                                (typeof tagId === 'string' ? tagId : 'n:device');
                
                devicesWithTag.push({
                  name: deviceName,
                  path: path,
                  ord: ord,
                  tagValue: tagValue,
                  tagId: tagIdStr,
                  allTags: allTags.map(function(t) {
                    const tId = t.getId();
                    const tIdStr = (tId && tId.$qname) ? tId.$qname : 
                                  (typeof tId === 'string' ? tId : 'unknown');
                    return {
                      id: tIdStr,
                      value: t.getValue ? t.getValue().toString() : ''
                    };
                  })
                });
                
                // Update progress
                if (devicesWithTag.length % 10 === 0) {
                  resultDiv.innerHTML = 'Checking tags... (' + devicesWithTag.length + ' components with n:device tag found so far)<br>' +
                    'Total checked: ' + (index + 1) + '/' + ords.length;
                }
              }
              
              return { index: index, hasTag: !!deviceTag };
            } catch(e) {
              console.warn('Error checking tags for', ord, e);
              return { index: index, hasTag: false, error: e };
            }
          }).catch(function(err) {
            console.warn('Error getting tags for', ord, err);
            return { index: index, hasTag: false, error: err };
          });
          
          tagCheckPromises.push(tagCheckPromise);
        }
      }).then(function() {
        // Wait for ALL tag checks to complete before displaying results
        return Promise.all(tagCheckPromises);
      }).then(function() {
        // All tag checks complete - display results
        displayResults(devicesWithTag, ords.length);
      }).catch(function(err) {
        resultDiv.innerHTML = '‚ùå Error during batch resolve or tag check: ' + (err.message || err);
        console.error('‚ùå Batch Resolve Error:', err);
      });
    }
    
    function traverseTreeForDevices(baja, networkFolder, networkPath, resultDiv) {
      resultDiv.innerHTML = 'Traversing network folder (max depth: 5, scope: BacnetNetwork)...<br>' +
        'Collecting components to check...';
      
      const devicesWithTag = [];
      const componentsToCheck = [];
      const maxDepth = 5; // Limit traversal depth to 5 levels
      const checkedPaths = new Set(); // Track paths we've already added to avoid duplicates
      
      const systemFolders = ['Alarms', 'status', 'enabled', 'faultCause', 
        'health', 'alarmSourceInfo', 'address', 'config', 'enumerationList'];
      
      // Recursively traverse folder tree with depth limit
      // We collect all component paths first, then batch resolve them
      function traverseFolder(folder, currentPath, depth) {
        if (depth > maxDepth) {
          return; // Stop at max depth
        }
        
        try {
          const slots = folder.getSlots();
          if (!slots) {
            return;
          }
          
          slots.each(function(slot) {
            try {
              const slotName = slot.getName ? slot.getName() : slot.toString();
              if (!slotName) {
                return;
              }
              
              const childPath = currentPath + '/' + slotName;
              
              // Skip if already checked (avoid duplicates)
              if (checkedPaths.has(childPath)) {
                return;
              }
              
              // Skip system folders
              if (systemFolders.some(function(sys) { return sys.toLowerCase() === slotName.toLowerCase(); })) {
                return;
              }
              
              checkedPaths.add(childPath);
              const childOrd = 'station:|slot:' + childPath;
              componentsToCheck.push({
                path: childPath,
                ord: childOrd,
                name: slotName,
                depth: depth
              });
            } catch(e) {
              console.warn('Error traversing slot:', e);
            }
          });
        } catch(e) {
          console.warn('Error getting slots from folder:', currentPath, e);
        }
      }
      
      // First pass: Collect all component paths by traversing recursively
      // We need to resolve components to check if they're folders, but we'll do that in batches
      function collectComponentsRecursively(folder, currentPath, depth) {
        if (depth > maxDepth) {
          return;
        }
        
        traverseFolder(folder, currentPath, depth);
        
        // Now we need to resolve components to see if they're folders and continue traversal
        // But we'll do this efficiently by batching
        const currentLevelPaths = [];
        const slots = folder.getSlots();
        if (slots) {
          slots.each(function(slot) {
            try {
              const slotName = slot.getName ? slot.getName() : slot.toString();
              if (!slotName) return;
              
              const childPath = currentPath + '/' + slotName;
              if (checkedPaths.has(childPath) || 
                  systemFolders.some(function(sys) { return sys.toLowerCase() === slotName.toLowerCase(); })) {
                return;
              }
              
              currentLevelPaths.push({
                path: childPath,
                ord: 'station:|slot:' + childPath,
                name: slotName
              });
            } catch(e) {
              // Skip errors
            }
          });
        }
        
        // If we have paths at this level and haven't reached max depth, resolve them to continue traversal
        if (currentLevelPaths.length > 0 && depth < maxDepth) {
          const ords = currentLevelPaths.map(function(p) { return p.ord; });
          const batchResolve = new baja.BatchResolve(ords);
          
          return batchResolve.resolve({
            each: function(component, index) {
              const pathInfo = currentLevelPaths[index];
              if (!pathInfo) return;
              
              // Check if this component has slots (is a folder) and continue traversal
              if (component.getSlots && typeof component.getSlots === 'function') {
                collectComponentsRecursively(component, pathInfo.path, depth + 1);
              }
            }
          });
        }
      }
      
      // Start recursive collection from network folder (depth 0)
      collectComponentsRecursively(networkFolder, networkPath, 0).then(function() {
        console.log('Found', componentsToCheck.length, 'components to check (max depth:', maxDepth + ')');
        resultDiv.innerHTML = 'Found ' + componentsToCheck.length + ' components<br>' +
          'Batch resolving and checking tags...';
        
        // Now batch resolve all collected components and check tags
        const ords = componentsToCheck.map(function(comp) { return comp.ord; });
        const batchResolve = new baja.BatchResolve(ords);
        
        return batchResolve.resolve({
          each: function(component, index) {
            const compInfo = componentsToCheck[index];
            if (!compInfo) return;
            
            // Check tags for this component
            component.tags().then(function(tags) {
              try {
                const allTags = tags.getAll ? tags.getAll() : [];
                const deviceTag = allTags.find(function(tag) {
                  if (!tag.getId) return false;
                  const tagId = tag.getId();
                  if (typeof tagId === 'object' && tagId.$qname) {
                    return tagId.$qname === 'n:device';
                  } else if (typeof tagId === 'string') {
                    return tagId === 'n:device';
                  }
                  if (tagId.$dict === 'n' && tagId.$name === 'device') {
                    return true;
                  }
                  return false;
                });
                
                if (deviceTag) {
                  const deviceName = component.getDisplayName ? component.getDisplayName() : 
                                   (component.getName ? component.getName() : 'Unknown');
                  const tagValue = deviceTag.getValue ? deviceTag.getValue().toString() : '';
                  const path = compInfo.path;
                  const tagId = deviceTag.getId();
                  const tagIdStr = (tagId && tagId.$qname) ? tagId.$qname : 
                                  (typeof tagId === 'string' ? tagId : 'unknown');
                  
                  devicesWithTag.push({
                    name: deviceName,
                    path: path,
                    ord: compInfo.ord,
                    tagValue: tagValue,
                    tagId: tagIdStr,
                    depth: compInfo.depth,
                    allTags: allTags.map(function(t) {
                      const tId = t.getId();
                      const tIdStr = (tId && tId.$qname) ? tId.$qname : 
                                    (typeof tId === 'string' ? tId : 'unknown');
                      return {
                        id: tIdStr,
                        value: t.getValue ? t.getValue().toString() : ''
                      };
                    })
                  });
                  
                  console.log('‚úÖ Found device with n:device tag:', deviceName, 'at', path, '(depth:', compInfo.depth + ')');
                }
              } catch(e) {
                console.warn('Error checking tags for', compInfo.path, e);
              }
            }).catch(function(err) {
              console.warn('Tags call failed for', compInfo.path, err);
            });
          }
        });
      }).then(function() {
        // All components resolved - display results
        displayResults(devicesWithTag, componentsToCheck.length);
      }).catch(function(err) {
        resultDiv.innerHTML = '‚ùå Error during traversal/resolve: ' + (err.message || err);
        console.error('‚ùå Error:', err);
      });
    }
    
    function displayResults(devices, totalChecked) {
      const resultDiv = document.getElementById('result');
      
      if (devices.length === 0) {
        resultDiv.innerHTML = '‚ùå No devices found with n:device tag<br>' +
          'Checked ' + totalChecked + ' device paths<br>' +
          'Note: Devices may not have the n:device tag set, or tag checking may have failed.';
        return;
      }
      
      let html = '<h3>‚úÖ Found ' + devices.length + ' device(s) with n:device tag</h3>';
      html += '<p>Checked ' + totalChecked + ' total device paths</p>';
      
      if (devices.length === totalChecked) {
        html += '<p style="color:#4CAF50;">‚úì All checked devices have the n:device tag!</p>';
      } else {
        html += '<p style="color:#FF9800;">Note: ' + (totalChecked - devices.length) + ' device(s) were checked but don\'t have the n:device tag.</p>';
      }
      
      html += '<p style="color:#888; font-size:12px; margin-top:10px;"><strong>Method:</strong> Traversed device tree using getSlots() to find ALL devices, ' +
        'regardless of whether they have control points.</p>';
      
      devices.forEach(function(device, index) {
        html += '<div class="device-item">';
        html += '<strong>' + (index + 1) + '. ' + device.name + '</strong><br>';
        html += '<span style="color:#888;">Path: ' + device.path + '</span><br>';
        html += '<span class="tag-info">n:device = "' + device.tagValue + '"</span><br>';
        
        // Show all tags (limit to first 10 for readability)
        if (device.allTags && device.allTags.length > 0) {
          html += '<div style="margin-left:20px; margin-top:5px; font-size:12px; color:#888;">';
          html += '<strong>All tags (' + device.allTags.length + '):</strong> ';
          const tagsToShow = device.allTags.slice(0, 10);
          html += tagsToShow.map(function(t) {
            return t.id + '=' + (t.value.length > 30 ? t.value.substring(0, 30) + '...' : t.value);
          }).join(', ');
          if (device.allTags.length > 10) {
            html += ' <span style="color:#666;">(+' + (device.allTags.length - 10) + ' more)</span>';
          }
          html += '</div>';
        }
        
        html += '</div>';
      });
      
      resultDiv.innerHTML = html;
    }
  </script>
</body>
</html>

