<!-- @noSnoop -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Find Devices by Tag - BQL Method</title>
  <style>
    body { font-family: Arial; background: #1e1e1e; color: #fff; padding: 20px; }
    button { background: #4CAF50; color: white; border: none; padding: 10px 20px; cursor: pointer; margin: 5px; }
    #result { background: #2d2d2d; padding: 15px; border-radius: 4px; margin-top: 10px; font-family: monospace; min-height: 100px; }
    .device-item { margin: 10px 0; padding: 10px; background: #3d3d3d; border-radius: 4px; }
    .debug { color: #888; font-size: 0.9em; margin-top: 10px; }
    .timing { color: #4CAF50; font-weight: bold; }
  </style>
</head>
<body>
  <h1>Find Devices by Tag - BQL Method</h1>
  <p>This test uses BQL to find control points, extracts device paths, then checks tags.</p>
  
  <button onclick="findDevicesBQL()">Find Devices (BQL)</button>
  <div id="result">Click button to test BQL method</div>

  <script type='text/javascript' src='/requirejs/config.js'></script>
  <script type='text/javascript' src='/module/js/com/tridium/js/ext/require/require.min.js'></script>

  <script>
    /**
     * BQL Method: Find devices by querying control points, extracting device paths, then checking tags
     * 
     * Strategy:
     * 1. Use BQL to query control points: 'station:|slot:/Drivers/BacnetNetwork|bql:select slotPath from control:ControlPoint'
     * 2. Extract unique device paths from slotPath
     * 3. Batch resolve device ORDs
     * 4. Check tags to find devices with n:device tag
     */
    
    window.findDevicesBQL = function() {
      const resultDiv = document.getElementById('result');
      resultDiv.innerHTML = 'Loading Baja...';
      
      const timings = {
        start: Date.now(),
        bqlQueryStart: null,
        bqlQueryEnd: null,
        pathExtractionStart: null,
        pathExtractionEnd: null,
        batchResolveStart: null,
        batchResolveEnd: null,
        tagCheckStart: null,
        tagCheckEnd: null,
        totalEnd: null
      };
      
      if (typeof require !== 'undefined') {
        require(["baja!", "Promise"], function (baja, Promise) {
          runBQLTest(baja, timings);
        }, function(err) {
          resultDiv.innerHTML = 'Error loading Baja: ' + (err.message || err);
        });
      } else {
        var attempts = 0;
        var checkBaja = setInterval(function() {
          attempts++;
          if (typeof baja !== 'undefined') {
            clearInterval(checkBaja);
            runBQLTest(baja, timings);
          } else if (attempts > 20) {
            clearInterval(checkBaja);
            resultDiv.innerHTML = 'Error: Baja not available';
          }
        }, 500);
      }
    };
    
    function runBQLTest(baja, timings) {
      const resultDiv = document.getElementById('result');
      resultDiv.innerHTML = 'üîç Starting BQL query...';
      
      timings.bqlQueryStart = Date.now();
      
      // Try multiple BQL strategies:
      // Strategy 1: Query devices directly (if possible)
      // Strategy 2: Query control points and extract device paths
      
      // First, try to query devices directly by type
      // Note: This may not work - BQL might not support device queries
      const deviceBql = "station:|slot:/Drivers/BacnetNetwork|bql:select slotPath from bacnet:BacnetDevice";
      const pointsBql = "station:|slot:/Drivers/BacnetNetwork|bql:select slotPath from control:ControlPoint";
      
      // Try device query first, fallback to points query
      let bql = deviceBql;
      let queryType = 'device';
      
      new Promise(function(resolve, reject) {
        const timeout = setTimeout(function() { 
          reject(new Error('BQL query timeout (60s)')); 
        }, 60000);
        
        baja.Ord.make(bql).get().then(function(table) {
          if (!table) {
            throw new Error('BQL query returned null/undefined table');
          }
          
          clearTimeout(timeout);
          const slotPaths = [];
          
          return new Promise(function(resolveCursor, rejectCursor) {
            try {
              table.cursor({
                limit: 10000,
                each: function(record) {
                  try {
                    let slotPath = record.get('slotPath')?.toString() || '';
                    if (slotPath) {
                      // CRITICAL: Clean path to avoid "slot:slot:" duplication
                      slotPath = slotPath.replace(/^slot:/, '').trim();
                      if (slotPath) {
                        slotPaths.push(slotPath);
                      }
                    }
                  } catch(e) {
                    console.warn('Error processing record:', e);
                  }
                },
                after: function() {
                  timings.bqlQueryEnd = Date.now();
                  const bqlTime = timings.bqlQueryEnd - timings.bqlQueryStart;
                  console.log('‚è±Ô∏è BQL Query Time:', bqlTime + 'ms', 'Found', slotPaths.length, queryType + '(s)');
                  
                  resolveCursor({ slotPaths: slotPaths, queryType: queryType });
                }
              });
            } catch(cursorErr) {
              rejectCursor(cursorErr);
            }
          });
        }).then(function(result) {
          resolve(result);
        }).catch(function(err) {
          // If device query failed, try points query
          if (queryType === 'device') {
            console.log('Device query failed, trying points query:', err);
            bql = pointsBql;
            queryType = 'points';
            
            // Retry with points query
            return baja.Ord.make(bql).get().then(function(table) {
              if (!table) {
                throw new Error('BQL points query returned null/undefined table');
              }
              
              clearTimeout(timeout);
              const slotPaths = [];
              
              return new Promise(function(resolveCursor, rejectCursor) {
                try {
                  table.cursor({
                    limit: 10000,
                    each: function(record) {
                      try {
                        let slotPath = record.get('slotPath')?.toString() || '';
                        if (slotPath) {
                          // CRITICAL: Clean path to avoid "slot:slot:" duplication
                          slotPath = slotPath.replace(/^slot:/, '').trim();
                          if (slotPath) {
                            slotPaths.push(slotPath);
                          }
                        }
                      } catch(e) {
                        console.warn('Error processing record:', e);
                      }
                    },
                    after: function() {
                      timings.bqlQueryEnd = Date.now();
                      const bqlTime = timings.bqlQueryEnd - timings.bqlQueryStart;
                      console.log('‚è±Ô∏è BQL Query Time:', bqlTime + 'ms', 'Found', slotPaths.length, queryType);
                      
                      resolveCursor({ slotPaths: slotPaths, queryType: queryType });
                    }
                  });
                } catch(cursorErr) {
                  rejectCursor(cursorErr);
                }
              });
            }).then(function(result) {
              resolve(result);
            }).catch(function(retryErr) {
              clearTimeout(timeout);
              timings.bqlQueryEnd = Date.now();
              reject(new Error('Both device and points queries failed. Device error: ' + err.message + ', Points error: ' + (retryErr.message || retryErr)));
            });
          } else {
            clearTimeout(timeout);
            timings.bqlQueryEnd = Date.now();
            reject(err);
          }
        });
      }).then(function(result) {
        if (!result || !result.slotPaths) {
          throw new Error('BQL query returned invalid result structure: ' + JSON.stringify(result));
        }
        
        const slotPaths = result.slotPaths;
        const queryType = result.queryType || 'unknown';
        
        if (!Array.isArray(slotPaths)) {
          throw new Error('slotPaths is not an array: ' + typeof slotPaths);
        }
        
        resultDiv.innerHTML = '‚úÖ BQL query successful! (' + queryType + ' query)<br>' +
          'Found ' + slotPaths.length + ' ' + queryType + '<br>' +
          '‚è±Ô∏è BQL Query Time: ' + (timings.bqlQueryEnd - timings.bqlQueryStart) + 'ms<br>';
        
        timings.pathExtractionStart = Date.now();
        
        let devicePaths;
        let deviceOrds;
        
        if (queryType === 'device') {
          // Direct device query - slotPaths are already device paths!
          // CRITICAL: Clean paths to avoid "slot:slot:" duplication
          devicePaths = new Set(slotPaths.map(function(path) {
            // Remove any "slot:" prefix to avoid duplication
            let cleanPath = path.toString().replace(/^slot:/, '').trim();
            // Ensure path starts with /
            cleanPath = cleanPath.startsWith('/') ? cleanPath : '/' + cleanPath;
            return cleanPath;
          }));
          
          timings.pathExtractionEnd = Date.now();
          const extractionTime = timings.pathExtractionEnd - timings.pathExtractionStart;
          console.log('‚è±Ô∏è Path Processing Time:', extractionTime + 'ms', 'Found', devicePaths.size, 'devices');
          
          resultDiv.innerHTML += '<br>‚úÖ Found ' + devicePaths.size + ' devices directly<br>' +
            '‚è±Ô∏è Path Processing Time: ' + extractionTime + 'ms<br>' +
            'Batch resolving devices...';
        } else {
          // Points query - need to extract device paths
          resultDiv.innerHTML += 'Extracting device paths...';
          
          // Extract unique device paths from slotPaths
          // Device path is typically: /Drivers/BacnetNetwork/DeviceName/points/PointName
          // We want: /Drivers/BacnetNetwork/DeviceName
          devicePaths = new Set();
          
          slotPaths.forEach(function(slotPath) {
            // Remove leading slash if present for processing
            let path = slotPath.startsWith('/') ? slotPath.substring(1) : slotPath;
            
            // Split by '/'
            const parts = path.split('/');
            
            // Device path is typically: Drivers/BacnetNetwork/DeviceName/points/...
            // Or: Drivers/BacnetNetwork/DeviceName/Monitor/...
            // We want everything up to (but not including) 'points' or 'Monitor' or other system folders
            const systemFolders = ['points', 'Monitor', 'Alarms', 'status', 'enabled'];
            let devicePathParts = [];
            
            for (let i = 0; i < parts.length; i++) {
              const part = parts[i];
              if (systemFolders.includes(part)) {
                break; // Stop at system folder
              }
              devicePathParts.push(part);
            }
            
            if (devicePathParts.length >= 3) { // At least Drivers/BacnetNetwork/DeviceName
              const devicePath = '/' + devicePathParts.join('/');
              devicePaths.add(devicePath);
            }
          });
          
          timings.pathExtractionEnd = Date.now();
          const extractionTime = timings.pathExtractionEnd - timings.pathExtractionStart;
          console.log('‚è±Ô∏è Path Extraction Time:', extractionTime + 'ms', 'Found', devicePaths.size, 'unique device paths');
          
          resultDiv.innerHTML += '<br>‚úÖ Extracted ' + devicePaths.size + ' unique device paths<br>' +
            '‚è±Ô∏è Path Extraction Time: ' + extractionTime + 'ms<br>' +
            'Batch resolving devices...';
        }
        
        timings.batchResolveStart = Date.now();
        
        // Convert device paths to ORDs
        // CRITICAL: Ensure paths are clean (no slot: prefix) before constructing ORDs
        deviceOrds = Array.from(devicePaths).map(function(path) {
          // Double-check: remove any slot: prefix
          let cleanPath = path.toString().replace(/^slot:/, '').trim();
          // Ensure starts with /
          cleanPath = cleanPath.startsWith('/') ? cleanPath : '/' + cleanPath;
          // Construct ORD
          const ord = 'station:|slot:' + cleanPath;
          return ord;
        }).filter(function(ord) {
          // Filter out any invalid ORDs
          return ord && !ord.includes('slot:slot:');
        });
        
        // Batch resolve all device ORDs
        const batchResolve = new baja.BatchResolve(deviceOrds);
        
        return batchResolve.resolve({
          each: function(component, index) {
            // Component resolved
          }
        }).then(function() {
          timings.batchResolveEnd = Date.now();
          const batchTime = timings.batchResolveEnd - timings.batchResolveStart;
          console.log('‚è±Ô∏è Batch Resolve Time:', batchTime + 'ms');
          
          resultDiv.innerHTML += '<br>‚úÖ Batch resolve complete<br>' +
            '‚è±Ô∏è Batch Resolve Time: ' + batchTime + 'ms<br>' +
            'Checking tags...';
          
          timings.tagCheckStart = Date.now();
          
          // Check tags for all devices
          const devicesWithTag = [];
          const tagPromises = [];
          
          const batchResolve2 = new baja.BatchResolve(deviceOrds);
          return batchResolve2.resolve({
            each: function(component, index) {
              const ord = deviceOrds[index];
              
              // Check tags
              const tagPromise = component.tags().then(function(tags) {
                const allTags = tags.getAll ? tags.getAll() : [];
                const deviceTag = allTags.find(function(tag) {
                  if (!tag.getId) return false;
                  const tagId = tag.getId();
                  if (typeof tagId === 'object' && tagId.$qname) {
                    return tagId.$qname === 'n:device';
                  } else if (typeof tagId === 'string') {
                    return tagId === 'n:device';
                  }
                  if (tagId.$dict === 'n' && tagId.$name === 'device') {
                    return true;
                  }
                  return false;
                });
                
                if (deviceTag) {
                  const deviceName = component.getDisplayName ? component.getDisplayName() : 
                                   (component.getName ? component.getName() : 'Unknown');
                  const path = ord.replace('station:|slot:', '');
                  
                  devicesWithTag.push({
                    name: deviceName,
                    path: path,
                    ord: ord
                  });
                }
              }).catch(function(err) {
                console.warn('Error checking tags for', ord, err);
              });
              
              tagPromises.push(tagPromise);
            }
          }).then(function() {
            // Wait for all tag checks to complete
            return Promise.all(tagPromises);
          }).then(function() {
            timings.tagCheckEnd = Date.now();
            timings.totalEnd = Date.now();
            
            const tagCheckTime = timings.tagCheckEnd - timings.tagCheckStart;
            const totalTime = timings.totalEnd - timings.start;
            
            console.log('‚è±Ô∏è Tag Check Time:', tagCheckTime + 'ms');
            console.log('‚è±Ô∏è Total Time:', totalTime + 'ms');
            console.log('‚úÖ Found', devicesWithTag.length, 'devices with n:device tag');
            
            // Display results with timing breakdown
            let html = '<div class="timing">‚è±Ô∏è TIMING BREAKDOWN:</div>';
            html += '<div class="debug">';
            html += 'BQL Query: ' + (timings.bqlQueryEnd - timings.bqlQueryStart) + 'ms<br>';
            html += 'Path Extraction: ' + (timings.pathExtractionEnd - timings.pathExtractionStart) + 'ms<br>';
            html += 'Batch Resolve: ' + (timings.batchResolveEnd - timings.batchResolveStart) + 'ms<br>';
            html += 'Tag Check: ' + tagCheckTime + 'ms<br>';
            html += '<strong>Total Time: ' + totalTime + 'ms</strong><br>';
            html += '</div>';
            
            html += '<div style="margin-top: 20px;"><strong>‚úÖ Found ' + devicesWithTag.length + ' device(s) with n:device tag</strong></div>';
            
            devicesWithTag.forEach(function(device) {
              html += '<div class="device-item">' + device.name + ' (' + device.path + ')</div>';
            });
            
            resultDiv.innerHTML = html;
          });
        });
      }).catch(function(err) {
        timings.totalEnd = Date.now();
        const totalTime = timings.totalEnd - timings.start;
        
        resultDiv.innerHTML = '‚ùå BQL Error: ' + (err.message || err) + '<br>' +
          '<div class="debug">Total time before error: ' + totalTime + 'ms</div>';
        console.error('‚ùå BQL Error:', err);
      });
    }
  </script>
</body>
</html>

